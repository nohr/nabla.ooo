{"ast":null,"code":"module.exports = ConeEquation;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Mat3 = require('../math/Mat3');\n\nvar Equation = require('./Equation');\n/**\n * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.\n * @class ConeEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA] Local axis in A\n * @param {Vec3} [options.axisB] Local axis in B\n * @param {Vec3} [options.angle] The \"cone angle\" to keep\n * @param {number} [options.maxForce=1e6]\n * @extends Equation\n */\n\n\nfunction ConeEquation(bodyA, bodyB, options) {\n  options = options || {};\n  var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;\n  Equation.call(this, bodyA, bodyB, -maxForce, maxForce);\n  this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n  this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n  /**\n   * The cone angle to keep\n   * @property {number} angle\n   */\n\n  this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;\n}\n\nConeEquation.prototype = new Equation();\nConeEquation.prototype.constructor = ConeEquation;\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nConeEquation.prototype.computeB = function (h) {\n  var a = this.a,\n      b = this.b,\n      ni = this.axisA,\n      nj = this.axisB,\n      nixnj = tmpVec1,\n      njxni = tmpVec2,\n      GA = this.jacobianElementA,\n      GB = this.jacobianElementB; // Caluclate cross products\n\n  ni.cross(nj, nixnj);\n  nj.cross(ni, njxni); // The angle between two vector is:\n  // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b\n  // g = a * b\n  // gdot = (b x a) * wi + (a x b) * wj\n  // G = [0 bxa 0 axb]\n  // W = [vi wi vj wj]\n\n  GA.rotational.copy(njxni);\n  GB.rotational.copy(nixnj);\n  var g = Math.cos(this.angle) - ni.dot(nj),\n      GW = this.computeGW(),\n      GiMf = this.computeGiMf();\n  var B = -g * a - GW * b - h * GiMf;\n  return B;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/ConeEquation.js"],"names":["module","exports","ConeEquation","Vec3","require","Mat3","Equation","bodyA","bodyB","options","maxForce","call","axisA","clone","axisB","angle","prototype","constructor","tmpVec1","tmpVec2","computeB","h","a","b","ni","nj","nixnj","njxni","GA","jacobianElementA","GB","jacobianElementB","cross","rotational","copy","g","Math","cos","dot","GW","computeGW","GiMf","computeGiMf","B"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,YAAjB;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,YAAT,CAAsBK,KAAtB,EAA6BC,KAA7B,EAAoCC,OAApC,EAA4C;AACxCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIC,QAAQ,GAAG,OAAOD,OAAO,CAACC,QAAf,KAA6B,WAA7B,GAA2CD,OAAO,CAACC,QAAnD,GAA8D,GAA7E;AAEAJ,EAAAA,QAAQ,CAACK,IAAT,CAAc,IAAd,EAAmBJ,KAAnB,EAAyBC,KAAzB,EAA+B,CAACE,QAAhC,EAA0CA,QAA1C;AAEA,OAAKE,KAAL,GAAaH,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAR,CAAcC,KAAd,EAAhB,GAAwC,IAAIV,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAArD;AACA,OAAKW,KAAL,GAAaL,OAAO,CAACK,KAAR,GAAgBL,OAAO,CAACK,KAAR,CAAcD,KAAd,EAAhB,GAAwC,IAAIV,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAArD;AAEA;AACJ;AACA;AACA;;AACI,OAAKY,KAAL,GAAa,OAAON,OAAO,CAACM,KAAf,KAA0B,WAA1B,GAAwCN,OAAO,CAACM,KAAhD,GAAwD,CAArE;AACH;;AAEDb,YAAY,CAACc,SAAb,GAAyB,IAAIV,QAAJ,EAAzB;AACAJ,YAAY,CAACc,SAAb,CAAuBC,WAAvB,GAAqCf,YAArC;AAEA,IAAIgB,OAAO,GAAG,IAAIf,IAAJ,EAAd;AACA,IAAIgB,OAAO,GAAG,IAAIhB,IAAJ,EAAd;;AAEAD,YAAY,CAACc,SAAb,CAAuBI,QAAvB,GAAkC,UAASC,CAAT,EAAW;AACzC,MAAIC,CAAC,GAAG,KAAKA,CAAb;AAAA,MACIC,CAAC,GAAG,KAAKA,CADb;AAAA,MAGIC,EAAE,GAAG,KAAKZ,KAHd;AAAA,MAIIa,EAAE,GAAG,KAAKX,KAJd;AAAA,MAMIY,KAAK,GAAGR,OANZ;AAAA,MAOIS,KAAK,GAAGR,OAPZ;AAAA,MASIS,EAAE,GAAG,KAAKC,gBATd;AAAA,MAUIC,EAAE,GAAG,KAAKC,gBAVd,CADyC,CAazC;;AACAP,EAAAA,EAAE,CAACQ,KAAH,CAASP,EAAT,EAAaC,KAAb;AACAD,EAAAA,EAAE,CAACO,KAAH,CAASR,EAAT,EAAaG,KAAb,EAfyC,CAiBzC;AACA;AAEA;AACA;AACA;AACA;;AACAC,EAAAA,EAAE,CAACK,UAAH,CAAcC,IAAd,CAAmBP,KAAnB;AACAG,EAAAA,EAAE,CAACG,UAAH,CAAcC,IAAd,CAAmBR,KAAnB;AAEA,MAAIS,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKtB,KAAd,IAAuBS,EAAE,CAACc,GAAH,CAAOb,EAAP,CAA/B;AAAA,MACIc,EAAE,GAAG,KAAKC,SAAL,EADT;AAAA,MAEIC,IAAI,GAAG,KAAKC,WAAL,EAFX;AAIA,MAAIC,CAAC,GAAG,CAAER,CAAF,GAAMb,CAAN,GAAUiB,EAAE,GAAGhB,CAAf,GAAmBF,CAAC,GAAGoB,IAA/B;AAEA,SAAOE,CAAP;AACH,CAlCD","sourcesContent":["module.exports = ConeEquation;\n\nvar Vec3 = require('../math/Vec3');\nvar Mat3 = require('../math/Mat3');\nvar Equation = require('./Equation');\n\n/**\n * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.\n * @class ConeEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA] Local axis in A\n * @param {Vec3} [options.axisB] Local axis in B\n * @param {Vec3} [options.angle] The \"cone angle\" to keep\n * @param {number} [options.maxForce=1e6]\n * @extends Equation\n */\nfunction ConeEquation(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);\n\n    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n\n    /**\n     * The cone angle to keep\n     * @property {number} angle\n     */\n    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;\n}\n\nConeEquation.prototype = new Equation();\nConeEquation.prototype.constructor = ConeEquation;\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nConeEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n\n        ni = this.axisA,\n        nj = this.axisB,\n\n        nixnj = tmpVec1,\n        njxni = tmpVec2,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // Caluclate cross products\n    ni.cross(nj, nixnj);\n    nj.cross(ni, njxni);\n\n    // The angle between two vector is:\n    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b\n\n    // g = a * b\n    // gdot = (b x a) * wi + (a x b) * wj\n    // G = [0 bxa 0 axb]\n    // W = [vi wi vj wj]\n    GA.rotational.copy(njxni);\n    GB.rotational.copy(nixnj);\n\n    var g = Math.cos(this.angle) - ni.dot(nj),\n        GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h * GiMf;\n\n    return B;\n};\n\n"]},"metadata":{},"sourceType":"script"}