{"ast":null,"code":"var AABB = require('../collision/AABB');\n\nvar Vec3 = require('../math/Vec3');\n\nmodule.exports = Octree;\n/**\n * @class OctreeNode\n * @param {object} [options]\n * @param {Octree} [options.root]\n * @param {AABB} [options.aabb]\n */\n\nfunction OctreeNode(options) {\n  options = options || {};\n  /**\n   * The root node\n   * @property {OctreeNode} root\n   */\n\n  this.root = options.root || null;\n  /**\n   * Boundary of this node\n   * @property {AABB} aabb\n   */\n\n  this.aabb = options.aabb ? options.aabb.clone() : new AABB();\n  /**\n   * Contained data at the current node level.\n   * @property {Array} data\n   */\n\n  this.data = [];\n  /**\n   * Children to this node\n   * @property {Array} children\n   */\n\n  this.children = [];\n}\n/**\n * @class Octree\n * @param {AABB} aabb The total AABB of the tree\n * @param {object} [options]\n * @param {number} [options.maxDepth=8]\n * @extends OctreeNode\n */\n\n\nfunction Octree(aabb, options) {\n  options = options || {};\n  options.root = null;\n  options.aabb = aabb;\n  OctreeNode.call(this, options);\n  /**\n   * Maximum subdivision depth\n   * @property {number} maxDepth\n   */\n\n  this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;\n}\n\nOctree.prototype = new OctreeNode();\n\nOctreeNode.prototype.reset = function (aabb, options) {\n  this.children.length = this.data.length = 0;\n};\n/**\n * Insert data into this node\n * @method insert\n * @param  {AABB} aabb\n * @param  {object} elementData\n * @return {boolean} True if successful, otherwise false\n */\n\n\nOctreeNode.prototype.insert = function (aabb, elementData, level) {\n  var nodeData = this.data;\n  level = level || 0; // Ignore objects that do not belong in this node\n\n  if (!this.aabb.contains(aabb)) {\n    return false; // object cannot be added\n  }\n\n  var children = this.children;\n\n  if (level < (this.maxDepth || this.root.maxDepth)) {\n    // Subdivide if there are no children yet\n    var subdivided = false;\n\n    if (!children.length) {\n      this.subdivide();\n      subdivided = true;\n    } // add to whichever node will accept it\n\n\n    for (var i = 0; i !== 8; i++) {\n      if (children[i].insert(aabb, elementData, level + 1)) {\n        return true;\n      }\n    }\n\n    if (subdivided) {\n      // No children accepted! Might as well just remove em since they contain none\n      children.length = 0;\n    }\n  } // Too deep, or children didnt want it. add it in current node\n\n\n  nodeData.push(elementData);\n  return true;\n};\n\nvar halfDiagonal = new Vec3();\n/**\n * Create 8 equally sized children nodes and put them in the .children array.\n * @method subdivide\n */\n\nOctreeNode.prototype.subdivide = function () {\n  var aabb = this.aabb;\n  var l = aabb.lowerBound;\n  var u = aabb.upperBound;\n  var children = this.children;\n  children.push(new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(0, 0, 0)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(1, 0, 0)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(1, 1, 0)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(1, 1, 1)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(0, 1, 1)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(0, 0, 1)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(1, 0, 1)\n    })\n  }), new OctreeNode({\n    aabb: new AABB({\n      lowerBound: new Vec3(0, 1, 0)\n    })\n  }));\n  u.vsub(l, halfDiagonal);\n  halfDiagonal.scale(0.5, halfDiagonal);\n  var root = this.root || this;\n\n  for (var i = 0; i !== 8; i++) {\n    var child = children[i]; // Set current node as root\n\n    child.root = root; // Compute bounds\n\n    var lowerBound = child.aabb.lowerBound;\n    lowerBound.x *= halfDiagonal.x;\n    lowerBound.y *= halfDiagonal.y;\n    lowerBound.z *= halfDiagonal.z;\n    lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal\n\n    lowerBound.vadd(halfDiagonal, child.aabb.upperBound);\n  }\n};\n/**\n * Get all data, potentially within an AABB\n * @method aabbQuery\n * @param  {AABB} aabb\n * @param  {array} result\n * @return {array} The \"result\" object\n */\n\n\nOctreeNode.prototype.aabbQuery = function (aabb, result) {\n  var nodeData = this.data; // abort if the range does not intersect this node\n  // if (!this.aabb.overlaps(aabb)){\n  //     return result;\n  // }\n  // Add objects at this level\n  // Array.prototype.push.apply(result, nodeData);\n  // Add child data\n  // @todo unwrap recursion into a queue / loop, that's faster in JS\n\n  var children = this.children; // for (var i = 0, N = this.children.length; i !== N; i++) {\n  //     children[i].aabbQuery(aabb, result);\n  // }\n\n  var queue = [this];\n\n  while (queue.length) {\n    var node = queue.pop();\n\n    if (node.aabb.overlaps(aabb)) {\n      Array.prototype.push.apply(result, node.data);\n    }\n\n    Array.prototype.push.apply(queue, node.children);\n  }\n\n  return result;\n};\n\nvar tmpAABB = new AABB();\n/**\n * Get all data, potentially intersected by a ray.\n * @method rayQuery\n * @param  {Ray} ray\n * @param  {Transform} treeTransform\n * @param  {array} result\n * @return {array} The \"result\" object\n */\n\nOctreeNode.prototype.rayQuery = function (ray, treeTransform, result) {\n  // Use aabb query for now.\n  // @todo implement real ray query which needs less lookups\n  ray.getAABB(tmpAABB);\n  tmpAABB.toLocalFrame(treeTransform, tmpAABB);\n  this.aabbQuery(tmpAABB, result);\n  return result;\n};\n/**\n * @method removeEmptyNodes\n */\n\n\nOctreeNode.prototype.removeEmptyNodes = function () {\n  var queue = [this];\n\n  while (queue.length) {\n    var node = queue.pop();\n\n    for (var i = node.children.length - 1; i >= 0; i--) {\n      if (!node.children[i].data.length) {\n        node.children.splice(i, 1);\n      }\n    }\n\n    Array.prototype.push.apply(queue, node.children);\n  }\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/utils/Octree.js"],"names":["AABB","require","Vec3","module","exports","Octree","OctreeNode","options","root","aabb","clone","data","children","call","maxDepth","prototype","reset","length","insert","elementData","level","nodeData","contains","subdivided","subdivide","i","push","halfDiagonal","l","lowerBound","u","upperBound","vsub","scale","child","x","y","z","vadd","aabbQuery","result","queue","node","pop","overlaps","Array","apply","tmpAABB","rayQuery","ray","treeTransform","getAABB","toLocalFrame","removeEmptyNodes","splice"],"mappings":"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","sourcesContent":["var AABB = require('../collision/AABB');\nvar Vec3 = require('../math/Vec3');\n\nmodule.exports = Octree;\n\n/**\n * @class OctreeNode\n * @param {object} [options]\n * @param {Octree} [options.root]\n * @param {AABB} [options.aabb]\n */\nfunction OctreeNode(options){\n    options = options || {};\n\n    /**\n     * The root node\n     * @property {OctreeNode} root\n     */\n    this.root = options.root || null;\n\n    /**\n     * Boundary of this node\n     * @property {AABB} aabb\n     */\n    this.aabb = options.aabb ? options.aabb.clone() : new AABB();\n\n    /**\n     * Contained data at the current node level.\n     * @property {Array} data\n     */\n    this.data = [];\n\n    /**\n     * Children to this node\n     * @property {Array} children\n     */\n    this.children = [];\n}\n\n/**\n * @class Octree\n * @param {AABB} aabb The total AABB of the tree\n * @param {object} [options]\n * @param {number} [options.maxDepth=8]\n * @extends OctreeNode\n */\nfunction Octree(aabb, options){\n    options = options || {};\n    options.root = null;\n    options.aabb = aabb;\n    OctreeNode.call(this, options);\n\n    /**\n     * Maximum subdivision depth\n     * @property {number} maxDepth\n     */\n    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;\n}\nOctree.prototype = new OctreeNode();\n\nOctreeNode.prototype.reset = function(aabb, options){\n    this.children.length = this.data.length = 0;\n};\n\n/**\n * Insert data into this node\n * @method insert\n * @param  {AABB} aabb\n * @param  {object} elementData\n * @return {boolean} True if successful, otherwise false\n */\nOctreeNode.prototype.insert = function(aabb, elementData, level){\n    var nodeData = this.data;\n    level = level || 0;\n\n    // Ignore objects that do not belong in this node\n    if (!this.aabb.contains(aabb)){\n        return false; // object cannot be added\n    }\n\n    var children = this.children;\n\n    if(level < (this.maxDepth || this.root.maxDepth)){\n        // Subdivide if there are no children yet\n        var subdivided = false;\n        if (!children.length){\n            this.subdivide();\n            subdivided = true;\n        }\n\n        // add to whichever node will accept it\n        for (var i = 0; i !== 8; i++) {\n            if (children[i].insert(aabb, elementData, level + 1)){\n                return true;\n            }\n        }\n\n        if(subdivided){\n            // No children accepted! Might as well just remove em since they contain none\n            children.length = 0;\n        }\n    }\n\n    // Too deep, or children didnt want it. add it in current node\n    nodeData.push(elementData);\n\n    return true;\n};\n\nvar halfDiagonal = new Vec3();\n\n/**\n * Create 8 equally sized children nodes and put them in the .children array.\n * @method subdivide\n */\nOctreeNode.prototype.subdivide = function() {\n    var aabb = this.aabb;\n    var l = aabb.lowerBound;\n    var u = aabb.upperBound;\n\n    var children = this.children;\n\n    children.push(\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })\n    );\n\n    u.vsub(l, halfDiagonal);\n    halfDiagonal.scale(0.5, halfDiagonal);\n\n    var root = this.root || this;\n\n    for (var i = 0; i !== 8; i++) {\n        var child = children[i];\n\n        // Set current node as root\n        child.root = root;\n\n        // Compute bounds\n        var lowerBound = child.aabb.lowerBound;\n        lowerBound.x *= halfDiagonal.x;\n        lowerBound.y *= halfDiagonal.y;\n        lowerBound.z *= halfDiagonal.z;\n\n        lowerBound.vadd(l, lowerBound);\n\n        // Upper bound is always lower bound + halfDiagonal\n        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);\n    }\n};\n\n/**\n * Get all data, potentially within an AABB\n * @method aabbQuery\n * @param  {AABB} aabb\n * @param  {array} result\n * @return {array} The \"result\" object\n */\nOctreeNode.prototype.aabbQuery = function(aabb, result) {\n\n    var nodeData = this.data;\n\n    // abort if the range does not intersect this node\n    // if (!this.aabb.overlaps(aabb)){\n    //     return result;\n    // }\n\n    // Add objects at this level\n    // Array.prototype.push.apply(result, nodeData);\n\n    // Add child data\n    // @todo unwrap recursion into a queue / loop, that's faster in JS\n    var children = this.children;\n\n\n    // for (var i = 0, N = this.children.length; i !== N; i++) {\n    //     children[i].aabbQuery(aabb, result);\n    // }\n\n    var queue = [this];\n    while (queue.length) {\n        var node = queue.pop();\n        if (node.aabb.overlaps(aabb)){\n            Array.prototype.push.apply(result, node.data);\n        }\n        Array.prototype.push.apply(queue, node.children);\n    }\n\n    return result;\n};\n\nvar tmpAABB = new AABB();\n\n/**\n * Get all data, potentially intersected by a ray.\n * @method rayQuery\n * @param  {Ray} ray\n * @param  {Transform} treeTransform\n * @param  {array} result\n * @return {array} The \"result\" object\n */\nOctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {\n\n    // Use aabb query for now.\n    // @todo implement real ray query which needs less lookups\n    ray.getAABB(tmpAABB);\n    tmpAABB.toLocalFrame(treeTransform, tmpAABB);\n    this.aabbQuery(tmpAABB, result);\n\n    return result;\n};\n\n/**\n * @method removeEmptyNodes\n */\nOctreeNode.prototype.removeEmptyNodes = function() {\n    var queue = [this];\n    while (queue.length) {\n        var node = queue.pop();\n        for (var i = node.children.length - 1; i >= 0; i--) {\n            if(!node.children[i].data.length){\n                node.children.splice(i, 1);\n            }\n        }\n        Array.prototype.push.apply(queue, node.children);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}