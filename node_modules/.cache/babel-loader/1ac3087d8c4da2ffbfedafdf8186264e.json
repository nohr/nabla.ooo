{"ast":null,"code":"module.exports = Cylinder;\n\nvar Shape = require('./Shape');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar ConvexPolyhedron = require('./ConvexPolyhedron');\n/**\n * @class Cylinder\n * @constructor\n * @extends ConvexPolyhedron\n * @author schteppe / https://github.com/schteppe\n * @param {Number} radiusTop\n * @param {Number} radiusBottom\n * @param {Number} height\n * @param {Number} numSegments The number of segments to build the cylinder out of\n */\n\n\nfunction Cylinder(radiusTop, radiusBottom, height, numSegments) {\n  var N = numSegments,\n      verts = [],\n      axes = [],\n      faces = [],\n      bottomface = [],\n      topface = [],\n      cos = Math.cos,\n      sin = Math.sin; // First bottom point\n\n  verts.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), -height * 0.5));\n  bottomface.push(0); // First top point\n\n  verts.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), height * 0.5));\n  topface.push(1);\n\n  for (var i = 0; i < N; i++) {\n    var theta = 2 * Math.PI / N * (i + 1);\n    var thetaN = 2 * Math.PI / N * (i + 0.5);\n\n    if (i < N - 1) {\n      // Bottom\n      verts.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), -height * 0.5));\n      bottomface.push(2 * i + 2); // Top\n\n      verts.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), height * 0.5));\n      topface.push(2 * i + 3); // Face\n\n      faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);\n    } else {\n      faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect\n    } // Axis: we can cut off half of them if we have even number of segments\n\n\n    if (N % 2 === 1 || i < N / 2) {\n      axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));\n    }\n  }\n\n  faces.push(topface);\n  axes.push(new Vec3(0, 0, 1)); // Reorder bottom face\n\n  var temp = [];\n\n  for (var i = 0; i < bottomface.length; i++) {\n    temp.push(bottomface[bottomface.length - i - 1]);\n  }\n\n  faces.push(temp);\n  ConvexPolyhedron.call(this, verts, faces, axes);\n}\n\nCylinder.prototype = new ConvexPolyhedron();","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/shapes/Cylinder.js"],"names":["module","exports","Cylinder","Shape","require","Vec3","Quaternion","ConvexPolyhedron","radiusTop","radiusBottom","height","numSegments","N","verts","axes","faces","bottomface","topface","cos","Math","sin","push","i","theta","PI","thetaN","temp","length","call","prototype"],"mappings":"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","sourcesContent":["module.exports = Cylinder;\n\nvar Shape = require('./Shape');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar ConvexPolyhedron = require('./ConvexPolyhedron');\n\n/**\n * @class Cylinder\n * @constructor\n * @extends ConvexPolyhedron\n * @author schteppe / https://github.com/schteppe\n * @param {Number} radiusTop\n * @param {Number} radiusBottom\n * @param {Number} height\n * @param {Number} numSegments The number of segments to build the cylinder out of\n */\nfunction Cylinder( radiusTop, radiusBottom, height , numSegments ) {\n    var N = numSegments,\n        verts = [],\n        axes = [],\n        faces = [],\n        bottomface = [],\n        topface = [],\n        cos = Math.cos,\n        sin = Math.sin;\n\n    // First bottom point\n    verts.push(new Vec3(radiusBottom*cos(0),\n                               radiusBottom*sin(0),\n                               -height*0.5));\n    bottomface.push(0);\n\n    // First top point\n    verts.push(new Vec3(radiusTop*cos(0),\n                               radiusTop*sin(0),\n                               height*0.5));\n    topface.push(1);\n\n    for(var i=0; i<N; i++){\n        var theta = 2*Math.PI/N * (i+1);\n        var thetaN = 2*Math.PI/N * (i+0.5);\n        if(i<N-1){\n            // Bottom\n            verts.push(new Vec3(radiusBottom*cos(theta),\n                                       radiusBottom*sin(theta),\n                                       -height*0.5));\n            bottomface.push(2*i+2);\n            // Top\n            verts.push(new Vec3(radiusTop*cos(theta),\n                                       radiusTop*sin(theta),\n                                       height*0.5));\n            topface.push(2*i+3);\n\n            // Face\n            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);\n        } else {\n            faces.push([0,1, 2*i+1, 2*i]); // Connect\n        }\n\n        // Axis: we can cut off half of them if we have even number of segments\n        if(N % 2 === 1 || i < N / 2){\n            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));\n        }\n    }\n    faces.push(topface);\n    axes.push(new Vec3(0,0,1));\n\n    // Reorder bottom face\n    var temp = [];\n    for(var i=0; i<bottomface.length; i++){\n        temp.push(bottomface[bottomface.length - i - 1]);\n    }\n    faces.push(temp);\n\n    ConvexPolyhedron.call( this, verts, faces, axes );\n}\n\nCylinder.prototype = new ConvexPolyhedron();\n"]},"metadata":{},"sourceType":"script"}