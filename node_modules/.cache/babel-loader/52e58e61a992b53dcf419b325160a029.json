{"ast":null,"code":"module.exports = Ray;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Transform = require('../math/Transform');\n\nvar ConvexPolyhedron = require('../shapes/ConvexPolyhedron');\n\nvar Box = require('../shapes/Box');\n\nvar RaycastResult = require('../collision/RaycastResult');\n\nvar Shape = require('../shapes/Shape');\n\nvar AABB = require('../collision/AABB');\n/**\n * A line in 3D space that intersects bodies and return points.\n * @class Ray\n * @constructor\n * @param {Vec3} from\n * @param {Vec3} to\n */\n\n\nfunction Ray(from, to) {\n  /**\n   * @property {Vec3} from\n   */\n  this.from = from ? from.clone() : new Vec3();\n  /**\n   * @property {Vec3} to\n   */\n\n  this.to = to ? to.clone() : new Vec3();\n  /**\n   * @private\n   * @property {Vec3} _direction\n   */\n\n  this._direction = new Vec3();\n  /**\n   * The precision of the ray. Used when checking parallelity etc.\n   * @property {Number} precision\n   */\n\n  this.precision = 0.0001;\n  /**\n   * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n   * @property {Boolean} checkCollisionResponse\n   */\n\n  this.checkCollisionResponse = true;\n  /**\n   * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n   * @property {Boolean} skipBackfaces\n   */\n\n  this.skipBackfaces = false;\n  /**\n   * @property {number} collisionFilterMask\n   * @default -1\n   */\n\n  this.collisionFilterMask = -1;\n  /**\n   * @property {number} collisionFilterGroup\n   * @default -1\n   */\n\n  this.collisionFilterGroup = -1;\n  /**\n   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.\n   * @property {number} mode\n   */\n\n  this.mode = Ray.ANY;\n  /**\n   * Current result object.\n   * @property {RaycastResult} result\n   */\n\n  this.result = new RaycastResult();\n  /**\n   * Will be set to true during intersectWorld() if the ray hit anything.\n   * @property {Boolean} hasHit\n   */\n\n  this.hasHit = false;\n  /**\n   * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n   * @property {Function} callback\n   */\n\n  this.callback = function (result) {};\n}\n\nRay.prototype.constructor = Ray;\nRay.CLOSEST = 1;\nRay.ANY = 2;\nRay.ALL = 4;\nvar tmpAABB = new AABB();\nvar tmpArray = [];\n/**\n * Do itersection against all bodies in the given World.\n * @method intersectWorld\n * @param  {World} world\n * @param  {object} options\n * @return {Boolean} True if the ray hit anything, otherwise false.\n */\n\nRay.prototype.intersectWorld = function (world, options) {\n  this.mode = options.mode || Ray.ANY;\n  this.result = options.result || new RaycastResult();\n  this.skipBackfaces = !!options.skipBackfaces;\n  this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;\n  this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;\n\n  if (options.from) {\n    this.from.copy(options.from);\n  }\n\n  if (options.to) {\n    this.to.copy(options.to);\n  }\n\n  this.callback = options.callback || function () {};\n\n  this.hasHit = false;\n  this.result.reset();\n\n  this._updateDirection();\n\n  this.getAABB(tmpAABB);\n  tmpArray.length = 0;\n  world.broadphase.aabbQuery(world, tmpAABB, tmpArray);\n  this.intersectBodies(tmpArray);\n  return this.hasHit;\n};\n\nvar v1 = new Vec3(),\n    v2 = new Vec3();\n/*\n * As per \"Barycentric Technique\" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division\n */\n\nRay.pointInTriangle = pointInTriangle;\n\nfunction pointInTriangle(p, a, b, c) {\n  c.vsub(a, v0);\n  b.vsub(a, v1);\n  p.vsub(a, v2);\n  var dot00 = v0.dot(v0);\n  var dot01 = v0.dot(v1);\n  var dot02 = v0.dot(v2);\n  var dot11 = v1.dot(v1);\n  var dot12 = v1.dot(v2);\n  var u, v;\n  return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;\n}\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @private\n * @param {Body} body\n * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.\n */\n\n\nvar intersectBody_xi = new Vec3();\nvar intersectBody_qi = new Quaternion();\n\nRay.prototype.intersectBody = function (body, result) {\n  if (result) {\n    this.result = result;\n\n    this._updateDirection();\n  }\n\n  var checkCollisionResponse = this.checkCollisionResponse;\n\n  if (checkCollisionResponse && !body.collisionResponse) {\n    return;\n  }\n\n  if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {\n    return;\n  }\n\n  var xi = intersectBody_xi;\n  var qi = intersectBody_qi;\n\n  for (var i = 0, N = body.shapes.length; i < N; i++) {\n    var shape = body.shapes[i];\n\n    if (checkCollisionResponse && !shape.collisionResponse) {\n      continue; // Skip\n    }\n\n    body.quaternion.mult(body.shapeOrientations[i], qi);\n    body.quaternion.vmult(body.shapeOffsets[i], xi);\n    xi.vadd(body.position, xi);\n    this.intersectShape(shape, qi, xi, body);\n\n    if (this.result._shouldStop) {\n      break;\n    }\n  }\n};\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n * @param {RaycastResult} [result] Deprecated\n */\n\n\nRay.prototype.intersectBodies = function (bodies, result) {\n  if (result) {\n    this.result = result;\n\n    this._updateDirection();\n  }\n\n  for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) {\n    this.intersectBody(bodies[i]);\n  }\n};\n/**\n * Updates the _direction vector.\n * @private\n * @method _updateDirection\n */\n\n\nRay.prototype._updateDirection = function () {\n  this.to.vsub(this.from, this._direction);\n\n  this._direction.normalize();\n};\n/**\n * @method intersectShape\n * @private\n * @param {Shape} shape\n * @param {Quaternion} quat\n * @param {Vec3} position\n * @param {Body} body\n */\n\n\nRay.prototype.intersectShape = function (shape, quat, position, body) {\n  var from = this.from; // Checking boundingSphere\n\n  var distance = distanceFromIntersection(from, this._direction, position);\n\n  if (distance > shape.boundingSphereRadius) {\n    return;\n  }\n\n  var intersectMethod = this[shape.type];\n\n  if (intersectMethod) {\n    intersectMethod.call(this, shape, quat, position, body, shape);\n  }\n};\n\nvar vector = new Vec3();\nvar normal = new Vec3();\nvar intersectPoint = new Vec3();\nvar a = new Vec3();\nvar b = new Vec3();\nvar c = new Vec3();\nvar d = new Vec3();\nvar tmpRaycastResult = new RaycastResult();\n/**\n * @method intersectBox\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\n\nRay.prototype.intersectBox = function (shape, quat, position, body, reportedShape) {\n  return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);\n};\n\nRay.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;\n/**\n * @method intersectPlane\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\n\nRay.prototype.intersectPlane = function (shape, quat, position, body, reportedShape) {\n  var from = this.from;\n  var to = this.to;\n  var direction = this._direction; // Get plane normal\n\n  var worldNormal = new Vec3(0, 0, 1);\n  quat.vmult(worldNormal, worldNormal);\n  var len = new Vec3();\n  from.vsub(position, len);\n  var planeToFrom = len.dot(worldNormal);\n  to.vsub(position, len);\n  var planeToTo = len.dot(worldNormal);\n\n  if (planeToFrom * planeToTo > 0) {\n    // \"from\" and \"to\" are on the same side of the plane... bail out\n    return;\n  }\n\n  if (from.distanceTo(to) < planeToFrom) {\n    return;\n  }\n\n  var n_dot_dir = worldNormal.dot(direction);\n\n  if (Math.abs(n_dot_dir) < this.precision) {\n    // No intersection\n    return;\n  }\n\n  var planePointToFrom = new Vec3();\n  var dir_scaled_with_t = new Vec3();\n  var hitPointWorld = new Vec3();\n  from.vsub(position, planePointToFrom);\n  var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n  direction.scale(t, dir_scaled_with_t);\n  from.vadd(dir_scaled_with_t, hitPointWorld);\n  this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);\n};\n\nRay.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;\n/**\n * Get the world AABB of the ray.\n * @method getAABB\n * @param  {AABB} aabb\n */\n\nRay.prototype.getAABB = function (result) {\n  var to = this.to;\n  var from = this.from;\n  result.lowerBound.x = Math.min(to.x, from.x);\n  result.lowerBound.y = Math.min(to.y, from.y);\n  result.lowerBound.z = Math.min(to.z, from.z);\n  result.upperBound.x = Math.max(to.x, from.x);\n  result.upperBound.y = Math.max(to.y, from.y);\n  result.upperBound.z = Math.max(to.z, from.z);\n};\n\nvar intersectConvexOptions = {\n  faceList: [0]\n};\nvar worldPillarOffset = new Vec3();\nvar intersectHeightfield_localRay = new Ray();\nvar intersectHeightfield_index = [];\nvar intersectHeightfield_minMax = [];\n/**\n * @method intersectHeightfield\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\n\nRay.prototype.intersectHeightfield = function (shape, quat, position, body, reportedShape) {\n  var data = shape.data,\n      w = shape.elementSize; // Convert the ray to local heightfield coordinates\n\n  var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);\n\n  localRay.from.copy(this.from);\n  localRay.to.copy(this.to);\n  Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n  Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n\n  localRay._updateDirection(); // Get the index of the data points to test against\n\n\n  var index = intersectHeightfield_index;\n  var iMinX, iMinY, iMaxX, iMaxY; // Set to max\n\n  iMinX = iMinY = 0;\n  iMaxX = iMaxY = shape.data.length - 1;\n  var aabb = new AABB();\n  localRay.getAABB(aabb);\n  shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);\n  iMinX = Math.max(iMinX, index[0]);\n  iMinY = Math.max(iMinY, index[1]);\n  shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);\n  iMaxX = Math.min(iMaxX, index[0] + 1);\n  iMaxY = Math.min(iMaxY, index[1] + 1);\n\n  for (var i = iMinX; i < iMaxX; i++) {\n    for (var j = iMinY; j < iMaxY; j++) {\n      if (this.result._shouldStop) {\n        return;\n      }\n\n      shape.getAabbAtIndex(i, j, aabb);\n\n      if (!aabb.overlapsRay(localRay)) {\n        continue;\n      } // Lower triangle\n\n\n      shape.getConvexTrianglePillar(i, j, false);\n      Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n      this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n\n      if (this.result._shouldStop) {\n        return;\n      } // Upper triangle\n\n\n      shape.getConvexTrianglePillar(i, j, true);\n      Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n      this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n    }\n  }\n};\n\nRay.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;\nvar Ray_intersectSphere_intersectionPoint = new Vec3();\nvar Ray_intersectSphere_normal = new Vec3();\n/**\n * @method intersectSphere\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\n\nRay.prototype.intersectSphere = function (shape, quat, position, body, reportedShape) {\n  var from = this.from,\n      to = this.to,\n      r = shape.radius;\n  var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n  var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n  var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n  var delta = Math.pow(b, 2) - 4 * a * c;\n  var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n  var normal = Ray_intersectSphere_normal;\n\n  if (delta < 0) {\n    // No intersection\n    return;\n  } else if (delta === 0) {\n    // single intersection point\n    from.lerp(to, delta, intersectionPoint);\n    intersectionPoint.vsub(position, normal);\n    normal.normalize();\n    this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n  } else {\n    var d1 = (-b - Math.sqrt(delta)) / (2 * a);\n    var d2 = (-b + Math.sqrt(delta)) / (2 * a);\n\n    if (d1 >= 0 && d1 <= 1) {\n      from.lerp(to, d1, intersectionPoint);\n      intersectionPoint.vsub(position, normal);\n      normal.normalize();\n      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n    }\n\n    if (this.result._shouldStop) {\n      return;\n    }\n\n    if (d2 >= 0 && d2 <= 1) {\n      from.lerp(to, d2, intersectionPoint);\n      intersectionPoint.vsub(position, normal);\n      normal.normalize();\n      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n    }\n  }\n};\n\nRay.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;\nvar intersectConvex_normal = new Vec3();\nvar intersectConvex_minDistNormal = new Vec3();\nvar intersectConvex_minDistIntersect = new Vec3();\nvar intersectConvex_vector = new Vec3();\n/**\n * @method intersectConvex\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @param {array} [options.faceList]\n */\n\nRay.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, reportedShape, options) {\n  var minDistNormal = intersectConvex_minDistNormal;\n  var normal = intersectConvex_normal;\n  var vector = intersectConvex_vector;\n  var minDistIntersect = intersectConvex_minDistIntersect;\n  var faceList = options && options.faceList || null; // Checking faces\n\n  var faces = shape.faces,\n      vertices = shape.vertices,\n      normals = shape.faceNormals;\n  var direction = this._direction;\n  var from = this.from;\n  var to = this.to;\n  var fromToDistance = from.distanceTo(to);\n  var minDist = -1;\n  var Nfaces = faceList ? faceList.length : faces.length;\n  var result = this.result;\n\n  for (var j = 0; !result._shouldStop && j < Nfaces; j++) {\n    var fi = faceList ? faceList[j] : j;\n    var face = faces[fi];\n    var faceNormal = normals[fi];\n    var q = quat;\n    var x = position; // determine if ray intersects the plane of the face\n    // note: this works regardless of the direction of the face normal\n    // Get plane point in world coordinates...\n\n    vector.copy(vertices[face[0]]);\n    q.vmult(vector, vector);\n    vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.\n\n    vector.vsub(from, vector); // Get plane normal\n\n    q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting\n\n    var dot = direction.dot(normal); // Bail out if ray and plane are parallel\n\n    if (Math.abs(dot) < this.precision) {\n      continue;\n    } // calc distance to plane\n\n\n    var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n    if (scalar < 0) {\n      continue;\n    } // if (dot < 0) {\n    // Intersection point is from + direction * scalar\n\n\n    direction.mult(scalar, intersectPoint);\n    intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.\n\n    a.copy(vertices[face[0]]);\n    q.vmult(a, a);\n    x.vadd(a, a);\n\n    for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {\n      // Transform 3 vertices to world coords\n      b.copy(vertices[face[i]]);\n      c.copy(vertices[face[i + 1]]);\n      q.vmult(b, b);\n      q.vmult(c, c);\n      x.vadd(b, b);\n      x.vadd(c, c);\n      var distance = intersectPoint.distanceTo(from);\n\n      if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {\n        continue;\n      }\n\n      this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);\n    } // }\n\n  }\n};\n\nRay.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;\nvar intersectTrimesh_normal = new Vec3();\nvar intersectTrimesh_localDirection = new Vec3();\nvar intersectTrimesh_localFrom = new Vec3();\nvar intersectTrimesh_localTo = new Vec3();\nvar intersectTrimesh_worldNormal = new Vec3();\nvar intersectTrimesh_worldIntersectPoint = new Vec3();\nvar intersectTrimesh_localAABB = new AABB();\nvar intersectTrimesh_triangles = [];\nvar intersectTrimesh_treeTransform = new Transform();\n/**\n * @method intersectTrimesh\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @todo Optimize by transforming the world to local space first.\n * @todo Use Octree lookup\n */\n\nRay.prototype.intersectTrimesh = function intersectTrimesh(mesh, quat, position, body, reportedShape, options) {\n  var normal = intersectTrimesh_normal;\n  var triangles = intersectTrimesh_triangles;\n  var treeTransform = intersectTrimesh_treeTransform;\n  var minDistNormal = intersectConvex_minDistNormal;\n  var vector = intersectConvex_vector;\n  var minDistIntersect = intersectConvex_minDistIntersect;\n  var localAABB = intersectTrimesh_localAABB;\n  var localDirection = intersectTrimesh_localDirection;\n  var localFrom = intersectTrimesh_localFrom;\n  var localTo = intersectTrimesh_localTo;\n  var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;\n  var worldNormal = intersectTrimesh_worldNormal;\n  var faceList = options && options.faceList || null; // Checking faces\n\n  var indices = mesh.indices,\n      vertices = mesh.vertices,\n      normals = mesh.faceNormals;\n  var from = this.from;\n  var to = this.to;\n  var direction = this._direction;\n  var minDist = -1;\n  treeTransform.position.copy(position);\n  treeTransform.quaternion.copy(quat); // Transform ray to local space!\n\n  Transform.vectorToLocalFrame(position, quat, direction, localDirection);\n  Transform.pointToLocalFrame(position, quat, from, localFrom);\n  Transform.pointToLocalFrame(position, quat, to, localTo);\n  localTo.x *= mesh.scale.x;\n  localTo.y *= mesh.scale.y;\n  localTo.z *= mesh.scale.z;\n  localFrom.x *= mesh.scale.x;\n  localFrom.y *= mesh.scale.y;\n  localFrom.z *= mesh.scale.z;\n  localTo.vsub(localFrom, localDirection);\n  localDirection.normalize();\n  var fromToDistanceSquared = localFrom.distanceSquared(localTo);\n  mesh.tree.rayQuery(this, treeTransform, triangles);\n\n  for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {\n    var trianglesIndex = triangles[i];\n    mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face\n    // note: this works regardless of the direction of the face normal\n    // Get plane point in world coordinates...\n\n    mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.\n\n    a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting\n\n    var dot = localDirection.dot(normal); // Bail out if ray and plane are parallel\n    // if (Math.abs( dot ) < this.precision){\n    //     continue;\n    // }\n    // calc distance to plane\n\n    var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n    if (scalar < 0) {\n      continue;\n    } // Intersection point is from + direction * scalar\n\n\n    localDirection.scale(scalar, intersectPoint);\n    intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices\n\n    mesh.getVertex(indices[trianglesIndex * 3 + 1], b);\n    mesh.getVertex(indices[trianglesIndex * 3 + 2], c);\n    var squaredDistance = intersectPoint.distanceSquared(localFrom);\n\n    if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {\n      continue;\n    } // transform intersectpoint and normal to world\n\n\n    Transform.vectorToWorldFrame(quat, normal, worldNormal);\n    Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);\n    this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);\n  }\n\n  triangles.length = 0;\n};\n\nRay.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;\n/**\n * @method reportIntersection\n * @private\n * @param  {Vec3} normal\n * @param  {Vec3} hitPointWorld\n * @param  {Shape} shape\n * @param  {Body} body\n * @return {boolean} True if the intersections should continue\n */\n\nRay.prototype.reportIntersection = function (normal, hitPointWorld, shape, body, hitFaceIndex) {\n  var from = this.from;\n  var to = this.to;\n  var distance = from.distanceTo(hitPointWorld);\n  var result = this.result; // Skip back faces?\n\n  if (this.skipBackfaces && normal.dot(this._direction) > 0) {\n    return;\n  }\n\n  result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;\n\n  switch (this.mode) {\n    case Ray.ALL:\n      this.hasHit = true;\n      result.set(from, to, normal, hitPointWorld, shape, body, distance);\n      result.hasHit = true;\n      this.callback(result);\n      break;\n\n    case Ray.CLOSEST:\n      // Store if closer than current closest\n      if (distance < result.distance || !result.hasHit) {\n        this.hasHit = true;\n        result.hasHit = true;\n        result.set(from, to, normal, hitPointWorld, shape, body, distance);\n      }\n\n      break;\n\n    case Ray.ANY:\n      // Report and stop.\n      this.hasHit = true;\n      result.hasHit = true;\n      result.set(from, to, normal, hitPointWorld, shape, body, distance);\n      result._shouldStop = true;\n      break;\n  }\n};\n\nvar v0 = new Vec3(),\n    intersect = new Vec3();\n\nfunction distanceFromIntersection(from, direction, position) {\n  // v0 is vector from from to position\n  position.vsub(from, v0);\n  var dot = v0.dot(direction); // intersect = direction*dot + from\n\n  direction.mult(dot, intersect);\n  intersect.vadd(from, intersect);\n  var distance = position.distanceTo(intersect);\n  return distance;\n}","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/collision/Ray.js"],"names":["module","exports","Ray","Vec3","require","Quaternion","Transform","ConvexPolyhedron","Box","RaycastResult","Shape","AABB","from","to","clone","_direction","precision","checkCollisionResponse","skipBackfaces","collisionFilterMask","collisionFilterGroup","mode","ANY","result","hasHit","callback","prototype","constructor","CLOSEST","ALL","tmpAABB","tmpArray","intersectWorld","world","options","copy","reset","_updateDirection","getAABB","length","broadphase","aabbQuery","intersectBodies","v1","v2","pointInTriangle","p","a","b","c","vsub","v0","dot00","dot","dot01","dot02","dot11","dot12","u","v","intersectBody_xi","intersectBody_qi","intersectBody","body","collisionResponse","xi","qi","i","N","shapes","shape","quaternion","mult","shapeOrientations","vmult","shapeOffsets","vadd","position","intersectShape","_shouldStop","bodies","l","normalize","quat","distance","distanceFromIntersection","boundingSphereRadius","intersectMethod","type","call","vector","normal","intersectPoint","d","tmpRaycastResult","intersectBox","reportedShape","intersectConvex","convexPolyhedronRepresentation","types","BOX","intersectPlane","direction","worldNormal","len","planeToFrom","planeToTo","distanceTo","n_dot_dir","Math","abs","planePointToFrom","dir_scaled_with_t","hitPointWorld","t","scale","reportIntersection","PLANE","lowerBound","x","min","y","z","upperBound","max","intersectConvexOptions","faceList","worldPillarOffset","intersectHeightfield_localRay","intersectHeightfield_index","intersectHeightfield_minMax","intersectHeightfield","data","w","elementSize","localRay","pointToLocalFrame","index","iMinX","iMinY","iMaxX","iMaxY","aabb","getIndexOfPosition","j","getAabbAtIndex","overlapsRay","getConvexTrianglePillar","pointToWorldFrame","pillarOffset","pillarConvex","HEIGHTFIELD","Ray_intersectSphere_intersectionPoint","Ray_intersectSphere_normal","intersectSphere","r","radius","pow","delta","intersectionPoint","lerp","d1","sqrt","d2","SPHERE","intersectConvex_normal","intersectConvex_minDistNormal","intersectConvex_minDistIntersect","intersectConvex_vector","minDistNormal","minDistIntersect","faces","vertices","normals","faceNormals","fromToDistance","minDist","Nfaces","fi","face","faceNormal","q","scalar","CONVEXPOLYHEDRON","intersectTrimesh_normal","intersectTrimesh_localDirection","intersectTrimesh_localFrom","intersectTrimesh_localTo","intersectTrimesh_worldNormal","intersectTrimesh_worldIntersectPoint","intersectTrimesh_localAABB","intersectTrimesh_triangles","intersectTrimesh_treeTransform","intersectTrimesh","mesh","triangles","treeTransform","localAABB","localDirection","localFrom","localTo","worldIntersectPoint","indices","vectorToLocalFrame","fromToDistanceSquared","distanceSquared","tree","rayQuery","trianglesIndex","getNormal","getVertex","squaredDistance","vectorToWorldFrame","TRIMESH","hitFaceIndex","set","intersect"],"mappings":"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","sourcesContent":["module.exports = Ray;\n\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Transform = require('../math/Transform');\nvar ConvexPolyhedron = require('../shapes/ConvexPolyhedron');\nvar Box = require('../shapes/Box');\nvar RaycastResult = require('../collision/RaycastResult');\nvar Shape = require('../shapes/Shape');\nvar AABB = require('../collision/AABB');\n\n/**\n * A line in 3D space that intersects bodies and return points.\n * @class Ray\n * @constructor\n * @param {Vec3} from\n * @param {Vec3} to\n */\nfunction Ray(from, to){\n    /**\n     * @property {Vec3} from\n     */\n    this.from = from ? from.clone() : new Vec3();\n\n    /**\n     * @property {Vec3} to\n     */\n    this.to = to ? to.clone() : new Vec3();\n\n    /**\n     * @private\n     * @property {Vec3} _direction\n     */\n    this._direction = new Vec3();\n\n    /**\n     * The precision of the ray. Used when checking parallelity etc.\n     * @property {Number} precision\n     */\n    this.precision = 0.0001;\n\n    /**\n     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n     * @property {Boolean} checkCollisionResponse\n     */\n    this.checkCollisionResponse = true;\n\n    /**\n     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @property {Boolean} skipBackfaces\n     */\n    this.skipBackfaces = false;\n\n    /**\n     * @property {number} collisionFilterMask\n     * @default -1\n     */\n    this.collisionFilterMask = -1;\n\n    /**\n     * @property {number} collisionFilterGroup\n     * @default -1\n     */\n    this.collisionFilterGroup = -1;\n\n    /**\n     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.\n     * @property {number} mode\n     */\n    this.mode = Ray.ANY;\n\n    /**\n     * Current result object.\n     * @property {RaycastResult} result\n     */\n    this.result = new RaycastResult();\n\n    /**\n     * Will be set to true during intersectWorld() if the ray hit anything.\n     * @property {Boolean} hasHit\n     */\n    this.hasHit = false;\n\n    /**\n     * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n     * @property {Function} callback\n     */\n    this.callback = function(result){};\n}\nRay.prototype.constructor = Ray;\n\nRay.CLOSEST = 1;\nRay.ANY = 2;\nRay.ALL = 4;\n\nvar tmpAABB = new AABB();\nvar tmpArray = [];\n\n/**\n * Do itersection against all bodies in the given World.\n * @method intersectWorld\n * @param  {World} world\n * @param  {object} options\n * @return {Boolean} True if the ray hit anything, otherwise false.\n */\nRay.prototype.intersectWorld = function (world, options) {\n    this.mode = options.mode || Ray.ANY;\n    this.result = options.result || new RaycastResult();\n    this.skipBackfaces = !!options.skipBackfaces;\n    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;\n    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;\n    if(options.from){\n        this.from.copy(options.from);\n    }\n    if(options.to){\n        this.to.copy(options.to);\n    }\n    this.callback = options.callback || function(){};\n    this.hasHit = false;\n\n    this.result.reset();\n    this._updateDirection();\n\n    this.getAABB(tmpAABB);\n    tmpArray.length = 0;\n    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);\n    this.intersectBodies(tmpArray);\n\n    return this.hasHit;\n};\n\nvar v1 = new Vec3(),\n    v2 = new Vec3();\n\n/*\n * As per \"Barycentric Technique\" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division\n */\nRay.pointInTriangle = pointInTriangle;\nfunction pointInTriangle(p, a, b, c) {\n    c.vsub(a,v0);\n    b.vsub(a,v1);\n    p.vsub(a,v2);\n\n    var dot00 = v0.dot( v0 );\n    var dot01 = v0.dot( v1 );\n    var dot02 = v0.dot( v2 );\n    var dot11 = v1.dot( v1 );\n    var dot12 = v1.dot( v2 );\n\n    var u,v;\n\n    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&\n            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&\n            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );\n}\n\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @private\n * @param {Body} body\n * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.\n */\nvar intersectBody_xi = new Vec3();\nvar intersectBody_qi = new Quaternion();\nRay.prototype.intersectBody = function (body, result) {\n    if(result){\n        this.result = result;\n        this._updateDirection();\n    }\n    var checkCollisionResponse = this.checkCollisionResponse;\n\n    if(checkCollisionResponse && !body.collisionResponse){\n        return;\n    }\n\n    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){\n        return;\n    }\n\n    var xi = intersectBody_xi;\n    var qi = intersectBody_qi;\n\n    for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n\n        if(checkCollisionResponse && !shape.collisionResponse){\n            continue; // Skip\n        }\n\n        body.quaternion.mult(body.shapeOrientations[i], qi);\n        body.quaternion.vmult(body.shapeOffsets[i], xi);\n        xi.vadd(body.position, xi);\n\n        this.intersectShape(\n            shape,\n            qi,\n            xi,\n            body\n        );\n\n        if(this.result._shouldStop){\n            break;\n        }\n    }\n};\n\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n * @param {RaycastResult} [result] Deprecated\n */\nRay.prototype.intersectBodies = function (bodies, result) {\n    if(result){\n        this.result = result;\n        this._updateDirection();\n    }\n\n    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {\n        this.intersectBody(bodies[i]);\n    }\n};\n\n/**\n * Updates the _direction vector.\n * @private\n * @method _updateDirection\n */\nRay.prototype._updateDirection = function(){\n    this.to.vsub(this.from, this._direction);\n    this._direction.normalize();\n};\n\n/**\n * @method intersectShape\n * @private\n * @param {Shape} shape\n * @param {Quaternion} quat\n * @param {Vec3} position\n * @param {Body} body\n */\nRay.prototype.intersectShape = function(shape, quat, position, body){\n    var from = this.from;\n\n\n    // Checking boundingSphere\n    var distance = distanceFromIntersection(from, this._direction, position);\n    if ( distance > shape.boundingSphereRadius ) {\n        return;\n    }\n\n    var intersectMethod = this[shape.type];\n    if(intersectMethod){\n        intersectMethod.call(this, shape, quat, position, body, shape);\n    }\n};\n\nvar vector = new Vec3();\nvar normal = new Vec3();\nvar intersectPoint = new Vec3();\n\nvar a = new Vec3();\nvar b = new Vec3();\nvar c = new Vec3();\nvar d = new Vec3();\n\nvar tmpRaycastResult = new RaycastResult();\n\n/**\n * @method intersectBox\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectBox = function(shape, quat, position, body, reportedShape){\n    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);\n};\nRay.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;\n\n/**\n * @method intersectPlane\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectPlane = function(shape, quat, position, body, reportedShape){\n    var from = this.from;\n    var to = this.to;\n    var direction = this._direction;\n\n    // Get plane normal\n    var worldNormal = new Vec3(0, 0, 1);\n    quat.vmult(worldNormal, worldNormal);\n\n    var len = new Vec3();\n    from.vsub(position, len);\n    var planeToFrom = len.dot(worldNormal);\n    to.vsub(position, len);\n    var planeToTo = len.dot(worldNormal);\n\n    if(planeToFrom * planeToTo > 0){\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n    }\n\n    if(from.distanceTo(to) < planeToFrom){\n        return;\n    }\n\n    var n_dot_dir = worldNormal.dot(direction);\n\n    if (Math.abs(n_dot_dir) < this.precision) {\n        // No intersection\n        return;\n    }\n\n    var planePointToFrom = new Vec3();\n    var dir_scaled_with_t = new Vec3();\n    var hitPointWorld = new Vec3();\n\n    from.vsub(position, planePointToFrom);\n    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n    direction.scale(t, dir_scaled_with_t);\n    from.vadd(dir_scaled_with_t, hitPointWorld);\n\n    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);\n};\nRay.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;\n\n/**\n * Get the world AABB of the ray.\n * @method getAABB\n * @param  {AABB} aabb\n */\nRay.prototype.getAABB = function(result){\n    var to = this.to;\n    var from = this.from;\n    result.lowerBound.x = Math.min(to.x, from.x);\n    result.lowerBound.y = Math.min(to.y, from.y);\n    result.lowerBound.z = Math.min(to.z, from.z);\n    result.upperBound.x = Math.max(to.x, from.x);\n    result.upperBound.y = Math.max(to.y, from.y);\n    result.upperBound.z = Math.max(to.z, from.z);\n};\n\nvar intersectConvexOptions = {\n    faceList: [0]\n};\nvar worldPillarOffset = new Vec3();\nvar intersectHeightfield_localRay = new Ray();\nvar intersectHeightfield_index = [];\nvar intersectHeightfield_minMax = [];\n\n/**\n * @method intersectHeightfield\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectHeightfield = function(shape, quat, position, body, reportedShape){\n    var data = shape.data,\n        w = shape.elementSize;\n\n    // Convert the ray to local heightfield coordinates\n    var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);\n    localRay.from.copy(this.from);\n    localRay.to.copy(this.to);\n    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n    localRay._updateDirection();\n\n    // Get the index of the data points to test against\n    var index = intersectHeightfield_index;\n    var iMinX, iMinY, iMaxX, iMaxY;\n\n    // Set to max\n    iMinX = iMinY = 0;\n    iMaxX = iMaxY = shape.data.length - 1;\n\n    var aabb = new AABB();\n    localRay.getAABB(aabb);\n\n    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);\n    iMinX = Math.max(iMinX, index[0]);\n    iMinY = Math.max(iMinY, index[1]);\n    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);\n    iMaxX = Math.min(iMaxX, index[0] + 1);\n    iMaxY = Math.min(iMaxY, index[1] + 1);\n\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            if(this.result._shouldStop){\n                return;\n            }\n\n            shape.getAabbAtIndex(i, j, aabb);\n            if(!aabb.overlapsRay(localRay)){\n                continue;\n            }\n\n            // Lower triangle\n            shape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n\n            if(this.result._shouldStop){\n                return;\n            }\n\n            // Upper triangle\n            shape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n        }\n    }\n};\nRay.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;\n\nvar Ray_intersectSphere_intersectionPoint = new Vec3();\nvar Ray_intersectSphere_normal = new Vec3();\n\n/**\n * @method intersectSphere\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectSphere = function(shape, quat, position, body, reportedShape){\n    var from = this.from,\n        to = this.to,\n        r = shape.radius;\n\n    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n\n    var delta = Math.pow(b, 2) - 4 * a * c;\n\n    var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n    var normal = Ray_intersectSphere_normal;\n\n    if(delta < 0){\n        // No intersection\n        return;\n\n    } else if(delta === 0){\n        // single intersection point\n        from.lerp(to, delta, intersectionPoint);\n\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n\n        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n\n    } else {\n        var d1 = (- b - Math.sqrt(delta)) / (2 * a);\n        var d2 = (- b + Math.sqrt(delta)) / (2 * a);\n\n        if(d1 >= 0 && d1 <= 1){\n            from.lerp(to, d1, intersectionPoint);\n            intersectionPoint.vsub(position, normal);\n            normal.normalize();\n            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n\n        if(this.result._shouldStop){\n            return;\n        }\n\n        if(d2 >= 0 && d2 <= 1){\n            from.lerp(to, d2, intersectionPoint);\n            intersectionPoint.vsub(position, normal);\n            normal.normalize();\n            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n    }\n};\nRay.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;\n\n\nvar intersectConvex_normal = new Vec3();\nvar intersectConvex_minDistNormal = new Vec3();\nvar intersectConvex_minDistIntersect = new Vec3();\nvar intersectConvex_vector = new Vec3();\n\n/**\n * @method intersectConvex\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @param {array} [options.faceList]\n */\nRay.prototype.intersectConvex = function intersectConvex(\n    shape,\n    quat,\n    position,\n    body,\n    reportedShape,\n    options\n){\n    var minDistNormal = intersectConvex_minDistNormal;\n    var normal = intersectConvex_normal;\n    var vector = intersectConvex_vector;\n    var minDistIntersect = intersectConvex_minDistIntersect;\n    var faceList = (options && options.faceList) || null;\n\n    // Checking faces\n    var faces = shape.faces,\n        vertices = shape.vertices,\n        normals = shape.faceNormals;\n    var direction = this._direction;\n\n    var from = this.from;\n    var to = this.to;\n    var fromToDistance = from.distanceTo(to);\n\n    var minDist = -1;\n    var Nfaces = faceList ? faceList.length : faces.length;\n    var result = this.result;\n\n    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {\n        var fi = faceList ? faceList[j] : j;\n\n        var face = faces[fi];\n        var faceNormal = normals[fi];\n        var q = quat;\n        var x = position;\n\n        // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n\n        // Get plane point in world coordinates...\n        vector.copy(vertices[face[0]]);\n        q.vmult(vector,vector);\n        vector.vadd(x,vector);\n\n        // ...but make it relative to the ray from. We'll fix this later.\n        vector.vsub(from,vector);\n\n        // Get plane normal\n        q.vmult(faceNormal,normal);\n\n        // If this dot product is negative, we have something interesting\n        var dot = direction.dot(normal);\n\n        // Bail out if ray and plane are parallel\n        if ( Math.abs( dot ) < this.precision ){\n            continue;\n        }\n\n        // calc distance to plane\n        var scalar = normal.dot(vector) / dot;\n\n        // if negative distance, then plane is behind ray\n        if (scalar < 0){\n            continue;\n        }\n\n        // if (dot < 0) {\n\n        // Intersection point is from + direction * scalar\n        direction.mult(scalar,intersectPoint);\n        intersectPoint.vadd(from,intersectPoint);\n\n        // a is the point we compare points b and c with.\n        a.copy(vertices[face[0]]);\n        q.vmult(a,a);\n        x.vadd(a,a);\n\n        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){\n            // Transform 3 vertices to world coords\n            b.copy(vertices[face[i]]);\n            c.copy(vertices[face[i+1]]);\n            q.vmult(b,b);\n            q.vmult(c,c);\n            x.vadd(b,b);\n            x.vadd(c,c);\n\n            var distance = intersectPoint.distanceTo(from);\n\n            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){\n                continue;\n            }\n\n            this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);\n        }\n        // }\n    }\n};\nRay.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;\n\nvar intersectTrimesh_normal = new Vec3();\nvar intersectTrimesh_localDirection = new Vec3();\nvar intersectTrimesh_localFrom = new Vec3();\nvar intersectTrimesh_localTo = new Vec3();\nvar intersectTrimesh_worldNormal = new Vec3();\nvar intersectTrimesh_worldIntersectPoint = new Vec3();\nvar intersectTrimesh_localAABB = new AABB();\nvar intersectTrimesh_triangles = [];\nvar intersectTrimesh_treeTransform = new Transform();\n\n/**\n * @method intersectTrimesh\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @todo Optimize by transforming the world to local space first.\n * @todo Use Octree lookup\n */\nRay.prototype.intersectTrimesh = function intersectTrimesh(\n    mesh,\n    quat,\n    position,\n    body,\n    reportedShape,\n    options\n){\n    var normal = intersectTrimesh_normal;\n    var triangles = intersectTrimesh_triangles;\n    var treeTransform = intersectTrimesh_treeTransform;\n    var minDistNormal = intersectConvex_minDistNormal;\n    var vector = intersectConvex_vector;\n    var minDistIntersect = intersectConvex_minDistIntersect;\n    var localAABB = intersectTrimesh_localAABB;\n    var localDirection = intersectTrimesh_localDirection;\n    var localFrom = intersectTrimesh_localFrom;\n    var localTo = intersectTrimesh_localTo;\n    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;\n    var worldNormal = intersectTrimesh_worldNormal;\n    var faceList = (options && options.faceList) || null;\n\n    // Checking faces\n    var indices = mesh.indices,\n        vertices = mesh.vertices,\n        normals = mesh.faceNormals;\n\n    var from = this.from;\n    var to = this.to;\n    var direction = this._direction;\n\n    var minDist = -1;\n    treeTransform.position.copy(position);\n    treeTransform.quaternion.copy(quat);\n\n    // Transform ray to local space!\n    Transform.vectorToLocalFrame(position, quat, direction, localDirection);\n    Transform.pointToLocalFrame(position, quat, from, localFrom);\n    Transform.pointToLocalFrame(position, quat, to, localTo);\n\n    localTo.x *= mesh.scale.x;\n    localTo.y *= mesh.scale.y;\n    localTo.z *= mesh.scale.z;\n    localFrom.x *= mesh.scale.x;\n    localFrom.y *= mesh.scale.y;\n    localFrom.z *= mesh.scale.z;\n\n    localTo.vsub(localFrom, localDirection);\n    localDirection.normalize();\n\n    var fromToDistanceSquared = localFrom.distanceSquared(localTo);\n\n    mesh.tree.rayQuery(this, treeTransform, triangles);\n\n    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {\n        var trianglesIndex = triangles[i];\n\n        mesh.getNormal(trianglesIndex, normal);\n\n        // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n\n        // Get plane point in world coordinates...\n        mesh.getVertex(indices[trianglesIndex * 3], a);\n\n        // ...but make it relative to the ray from. We'll fix this later.\n        a.vsub(localFrom,vector);\n\n        // If this dot product is negative, we have something interesting\n        var dot = localDirection.dot(normal);\n\n        // Bail out if ray and plane are parallel\n        // if (Math.abs( dot ) < this.precision){\n        //     continue;\n        // }\n\n        // calc distance to plane\n        var scalar = normal.dot(vector) / dot;\n\n        // if negative distance, then plane is behind ray\n        if (scalar < 0){\n            continue;\n        }\n\n        // Intersection point is from + direction * scalar\n        localDirection.scale(scalar,intersectPoint);\n        intersectPoint.vadd(localFrom,intersectPoint);\n\n        // Get triangle vertices\n        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);\n        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);\n\n        var squaredDistance = intersectPoint.distanceSquared(localFrom);\n\n        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){\n            continue;\n        }\n\n        // transform intersectpoint and normal to world\n        Transform.vectorToWorldFrame(quat, normal, worldNormal);\n        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);\n        this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);\n    }\n    triangles.length = 0;\n};\nRay.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;\n\n\n/**\n * @method reportIntersection\n * @private\n * @param  {Vec3} normal\n * @param  {Vec3} hitPointWorld\n * @param  {Shape} shape\n * @param  {Body} body\n * @return {boolean} True if the intersections should continue\n */\nRay.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){\n    var from = this.from;\n    var to = this.to;\n    var distance = from.distanceTo(hitPointWorld);\n    var result = this.result;\n\n    // Skip back faces?\n    if(this.skipBackfaces && normal.dot(this._direction) > 0){\n        return;\n    }\n\n    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;\n\n    switch(this.mode){\n    case Ray.ALL:\n        this.hasHit = true;\n        result.set(\n            from,\n            to,\n            normal,\n            hitPointWorld,\n            shape,\n            body,\n            distance\n        );\n        result.hasHit = true;\n        this.callback(result);\n        break;\n\n    case Ray.CLOSEST:\n\n        // Store if closer than current closest\n        if(distance < result.distance || !result.hasHit){\n            this.hasHit = true;\n            result.hasHit = true;\n            result.set(\n                from,\n                to,\n                normal,\n                hitPointWorld,\n                shape,\n                body,\n                distance\n            );\n        }\n        break;\n\n    case Ray.ANY:\n\n        // Report and stop.\n        this.hasHit = true;\n        result.hasHit = true;\n        result.set(\n            from,\n            to,\n            normal,\n            hitPointWorld,\n            shape,\n            body,\n            distance\n        );\n        result._shouldStop = true;\n        break;\n    }\n};\n\nvar v0 = new Vec3(),\n    intersect = new Vec3();\nfunction distanceFromIntersection(from, direction, position) {\n\n    // v0 is vector from from to position\n    position.vsub(from,v0);\n    var dot = v0.dot(direction);\n\n    // intersect = direction*dot + from\n    direction.mult(dot,intersect);\n    intersect.vadd(from,intersect);\n\n    var distance = position.distanceTo(intersect);\n\n    return distance;\n}\n\n"]},"metadata":{},"sourceType":"script"}