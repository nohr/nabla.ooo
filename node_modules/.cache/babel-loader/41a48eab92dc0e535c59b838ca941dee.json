{"ast":null,"code":"module.exports = HingeConstraint;\n\nvar Constraint = require('./Constraint');\n\nvar PointToPointConstraint = require('./PointToPointConstraint');\n\nvar RotationalEquation = require('../equations/RotationalEquation');\n\nvar RotationalMotorEquation = require('../equations/RotationalMotorEquation');\n\nvar ContactEquation = require('../equations/ContactEquation');\n\nvar Vec3 = require('../math/Vec3');\n/**\n * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.\n * @class HingeConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.\n * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.\n * @param {Vec3} [options.pivotB]\n * @param {Vec3} [options.axisB]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\n\n\nfunction HingeConstraint(bodyA, bodyB, options) {\n  options = options || {};\n  var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;\n  var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();\n  var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();\n  PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n  /**\n   * Rotation axis, defined locally in bodyA.\n   * @property {Vec3} axisA\n   */\n\n  var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n  axisA.normalize();\n  /**\n   * Rotation axis, defined locally in bodyB.\n   * @property {Vec3} axisB\n   */\n\n  var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);\n  axisB.normalize();\n  /**\n   * @property {RotationalEquation} rotationalEquation1\n   */\n\n  var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);\n  /**\n   * @property {RotationalEquation} rotationalEquation2\n   */\n\n  var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);\n  /**\n   * @property {RotationalMotorEquation} motorEquation\n   */\n\n  var motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);\n  motor.enabled = false; // Not enabled by default\n  // Equations to be fed to the solver\n\n  this.equations.push(r1, // rotational1\n  r2, // rotational2\n  motor);\n}\n\nHingeConstraint.prototype = new PointToPointConstraint();\nHingeConstraint.constructor = HingeConstraint;\n/**\n * @method enableMotor\n */\n\nHingeConstraint.prototype.enableMotor = function () {\n  this.motorEquation.enabled = true;\n};\n/**\n * @method disableMotor\n */\n\n\nHingeConstraint.prototype.disableMotor = function () {\n  this.motorEquation.enabled = false;\n};\n/**\n * @method setMotorSpeed\n * @param {number} speed\n */\n\n\nHingeConstraint.prototype.setMotorSpeed = function (speed) {\n  this.motorEquation.targetVelocity = speed;\n};\n/**\n * @method setMotorMaxForce\n * @param {number} maxForce\n */\n\n\nHingeConstraint.prototype.setMotorMaxForce = function (maxForce) {\n  this.motorEquation.maxForce = maxForce;\n  this.motorEquation.minForce = -maxForce;\n};\n\nvar HingeConstraint_update_tmpVec1 = new Vec3();\nvar HingeConstraint_update_tmpVec2 = new Vec3();\n\nHingeConstraint.prototype.update = function () {\n  var bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      motor = this.motorEquation,\n      r1 = this.rotationalEquation1,\n      r2 = this.rotationalEquation2,\n      worldAxisA = HingeConstraint_update_tmpVec1,\n      worldAxisB = HingeConstraint_update_tmpVec2;\n  var axisA = this.axisA;\n  var axisB = this.axisB;\n  PointToPointConstraint.prototype.update.call(this); // Get world axes\n\n  bodyA.quaternion.vmult(axisA, worldAxisA);\n  bodyB.quaternion.vmult(axisB, worldAxisB);\n  worldAxisA.tangents(r1.axisA, r2.axisA);\n  r1.axisB.copy(worldAxisB);\n  r2.axisB.copy(worldAxisB);\n\n  if (this.motorEquation.enabled) {\n    bodyA.quaternion.vmult(this.axisA, motor.axisA);\n    bodyB.quaternion.vmult(this.axisB, motor.axisB);\n  }\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/constraints/HingeConstraint.js"],"names":["module","exports","HingeConstraint","Constraint","require","PointToPointConstraint","RotationalEquation","RotationalMotorEquation","ContactEquation","Vec3","bodyA","bodyB","options","maxForce","pivotA","clone","pivotB","call","axisA","normalize","axisB","r1","rotationalEquation1","r2","rotationalEquation2","motor","motorEquation","enabled","equations","push","prototype","constructor","enableMotor","disableMotor","setMotorSpeed","speed","targetVelocity","setMotorMaxForce","minForce","HingeConstraint_update_tmpVec1","HingeConstraint_update_tmpVec2","update","worldAxisA","worldAxisB","quaternion","vmult","tangents","copy"],"mappings":"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","sourcesContent":["module.exports = HingeConstraint;\n\nvar Constraint = require('./Constraint');\nvar PointToPointConstraint = require('./PointToPointConstraint');\nvar RotationalEquation = require('../equations/RotationalEquation');\nvar RotationalMotorEquation = require('../equations/RotationalMotorEquation');\nvar ContactEquation = require('../equations/ContactEquation');\nvar Vec3 = require('../math/Vec3');\n\n/**\n * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.\n * @class HingeConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.\n * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.\n * @param {Vec3} [options.pivotB]\n * @param {Vec3} [options.axisB]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\nfunction HingeConstraint(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();\n    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();\n\n    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n\n    /**\n     * Rotation axis, defined locally in bodyA.\n     * @property {Vec3} axisA\n     */\n    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);\n    axisA.normalize();\n\n    /**\n     * Rotation axis, defined locally in bodyB.\n     * @property {Vec3} axisB\n     */\n    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);\n    axisB.normalize();\n\n    /**\n     * @property {RotationalEquation} rotationalEquation1\n     */\n    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation2\n     */\n    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalMotorEquation} motorEquation\n     */\n    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);\n    motor.enabled = false; // Not enabled by default\n\n    // Equations to be fed to the solver\n    this.equations.push(\n        r1, // rotational1\n        r2, // rotational2\n        motor\n    );\n}\nHingeConstraint.prototype = new PointToPointConstraint();\nHingeConstraint.constructor = HingeConstraint;\n\n/**\n * @method enableMotor\n */\nHingeConstraint.prototype.enableMotor = function(){\n    this.motorEquation.enabled = true;\n};\n\n/**\n * @method disableMotor\n */\nHingeConstraint.prototype.disableMotor = function(){\n    this.motorEquation.enabled = false;\n};\n\n/**\n * @method setMotorSpeed\n * @param {number} speed\n */\nHingeConstraint.prototype.setMotorSpeed = function(speed){\n    this.motorEquation.targetVelocity = speed;\n};\n\n/**\n * @method setMotorMaxForce\n * @param {number} maxForce\n */\nHingeConstraint.prototype.setMotorMaxForce = function(maxForce){\n    this.motorEquation.maxForce = maxForce;\n    this.motorEquation.minForce = -maxForce;\n};\n\nvar HingeConstraint_update_tmpVec1 = new Vec3();\nvar HingeConstraint_update_tmpVec2 = new Vec3();\n\nHingeConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        motor = this.motorEquation,\n        r1 = this.rotationalEquation1,\n        r2 = this.rotationalEquation2,\n        worldAxisA = HingeConstraint_update_tmpVec1,\n        worldAxisB = HingeConstraint_update_tmpVec2;\n\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n\n    PointToPointConstraint.prototype.update.call(this);\n\n    // Get world axes\n    bodyA.quaternion.vmult(axisA, worldAxisA);\n    bodyB.quaternion.vmult(axisB, worldAxisB);\n\n    worldAxisA.tangents(r1.axisA, r2.axisA);\n    r1.axisB.copy(worldAxisB);\n    r2.axisB.copy(worldAxisB);\n\n    if(this.motorEquation.enabled){\n        bodyA.quaternion.vmult(this.axisA, motor.axisA);\n        bodyB.quaternion.vmult(this.axisB, motor.axisB);\n    }\n};\n\n"]},"metadata":{},"sourceType":"script"}