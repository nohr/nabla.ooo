{"ast":null,"code":"module.exports = ConvexPolyhedron;\n\nvar Shape = require('./Shape');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Transform = require('../math/Transform');\n/**\n * A set of polygons describing a convex shape.\n * @class ConvexPolyhedron\n * @constructor\n * @extends Shape\n * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained\n * in the same 3D plane), instead these should be merged into one polygon.\n *\n * @param {array} points An array of Vec3's\n * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.\n *\n * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)\n * @author schteppe / https://github.com/schteppe\n * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n *\n * @todo Move the clipping functions to ContactGenerator?\n * @todo Automatically merge coplanar polygons in constructor.\n */\n\n\nfunction ConvexPolyhedron(points, faces, uniqueAxes) {\n  Shape.call(this, {\n    type: Shape.types.CONVEXPOLYHEDRON\n  });\n  /**\n   * Array of Vec3\n   * @property vertices\n   * @type {Array}\n   */\n\n  this.vertices = points || [];\n  this.worldVertices = []; // World transformed version of .vertices\n\n  this.worldVerticesNeedsUpdate = true;\n  /**\n   * Array of integer arrays, indicating which vertices each face consists of\n   * @property faces\n   * @type {Array}\n   */\n\n  this.faces = faces || [];\n  /**\n   * Array of Vec3\n   * @property faceNormals\n   * @type {Array}\n   */\n\n  this.faceNormals = [];\n  this.computeNormals();\n  this.worldFaceNormalsNeedsUpdate = true;\n  this.worldFaceNormals = []; // World transformed version of .faceNormals\n\n  /**\n   * Array of Vec3\n   * @property uniqueEdges\n   * @type {Array}\n   */\n\n  this.uniqueEdges = [];\n  /**\n   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.\n   * @property {Array} uniqueAxes\n   */\n\n  this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;\n  this.computeEdges();\n  this.updateBoundingSphereRadius();\n}\n\nConvexPolyhedron.prototype = new Shape();\nConvexPolyhedron.prototype.constructor = ConvexPolyhedron;\nvar computeEdges_tmpEdge = new Vec3();\n/**\n * Computes uniqueEdges\n * @method computeEdges\n */\n\nConvexPolyhedron.prototype.computeEdges = function () {\n  var faces = this.faces;\n  var vertices = this.vertices;\n  var nv = vertices.length;\n  var edges = this.uniqueEdges;\n  edges.length = 0;\n  var edge = computeEdges_tmpEdge;\n\n  for (var i = 0; i !== faces.length; i++) {\n    var face = faces[i];\n    var numVertices = face.length;\n\n    for (var j = 0; j !== numVertices; j++) {\n      var k = (j + 1) % numVertices;\n      vertices[face[j]].vsub(vertices[face[k]], edge);\n      edge.normalize();\n      var found = false;\n\n      for (var p = 0; p !== edges.length; p++) {\n        if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        edges.push(edge.clone());\n      }\n    }\n  }\n};\n/**\n * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.\n * @method computeNormals\n */\n\n\nConvexPolyhedron.prototype.computeNormals = function () {\n  this.faceNormals.length = this.faces.length; // Generate normals\n\n  for (var i = 0; i < this.faces.length; i++) {\n    // Check so all vertices exists for this face\n    for (var j = 0; j < this.faces[i].length; j++) {\n      if (!this.vertices[this.faces[i][j]]) {\n        throw new Error(\"Vertex \" + this.faces[i][j] + \" not found!\");\n      }\n    }\n\n    var n = this.faceNormals[i] || new Vec3();\n    this.getFaceNormal(i, n);\n    n.negate(n);\n    this.faceNormals[i] = n;\n    var vertex = this.vertices[this.faces[i][0]];\n\n    if (n.dot(vertex) < 0) {\n      console.error(\".faceNormals[\" + i + \"] = Vec3(\" + n.toString() + \") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.\");\n\n      for (var j = 0; j < this.faces[i].length; j++) {\n        console.warn(\".vertices[\" + this.faces[i][j] + \"] = Vec3(\" + this.vertices[this.faces[i][j]].toString() + \")\");\n      }\n    }\n  }\n};\n/**\n * Get face normal given 3 vertices\n * @static\n * @method getFaceNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\n\n\nvar cb = new Vec3();\nvar ab = new Vec3();\n\nConvexPolyhedron.computeNormal = function (va, vb, vc, target) {\n  vb.vsub(va, ab);\n  vc.vsub(vb, cb);\n  cb.cross(ab, target);\n\n  if (!target.isZero()) {\n    target.normalize();\n  }\n};\n/**\n * Compute the normal of a face from its vertices\n * @method getFaceNormal\n * @param  {Number} i\n * @param  {Vec3} target\n */\n\n\nConvexPolyhedron.prototype.getFaceNormal = function (i, target) {\n  var f = this.faces[i];\n  var va = this.vertices[f[0]];\n  var vb = this.vertices[f[1]];\n  var vc = this.vertices[f[2]];\n  return ConvexPolyhedron.computeNormal(va, vb, vc, target);\n};\n/**\n * @method clipAgainstHull\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} separatingNormal\n * @param {Number} minDist Clamp distance\n * @param {Number} maxDist\n * @param {array} result The an array of contact point objects, see clipFaceAgainstHull\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n */\n\n\nvar cah_WorldNormal = new Vec3();\n\nConvexPolyhedron.prototype.clipAgainstHull = function (posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {\n  var WorldNormal = cah_WorldNormal;\n  var hullA = this;\n  var curMaxDist = maxDist;\n  var closestFaceB = -1;\n  var dmax = -Number.MAX_VALUE;\n\n  for (var face = 0; face < hullB.faces.length; face++) {\n    WorldNormal.copy(hullB.faceNormals[face]);\n    quatB.vmult(WorldNormal, WorldNormal); //posB.vadd(WorldNormal,WorldNormal);\n\n    var d = WorldNormal.dot(separatingNormal);\n\n    if (d > dmax) {\n      dmax = d;\n      closestFaceB = face;\n    }\n  }\n\n  var worldVertsB1 = [];\n  var polyB = hullB.faces[closestFaceB];\n  var numVertices = polyB.length;\n\n  for (var e0 = 0; e0 < numVertices; e0++) {\n    var b = hullB.vertices[polyB[e0]];\n    var worldb = new Vec3();\n    worldb.copy(b);\n    quatB.vmult(worldb, worldb);\n    posB.vadd(worldb, worldb);\n    worldVertsB1.push(worldb);\n  }\n\n  if (closestFaceB >= 0) {\n    this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);\n  }\n};\n/**\n * Find the separating axis between this hull and another\n * @method findSeparatingAxis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} target The target vector to save the axis in\n * @return {bool} Returns false if a separation is found, else true\n */\n\n\nvar fsa_faceANormalWS3 = new Vec3(),\n    fsa_Worldnormal1 = new Vec3(),\n    fsa_deltaC = new Vec3(),\n    fsa_worldEdge0 = new Vec3(),\n    fsa_worldEdge1 = new Vec3(),\n    fsa_Cross = new Vec3();\n\nConvexPolyhedron.prototype.findSeparatingAxis = function (hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {\n  var faceANormalWS3 = fsa_faceANormalWS3,\n      Worldnormal1 = fsa_Worldnormal1,\n      deltaC = fsa_deltaC,\n      worldEdge0 = fsa_worldEdge0,\n      worldEdge1 = fsa_worldEdge1,\n      Cross = fsa_Cross;\n  var dmin = Number.MAX_VALUE;\n  var hullA = this;\n  var curPlaneTests = 0;\n\n  if (!hullA.uniqueAxes) {\n    var numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA\n\n    for (var i = 0; i < numFacesA; i++) {\n      var fi = faceListA ? faceListA[i] : i; // Get world face normal\n\n      faceANormalWS3.copy(hullA.faceNormals[fi]);\n      quatA.vmult(faceANormalWS3, faceANormalWS3);\n      var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n\n      if (d === false) {\n        return false;\n      }\n\n      if (d < dmin) {\n        dmin = d;\n        target.copy(faceANormalWS3);\n      }\n    }\n  } else {\n    // Test unique axes\n    for (var i = 0; i !== hullA.uniqueAxes.length; i++) {\n      // Get world axis\n      quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);\n      var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n\n      if (d === false) {\n        return false;\n      }\n\n      if (d < dmin) {\n        dmin = d;\n        target.copy(faceANormalWS3);\n      }\n    }\n  }\n\n  if (!hullB.uniqueAxes) {\n    // Test face normals from hullB\n    var numFacesB = faceListB ? faceListB.length : hullB.faces.length;\n\n    for (var i = 0; i < numFacesB; i++) {\n      var fi = faceListB ? faceListB[i] : i;\n      Worldnormal1.copy(hullB.faceNormals[fi]);\n      quatB.vmult(Worldnormal1, Worldnormal1);\n      curPlaneTests++;\n      var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);\n\n      if (d === false) {\n        return false;\n      }\n\n      if (d < dmin) {\n        dmin = d;\n        target.copy(Worldnormal1);\n      }\n    }\n  } else {\n    // Test unique axes in B\n    for (var i = 0; i !== hullB.uniqueAxes.length; i++) {\n      quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);\n      curPlaneTests++;\n      var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);\n\n      if (d === false) {\n        return false;\n      }\n\n      if (d < dmin) {\n        dmin = d;\n        target.copy(Worldnormal1);\n      }\n    }\n  } // Test edges\n\n\n  for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {\n    // Get world edge\n    quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);\n\n    for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {\n      // Get world edge 2\n      quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);\n      worldEdge0.cross(worldEdge1, Cross);\n\n      if (!Cross.almostZero()) {\n        Cross.normalize();\n        var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);\n\n        if (dist === false) {\n          return false;\n        }\n\n        if (dist < dmin) {\n          dmin = dist;\n          target.copy(Cross);\n        }\n      }\n    }\n  }\n\n  posB.vsub(posA, deltaC);\n\n  if (deltaC.dot(target) > 0.0) {\n    target.negate(target);\n  }\n\n  return true;\n};\n\nvar maxminA = [],\n    maxminB = [];\n/**\n * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.\n * @method testSepAxis\n * @param {Vec3} axis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @return {number} The overlap depth, or FALSE if no penetration.\n */\n\nConvexPolyhedron.prototype.testSepAxis = function (axis, hullB, posA, quatA, posB, quatB) {\n  var hullA = this;\n  ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);\n  ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);\n  var maxA = maxminA[0];\n  var minA = maxminA[1];\n  var maxB = maxminB[0];\n  var minB = maxminB[1];\n\n  if (maxA < minB || maxB < minA) {\n    return false; // Separated\n  }\n\n  var d0 = maxA - minB;\n  var d1 = maxB - minA;\n  var depth = d0 < d1 ? d0 : d1;\n  return depth;\n};\n\nvar cli_aabbmin = new Vec3(),\n    cli_aabbmax = new Vec3();\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n */\n\nConvexPolyhedron.prototype.calculateLocalInertia = function (mass, target) {\n  // Approximate with box inertia\n  // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n  this.computeLocalAABB(cli_aabbmin, cli_aabbmax);\n  var x = cli_aabbmax.x - cli_aabbmin.x,\n      y = cli_aabbmax.y - cli_aabbmin.y,\n      z = cli_aabbmax.z - cli_aabbmin.z;\n  target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);\n  target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);\n  target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);\n};\n/**\n * @method getPlaneConstantOfFace\n * @param  {Number} face_i Index of the face\n * @return {Number}\n */\n\n\nConvexPolyhedron.prototype.getPlaneConstantOfFace = function (face_i) {\n  var f = this.faces[face_i];\n  var n = this.faceNormals[face_i];\n  var v = this.vertices[f[0]];\n  var c = -n.dot(v);\n  return c;\n};\n/**\n * Clip a face against a hull.\n * @method clipFaceAgainstHull\n * @param {Vec3} separatingNormal\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.\n * @param {Number} minDist Distance clamping\n * @param {Number} maxDist\n * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.\n */\n\n\nvar cfah_faceANormalWS = new Vec3(),\n    cfah_edge0 = new Vec3(),\n    cfah_WorldEdge0 = new Vec3(),\n    cfah_worldPlaneAnormal1 = new Vec3(),\n    cfah_planeNormalWS1 = new Vec3(),\n    cfah_worldA1 = new Vec3(),\n    cfah_localPlaneNormal = new Vec3(),\n    cfah_planeNormalWS = new Vec3();\n\nConvexPolyhedron.prototype.clipFaceAgainstHull = function (separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {\n  var faceANormalWS = cfah_faceANormalWS,\n      edge0 = cfah_edge0,\n      WorldEdge0 = cfah_WorldEdge0,\n      worldPlaneAnormal1 = cfah_worldPlaneAnormal1,\n      planeNormalWS1 = cfah_planeNormalWS1,\n      worldA1 = cfah_worldA1,\n      localPlaneNormal = cfah_localPlaneNormal,\n      planeNormalWS = cfah_planeNormalWS;\n  var hullA = this;\n  var worldVertsB2 = [];\n  var pVtxIn = worldVertsB1;\n  var pVtxOut = worldVertsB2; // Find the face with normal closest to the separating axis\n\n  var closestFaceA = -1;\n  var dmin = Number.MAX_VALUE;\n\n  for (var face = 0; face < hullA.faces.length; face++) {\n    faceANormalWS.copy(hullA.faceNormals[face]);\n    quatA.vmult(faceANormalWS, faceANormalWS); //posA.vadd(faceANormalWS,faceANormalWS);\n\n    var d = faceANormalWS.dot(separatingNormal);\n\n    if (d < dmin) {\n      dmin = d;\n      closestFaceA = face;\n    }\n  }\n\n  if (closestFaceA < 0) {\n    // console.log(\"--- did not find any closest face... ---\");\n    return;\n  } //console.log(\"closest A: \",closestFaceA);\n  // Get the face and construct connected faces\n\n\n  var polyA = hullA.faces[closestFaceA];\n  polyA.connectedFaces = [];\n\n  for (var i = 0; i < hullA.faces.length; i++) {\n    for (var j = 0; j < hullA.faces[i].length; j++) {\n      if (polyA.indexOf(hullA.faces[i][j]) !== -1\n      /* Sharing a vertex*/\n      && i !== closestFaceA\n      /* Not the one we are looking for connections from */\n      && polyA.connectedFaces.indexOf(i) === -1\n      /* Not already added */\n      ) {\n          polyA.connectedFaces.push(i);\n        }\n    }\n  } // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face\n\n\n  var numContacts = pVtxIn.length;\n  var numVerticesA = polyA.length;\n  var res = [];\n\n  for (var e0 = 0; e0 < numVerticesA; e0++) {\n    var a = hullA.vertices[polyA[e0]];\n    var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];\n    a.vsub(b, edge0);\n    WorldEdge0.copy(edge0);\n    quatA.vmult(WorldEdge0, WorldEdge0);\n    posA.vadd(WorldEdge0, WorldEdge0);\n    worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]); //transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);\n\n    quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);\n    posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);\n    WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);\n    planeNormalWS1.negate(planeNormalWS1);\n    worldA1.copy(a);\n    quatA.vmult(worldA1, worldA1);\n    posA.vadd(worldA1, worldA1);\n    var planeEqWS1 = -worldA1.dot(planeNormalWS1);\n    var planeEqWS;\n\n    if (true) {\n      var otherFace = polyA.connectedFaces[e0];\n      localPlaneNormal.copy(this.faceNormals[otherFace]);\n      var localPlaneEq = this.getPlaneConstantOfFace(otherFace);\n      planeNormalWS.copy(localPlaneNormal);\n      quatA.vmult(planeNormalWS, planeNormalWS); //posA.vadd(planeNormalWS,planeNormalWS);\n\n      var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n    } else {\n      planeNormalWS.copy(planeNormalWS1);\n      planeEqWS = planeEqWS1;\n    } // Clip face against our constructed plane\n\n\n    this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the reamining until next clip\n\n    while (pVtxIn.length) {\n      pVtxIn.shift();\n    }\n\n    while (pVtxOut.length) {\n      pVtxIn.push(pVtxOut.shift());\n    }\n  } //console.log(\"Resulting points after clip:\",pVtxIn);\n  // only keep contact points that are behind the witness face\n\n\n  localPlaneNormal.copy(this.faceNormals[closestFaceA]);\n  var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);\n  planeNormalWS.copy(localPlaneNormal);\n  quatA.vmult(planeNormalWS, planeNormalWS);\n  var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n\n  for (var i = 0; i < pVtxIn.length; i++) {\n    var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???\n\n    /*console.log(\"depth calc from normal=\",planeNormalWS.toString(),\" and constant \"+planeEqWS+\" and vertex \",pVtxIn[i].toString(),\" gives \"+depth);*/\n\n    if (depth <= minDist) {\n      console.log(\"clamped: depth=\" + depth + \" to minDist=\" + (minDist + \"\"));\n      depth = minDist;\n    }\n\n    if (depth <= maxDist) {\n      var point = pVtxIn[i];\n\n      if (depth <= 0) {\n        /*console.log(\"Got contact point \",point.toString(),\n          \", depth=\",depth,\n          \"contact normal=\",separatingNormal.toString(),\n          \"plane\",planeNormalWS.toString(),\n          \"planeConstant\",planeEqWS);*/\n        var p = {\n          point: point,\n          normal: planeNormalWS,\n          depth: depth\n        };\n        result.push(p);\n      }\n    }\n  }\n};\n/**\n * Clip a face in a hull against the back of a plane.\n * @method clipFaceAgainstPlane\n * @param {Array} inVertices\n * @param {Array} outVertices\n * @param {Vec3} planeNormal\n * @param {Number} planeConstant The constant in the mathematical plane equation\n */\n\n\nConvexPolyhedron.prototype.clipFaceAgainstPlane = function (inVertices, outVertices, planeNormal, planeConstant) {\n  var n_dot_first, n_dot_last;\n  var numVerts = inVertices.length;\n\n  if (numVerts < 2) {\n    return outVertices;\n  }\n\n  var firstVertex = inVertices[inVertices.length - 1],\n      lastVertex = inVertices[0];\n  n_dot_first = planeNormal.dot(firstVertex) + planeConstant;\n\n  for (var vi = 0; vi < numVerts; vi++) {\n    lastVertex = inVertices[vi];\n    n_dot_last = planeNormal.dot(lastVertex) + planeConstant;\n\n    if (n_dot_first < 0) {\n      if (n_dot_last < 0) {\n        // Start < 0, end < 0, so output lastVertex\n        var newv = new Vec3();\n        newv.copy(lastVertex);\n        outVertices.push(newv);\n      } else {\n        // Start < 0, end >= 0, so output intersection\n        var newv = new Vec3();\n        firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);\n        outVertices.push(newv);\n      }\n    } else {\n      if (n_dot_last < 0) {\n        // Start >= 0, end < 0 so output intersection and end\n        var newv = new Vec3();\n        firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);\n        outVertices.push(newv);\n        outVertices.push(lastVertex);\n      }\n    }\n\n    firstVertex = lastVertex;\n    n_dot_first = n_dot_last;\n  }\n\n  return outVertices;\n}; // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\n\n\nConvexPolyhedron.prototype.computeWorldVertices = function (position, quat) {\n  var N = this.vertices.length;\n\n  while (this.worldVertices.length < N) {\n    this.worldVertices.push(new Vec3());\n  }\n\n  var verts = this.vertices,\n      worldVerts = this.worldVertices;\n\n  for (var i = 0; i !== N; i++) {\n    quat.vmult(verts[i], worldVerts[i]);\n    position.vadd(worldVerts[i], worldVerts[i]);\n  }\n\n  this.worldVerticesNeedsUpdate = false;\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\n\nConvexPolyhedron.prototype.computeLocalAABB = function (aabbmin, aabbmax) {\n  var n = this.vertices.length,\n      vertices = this.vertices,\n      worldVert = computeLocalAABB_worldVert;\n  aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n  for (var i = 0; i < n; i++) {\n    var v = vertices[i];\n\n    if (v.x < aabbmin.x) {\n      aabbmin.x = v.x;\n    } else if (v.x > aabbmax.x) {\n      aabbmax.x = v.x;\n    }\n\n    if (v.y < aabbmin.y) {\n      aabbmin.y = v.y;\n    } else if (v.y > aabbmax.y) {\n      aabbmax.y = v.y;\n    }\n\n    if (v.z < aabbmin.z) {\n      aabbmin.z = v.z;\n    } else if (v.z > aabbmax.z) {\n      aabbmax.z = v.z;\n    }\n  }\n};\n/**\n * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\n * @method computeWorldFaceNormals\n * @param  {Quaternion} quat\n */\n\n\nConvexPolyhedron.prototype.computeWorldFaceNormals = function (quat) {\n  var N = this.faceNormals.length;\n\n  while (this.worldFaceNormals.length < N) {\n    this.worldFaceNormals.push(new Vec3());\n  }\n\n  var normals = this.faceNormals,\n      worldNormals = this.worldFaceNormals;\n\n  for (var i = 0; i !== N; i++) {\n    quat.vmult(normals[i], worldNormals[i]);\n  }\n\n  this.worldFaceNormalsNeedsUpdate = false;\n};\n/**\n * @method updateBoundingSphereRadius\n */\n\n\nConvexPolyhedron.prototype.updateBoundingSphereRadius = function () {\n  // Assume points are distributed with local (0,0,0) as center\n  var max2 = 0;\n  var verts = this.vertices;\n\n  for (var i = 0, N = verts.length; i !== N; i++) {\n    var norm2 = verts[i].norm2();\n\n    if (norm2 > max2) {\n      max2 = norm2;\n    }\n  }\n\n  this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\n\nConvexPolyhedron.prototype.calculateWorldAABB = function (pos, quat, min, max) {\n  var n = this.vertices.length,\n      verts = this.vertices;\n  var minx, miny, minz, maxx, maxy, maxz;\n\n  for (var i = 0; i < n; i++) {\n    tempWorldVertex.copy(verts[i]);\n    quat.vmult(tempWorldVertex, tempWorldVertex);\n    pos.vadd(tempWorldVertex, tempWorldVertex);\n    var v = tempWorldVertex;\n\n    if (v.x < minx || minx === undefined) {\n      minx = v.x;\n    } else if (v.x > maxx || maxx === undefined) {\n      maxx = v.x;\n    }\n\n    if (v.y < miny || miny === undefined) {\n      miny = v.y;\n    } else if (v.y > maxy || maxy === undefined) {\n      maxy = v.y;\n    }\n\n    if (v.z < minz || minz === undefined) {\n      minz = v.z;\n    } else if (v.z > maxz || maxz === undefined) {\n      maxz = v.z;\n    }\n  }\n\n  min.set(minx, miny, minz);\n  max.set(maxx, maxy, maxz);\n};\n/**\n * Get approximate convex volume\n * @method volume\n * @return {Number}\n */\n\n\nConvexPolyhedron.prototype.volume = function () {\n  return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n/**\n * Get an average of all the vertices positions\n * @method getAveragePointLocal\n * @param  {Vec3} target\n * @return {Vec3}\n */\n\n\nConvexPolyhedron.prototype.getAveragePointLocal = function (target) {\n  target = target || new Vec3();\n  var n = this.vertices.length,\n      verts = this.vertices;\n\n  for (var i = 0; i < n; i++) {\n    target.vadd(verts[i], target);\n  }\n\n  target.mult(1 / n, target);\n  return target;\n};\n/**\n * Transform all local points. Will change the .vertices\n * @method transformAllPoints\n * @param  {Vec3} offset\n * @param  {Quaternion} quat\n */\n\n\nConvexPolyhedron.prototype.transformAllPoints = function (offset, quat) {\n  var n = this.vertices.length,\n      verts = this.vertices; // Apply rotation\n\n  if (quat) {\n    // Rotate vertices\n    for (var i = 0; i < n; i++) {\n      var v = verts[i];\n      quat.vmult(v, v);\n    } // Rotate face normals\n\n\n    for (var i = 0; i < this.faceNormals.length; i++) {\n      var v = this.faceNormals[i];\n      quat.vmult(v, v);\n    }\n    /*\n    // Rotate edges\n    for(var i=0; i<this.uniqueEdges.length; i++){\n        var v = this.uniqueEdges[i];\n        quat.vmult(v,v);\n    }*/\n\n  } // Apply offset\n\n\n  if (offset) {\n    for (var i = 0; i < n; i++) {\n      var v = verts[i];\n      v.vadd(offset, v);\n    }\n  }\n};\n/**\n * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.\n * @method pointIsInside\n * @param  {Vec3} p      A point given in local coordinates\n * @return {Boolean}\n */\n\n\nvar ConvexPolyhedron_pointIsInside = new Vec3();\nvar ConvexPolyhedron_vToP = new Vec3();\nvar ConvexPolyhedron_vToPointInside = new Vec3();\n\nConvexPolyhedron.prototype.pointIsInside = function (p) {\n  var n = this.vertices.length,\n      verts = this.vertices,\n      faces = this.faces,\n      normals = this.faceNormals;\n  var positiveResult = null;\n  var N = this.faces.length;\n  var pointInside = ConvexPolyhedron_pointIsInside;\n  this.getAveragePointLocal(pointInside);\n\n  for (var i = 0; i < N; i++) {\n    var numVertices = this.faces[i].length;\n    var n = normals[i];\n    var v = verts[faces[i][0]]; // We only need one point in the face\n    // This dot product determines which side of the edge the point is\n\n    var vToP = ConvexPolyhedron_vToP;\n    p.vsub(v, vToP);\n    var r1 = n.dot(vToP);\n    var vToPointInside = ConvexPolyhedron_vToPointInside;\n    pointInside.vsub(v, vToPointInside);\n    var r2 = n.dot(vToPointInside);\n\n    if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {\n      return false; // Encountered some other sign. Exit.\n    } else {}\n  } // If we got here, all dot products were of the same sign.\n\n\n  return positiveResult ? 1 : -1;\n};\n/**\n * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.\n * @static\n * @method project\n * @param {ConvexPolyhedron} hull\n * @param {Vec3} axis\n * @param {Vec3} pos\n * @param {Quaternion} quat\n * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.\n */\n\n\nvar project_worldVertex = new Vec3();\nvar project_localAxis = new Vec3();\nvar project_localOrigin = new Vec3();\n\nConvexPolyhedron.project = function (hull, axis, pos, quat, result) {\n  var n = hull.vertices.length,\n      worldVertex = project_worldVertex,\n      localAxis = project_localAxis,\n      max = 0,\n      min = 0,\n      localOrigin = project_localOrigin,\n      vs = hull.vertices;\n  localOrigin.setZero(); // Transform the axis to local\n\n  Transform.vectorToLocalFrame(pos, quat, axis, localAxis);\n  Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);\n  var add = localOrigin.dot(localAxis);\n  min = max = vs[0].dot(localAxis);\n\n  for (var i = 1; i < n; i++) {\n    var val = vs[i].dot(localAxis);\n\n    if (val > max) {\n      max = val;\n    }\n\n    if (val < min) {\n      min = val;\n    }\n  }\n\n  min -= add;\n  max -= add;\n\n  if (min > max) {\n    // Inconsistent - swap\n    var temp = min;\n    min = max;\n    max = temp;\n  } // Output\n\n\n  result[0] = max;\n  result[1] = min;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/shapes/ConvexPolyhedron.js"],"names":["module","exports","ConvexPolyhedron","Shape","require","Vec3","Quaternion","Transform","points","faces","uniqueAxes","call","type","types","CONVEXPOLYHEDRON","vertices","worldVertices","worldVerticesNeedsUpdate","faceNormals","computeNormals","worldFaceNormalsNeedsUpdate","worldFaceNormals","uniqueEdges","slice","computeEdges","updateBoundingSphereRadius","prototype","constructor","computeEdges_tmpEdge","nv","length","edges","edge","i","face","numVertices","j","k","vsub","normalize","found","p","almostEquals","push","clone","Error","n","getFaceNormal","negate","vertex","dot","console","error","toString","warn","cb","ab","computeNormal","va","vb","vc","target","cross","isZero","f","cah_WorldNormal","clipAgainstHull","posA","quatA","hullB","posB","quatB","separatingNormal","minDist","maxDist","result","WorldNormal","hullA","curMaxDist","closestFaceB","dmax","Number","MAX_VALUE","copy","vmult","d","worldVertsB1","polyB","e0","b","worldb","vadd","clipFaceAgainstHull","fsa_faceANormalWS3","fsa_Worldnormal1","fsa_deltaC","fsa_worldEdge0","fsa_worldEdge1","fsa_Cross","findSeparatingAxis","faceListA","faceListB","faceANormalWS3","Worldnormal1","deltaC","worldEdge0","worldEdge1","Cross","dmin","curPlaneTests","numFacesA","fi","testSepAxis","numFacesB","e1","almostZero","dist","maxminA","maxminB","axis","project","maxA","minA","maxB","minB","d0","d1","depth","cli_aabbmin","cli_aabbmax","calculateLocalInertia","mass","computeLocalAABB","x","y","z","getPlaneConstantOfFace","face_i","v","c","cfah_faceANormalWS","cfah_edge0","cfah_WorldEdge0","cfah_worldPlaneAnormal1","cfah_planeNormalWS1","cfah_worldA1","cfah_localPlaneNormal","cfah_planeNormalWS","faceANormalWS","edge0","WorldEdge0","worldPlaneAnormal1","planeNormalWS1","worldA1","localPlaneNormal","planeNormalWS","worldVertsB2","pVtxIn","pVtxOut","closestFaceA","polyA","connectedFaces","indexOf","numContacts","numVerticesA","res","a","planeEqWS1","planeEqWS","otherFace","localPlaneEq","clipFaceAgainstPlane","shift","log","point","normal","inVertices","outVertices","planeNormal","planeConstant","n_dot_first","n_dot_last","numVerts","firstVertex","lastVertex","vi","newv","lerp","computeWorldVertices","position","quat","N","verts","worldVerts","computeLocalAABB_worldVert","aabbmin","aabbmax","worldVert","set","computeWorldFaceNormals","normals","worldNormals","max2","norm2","boundingSphereRadius","Math","sqrt","tempWorldVertex","calculateWorldAABB","pos","min","max","minx","miny","minz","maxx","maxy","maxz","undefined","volume","PI","getAveragePointLocal","mult","transformAllPoints","offset","ConvexPolyhedron_pointIsInside","ConvexPolyhedron_vToP","ConvexPolyhedron_vToPointInside","pointIsInside","positiveResult","pointInside","vToP","r1","vToPointInside","r2","project_worldVertex","project_localAxis","project_localOrigin","hull","worldVertex","localAxis","localOrigin","vs","setZero","vectorToLocalFrame","pointToLocalFrame","add","val","temp"],"mappings":"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","sourcesContent":["module.exports = ConvexPolyhedron;\n\nvar Shape = require('./Shape');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Transform = require('../math/Transform');\n\n/**\n * A set of polygons describing a convex shape.\n * @class ConvexPolyhedron\n * @constructor\n * @extends Shape\n * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained\n * in the same 3D plane), instead these should be merged into one polygon.\n *\n * @param {array} points An array of Vec3's\n * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.\n *\n * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)\n * @author schteppe / https://github.com/schteppe\n * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n *\n * @todo Move the clipping functions to ContactGenerator?\n * @todo Automatically merge coplanar polygons in constructor.\n */\nfunction ConvexPolyhedron(points, faces, uniqueAxes) {\n    Shape.call(this, {\n        type: Shape.types.CONVEXPOLYHEDRON\n    });\n\n    /**\n     * Array of Vec3\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = points||[];\n\n    this.worldVertices = []; // World transformed version of .vertices\n    this.worldVerticesNeedsUpdate = true;\n\n    /**\n     * Array of integer arrays, indicating which vertices each face consists of\n     * @property faces\n     * @type {Array}\n     */\n    this.faces = faces||[];\n\n    /**\n     * Array of Vec3\n     * @property faceNormals\n     * @type {Array}\n     */\n    this.faceNormals = [];\n    this.computeNormals();\n\n    this.worldFaceNormalsNeedsUpdate = true;\n    this.worldFaceNormals = []; // World transformed version of .faceNormals\n\n    /**\n     * Array of Vec3\n     * @property uniqueEdges\n     * @type {Array}\n     */\n    this.uniqueEdges = [];\n\n    /**\n     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.\n     * @property {Array} uniqueAxes\n     */\n    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;\n\n    this.computeEdges();\n    this.updateBoundingSphereRadius();\n}\nConvexPolyhedron.prototype = new Shape();\nConvexPolyhedron.prototype.constructor = ConvexPolyhedron;\n\nvar computeEdges_tmpEdge = new Vec3();\n/**\n * Computes uniqueEdges\n * @method computeEdges\n */\nConvexPolyhedron.prototype.computeEdges = function(){\n    var faces = this.faces;\n    var vertices = this.vertices;\n    var nv = vertices.length;\n    var edges = this.uniqueEdges;\n\n    edges.length = 0;\n\n    var edge = computeEdges_tmpEdge;\n\n    for(var i=0; i !== faces.length; i++){\n        var face = faces[i];\n        var numVertices = face.length;\n        for(var j = 0; j !== numVertices; j++){\n            var k = ( j+1 ) % numVertices;\n            vertices[face[j]].vsub(vertices[face[k]], edge);\n            edge.normalize();\n            var found = false;\n            for(var p=0; p !== edges.length; p++){\n                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found){\n                edges.push(edge.clone());\n            }\n        }\n    }\n};\n\n/**\n * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.\n * @method computeNormals\n */\nConvexPolyhedron.prototype.computeNormals = function(){\n    this.faceNormals.length = this.faces.length;\n\n    // Generate normals\n    for(var i=0; i<this.faces.length; i++){\n\n        // Check so all vertices exists for this face\n        for(var j=0; j<this.faces[i].length; j++){\n            if(!this.vertices[this.faces[i][j]]){\n                throw new Error(\"Vertex \"+this.faces[i][j]+\" not found!\");\n            }\n        }\n\n        var n = this.faceNormals[i] || new Vec3();\n        this.getFaceNormal(i,n);\n        n.negate(n);\n        this.faceNormals[i] = n;\n        var vertex = this.vertices[this.faces[i][0]];\n        if(n.dot(vertex) < 0){\n            console.error(\".faceNormals[\" + i + \"] = Vec3(\"+n.toString()+\") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.\");\n            for(var j=0; j<this.faces[i].length; j++){\n                console.warn(\".vertices[\"+this.faces[i][j]+\"] = Vec3(\"+this.vertices[this.faces[i][j]].toString()+\")\");\n            }\n        }\n    }\n};\n\n/**\n * Get face normal given 3 vertices\n * @static\n * @method getFaceNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\nvar cb = new Vec3();\nvar ab = new Vec3();\nConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {\n    vb.vsub(va,ab);\n    vc.vsub(vb,cb);\n    cb.cross(ab,target);\n    if ( !target.isZero() ) {\n        target.normalize();\n    }\n};\n\n/**\n * Compute the normal of a face from its vertices\n * @method getFaceNormal\n * @param  {Number} i\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.getFaceNormal = function(i,target){\n    var f = this.faces[i];\n    var va = this.vertices[f[0]];\n    var vb = this.vertices[f[1]];\n    var vc = this.vertices[f[2]];\n    return ConvexPolyhedron.computeNormal(va,vb,vc,target);\n};\n\n/**\n * @method clipAgainstHull\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} separatingNormal\n * @param {Number} minDist Clamp distance\n * @param {Number} maxDist\n * @param {array} result The an array of contact point objects, see clipFaceAgainstHull\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n */\nvar cah_WorldNormal = new Vec3();\nConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){\n    var WorldNormal = cah_WorldNormal;\n    var hullA = this;\n    var curMaxDist = maxDist;\n    var closestFaceB = -1;\n    var dmax = -Number.MAX_VALUE;\n    for(var face=0; face < hullB.faces.length; face++){\n        WorldNormal.copy(hullB.faceNormals[face]);\n        quatB.vmult(WorldNormal,WorldNormal);\n        //posB.vadd(WorldNormal,WorldNormal);\n        var d = WorldNormal.dot(separatingNormal);\n        if (d > dmax){\n            dmax = d;\n            closestFaceB = face;\n        }\n    }\n    var worldVertsB1 = [];\n    var polyB = hullB.faces[closestFaceB];\n    var numVertices = polyB.length;\n    for(var e0=0; e0<numVertices; e0++){\n        var b = hullB.vertices[polyB[e0]];\n        var worldb = new Vec3();\n        worldb.copy(b);\n        quatB.vmult(worldb,worldb);\n        posB.vadd(worldb,worldb);\n        worldVertsB1.push(worldb);\n    }\n\n    if (closestFaceB>=0){\n        this.clipFaceAgainstHull(separatingNormal,\n                                 posA,\n                                 quatA,\n                                 worldVertsB1,\n                                 minDist,\n                                 maxDist,\n                                 result);\n    }\n};\n\n/**\n * Find the separating axis between this hull and another\n * @method findSeparatingAxis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} target The target vector to save the axis in\n * @return {bool} Returns false if a separation is found, else true\n */\nvar fsa_faceANormalWS3 = new Vec3(),\n    fsa_Worldnormal1 = new Vec3(),\n    fsa_deltaC = new Vec3(),\n    fsa_worldEdge0 = new Vec3(),\n    fsa_worldEdge1 = new Vec3(),\n    fsa_Cross = new Vec3();\nConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){\n    var faceANormalWS3 = fsa_faceANormalWS3,\n        Worldnormal1 = fsa_Worldnormal1,\n        deltaC = fsa_deltaC,\n        worldEdge0 = fsa_worldEdge0,\n        worldEdge1 = fsa_worldEdge1,\n        Cross = fsa_Cross;\n\n    var dmin = Number.MAX_VALUE;\n    var hullA = this;\n    var curPlaneTests=0;\n\n    if(!hullA.uniqueAxes){\n\n        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;\n\n        // Test face normals from hullA\n        for(var i=0; i<numFacesA; i++){\n            var fi = faceListA ? faceListA[i] : i;\n\n            // Get world face normal\n            faceANormalWS3.copy(hullA.faceNormals[fi]);\n            quatA.vmult(faceANormalWS3,faceANormalWS3);\n\n            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(faceANormalWS3);\n            }\n        }\n\n    } else {\n\n        // Test unique axes\n        for(var i = 0; i !== hullA.uniqueAxes.length; i++){\n\n            // Get world axis\n            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);\n\n            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(faceANormalWS3);\n            }\n        }\n    }\n\n    if(!hullB.uniqueAxes){\n\n        // Test face normals from hullB\n        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;\n        for(var i=0;i<numFacesB;i++){\n\n            var fi = faceListB ? faceListB[i] : i;\n\n            Worldnormal1.copy(hullB.faceNormals[fi]);\n            quatB.vmult(Worldnormal1,Worldnormal1);\n            curPlaneTests++;\n            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(Worldnormal1);\n            }\n        }\n    } else {\n\n        // Test unique axes in B\n        for(var i = 0; i !== hullB.uniqueAxes.length; i++){\n            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);\n\n            curPlaneTests++;\n            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(Worldnormal1);\n            }\n        }\n    }\n\n    // Test edges\n    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){\n\n        // Get world edge\n        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);\n\n        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){\n\n            // Get world edge 2\n            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);\n            worldEdge0.cross(worldEdge1,Cross);\n\n            if(!Cross.almostZero()){\n                Cross.normalize();\n                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);\n                if(dist === false){\n                    return false;\n                }\n                if(dist < dmin){\n                    dmin = dist;\n                    target.copy(Cross);\n                }\n            }\n        }\n    }\n\n    posB.vsub(posA,deltaC);\n    if((deltaC.dot(target))>0.0){\n        target.negate(target);\n    }\n\n    return true;\n};\n\nvar maxminA=[], maxminB=[];\n\n/**\n * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.\n * @method testSepAxis\n * @param {Vec3} axis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @return {number} The overlap depth, or FALSE if no penetration.\n */\nConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){\n    var hullA=this;\n    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);\n    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);\n    var maxA = maxminA[0];\n    var minA = maxminA[1];\n    var maxB = maxminB[0];\n    var minB = maxminB[1];\n    if(maxA<minB || maxB<minA){\n        return false; // Separated\n    }\n    var d0 = maxA - minB;\n    var d1 = maxB - minA;\n    var depth = d0<d1 ? d0:d1;\n    return depth;\n};\n\nvar cli_aabbmin = new Vec3(),\n    cli_aabbmax = new Vec3();\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){\n    // Approximate with box inertia\n    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);\n    var x = cli_aabbmax.x - cli_aabbmin.x,\n        y = cli_aabbmax.y - cli_aabbmin.y,\n        z = cli_aabbmax.z - cli_aabbmin.z;\n    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );\n    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );\n    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );\n};\n\n/**\n * @method getPlaneConstantOfFace\n * @param  {Number} face_i Index of the face\n * @return {Number}\n */\nConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){\n    var f = this.faces[face_i];\n    var n = this.faceNormals[face_i];\n    var v = this.vertices[f[0]];\n    var c = -n.dot(v);\n    return c;\n};\n\n/**\n * Clip a face against a hull.\n * @method clipFaceAgainstHull\n * @param {Vec3} separatingNormal\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.\n * @param {Number} minDist Distance clamping\n * @param {Number} maxDist\n * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.\n */\nvar cfah_faceANormalWS = new Vec3(),\n    cfah_edge0 = new Vec3(),\n    cfah_WorldEdge0 = new Vec3(),\n    cfah_worldPlaneAnormal1 = new Vec3(),\n    cfah_planeNormalWS1 = new Vec3(),\n    cfah_worldA1 = new Vec3(),\n    cfah_localPlaneNormal = new Vec3(),\n    cfah_planeNormalWS = new Vec3();\nConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){\n    var faceANormalWS = cfah_faceANormalWS,\n        edge0 = cfah_edge0,\n        WorldEdge0 = cfah_WorldEdge0,\n        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,\n        planeNormalWS1 = cfah_planeNormalWS1,\n        worldA1 = cfah_worldA1,\n        localPlaneNormal = cfah_localPlaneNormal,\n        planeNormalWS = cfah_planeNormalWS;\n\n    var hullA = this;\n    var worldVertsB2 = [];\n    var pVtxIn = worldVertsB1;\n    var pVtxOut = worldVertsB2;\n    // Find the face with normal closest to the separating axis\n    var closestFaceA = -1;\n    var dmin = Number.MAX_VALUE;\n    for(var face=0; face<hullA.faces.length; face++){\n        faceANormalWS.copy(hullA.faceNormals[face]);\n        quatA.vmult(faceANormalWS,faceANormalWS);\n        //posA.vadd(faceANormalWS,faceANormalWS);\n        var d = faceANormalWS.dot(separatingNormal);\n        if (d < dmin){\n            dmin = d;\n            closestFaceA = face;\n        }\n    }\n    if (closestFaceA < 0){\n        // console.log(\"--- did not find any closest face... ---\");\n        return;\n    }\n    //console.log(\"closest A: \",closestFaceA);\n    // Get the face and construct connected faces\n    var polyA = hullA.faces[closestFaceA];\n    polyA.connectedFaces = [];\n    for(var i=0; i<hullA.faces.length; i++){\n        for(var j=0; j<hullA.faces[i].length; j++){\n            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){\n                polyA.connectedFaces.push(i);\n            }\n        }\n    }\n    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face\n    var numContacts = pVtxIn.length;\n    var numVerticesA = polyA.length;\n    var res = [];\n    for(var e0=0; e0<numVerticesA; e0++){\n        var a = hullA.vertices[polyA[e0]];\n        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];\n        a.vsub(b,edge0);\n        WorldEdge0.copy(edge0);\n        quatA.vmult(WorldEdge0,WorldEdge0);\n        posA.vadd(WorldEdge0,WorldEdge0);\n        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);\n        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);\n        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);\n        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);\n        planeNormalWS1.negate(planeNormalWS1);\n        worldA1.copy(a);\n        quatA.vmult(worldA1,worldA1);\n        posA.vadd(worldA1,worldA1);\n        var planeEqWS1 = -worldA1.dot(planeNormalWS1);\n        var planeEqWS;\n        if(true){\n            var otherFace = polyA.connectedFaces[e0];\n            localPlaneNormal.copy(this.faceNormals[otherFace]);\n            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);\n\n            planeNormalWS.copy(localPlaneNormal);\n            quatA.vmult(planeNormalWS,planeNormalWS);\n            //posA.vadd(planeNormalWS,planeNormalWS);\n            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n        } else  {\n            planeNormalWS.copy(planeNormalWS1);\n            planeEqWS = planeEqWS1;\n        }\n\n        // Clip face against our constructed plane\n        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);\n\n        // Throw away all clipped points, but save the reamining until next clip\n        while(pVtxIn.length){\n            pVtxIn.shift();\n        }\n        while(pVtxOut.length){\n            pVtxIn.push(pVtxOut.shift());\n        }\n    }\n\n    //console.log(\"Resulting points after clip:\",pVtxIn);\n\n    // only keep contact points that are behind the witness face\n    localPlaneNormal.copy(this.faceNormals[closestFaceA]);\n\n    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);\n    planeNormalWS.copy(localPlaneNormal);\n    quatA.vmult(planeNormalWS,planeNormalWS);\n\n    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n    for (var i=0; i<pVtxIn.length; i++){\n        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???\n        /*console.log(\"depth calc from normal=\",planeNormalWS.toString(),\" and constant \"+planeEqWS+\" and vertex \",pVtxIn[i].toString(),\" gives \"+depth);*/\n        if (depth <=minDist){\n            console.log(\"clamped: depth=\"+depth+\" to minDist=\"+(minDist+\"\"));\n            depth = minDist;\n        }\n\n        if (depth <=maxDist){\n            var point = pVtxIn[i];\n            if(depth<=0){\n                /*console.log(\"Got contact point \",point.toString(),\n                  \", depth=\",depth,\n                  \"contact normal=\",separatingNormal.toString(),\n                  \"plane\",planeNormalWS.toString(),\n                  \"planeConstant\",planeEqWS);*/\n                var p = {\n                    point:point,\n                    normal:planeNormalWS,\n                    depth: depth,\n                };\n                result.push(p);\n            }\n        }\n    }\n};\n\n/**\n * Clip a face in a hull against the back of a plane.\n * @method clipFaceAgainstPlane\n * @param {Array} inVertices\n * @param {Array} outVertices\n * @param {Vec3} planeNormal\n * @param {Number} planeConstant The constant in the mathematical plane equation\n */\nConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){\n    var n_dot_first, n_dot_last;\n    var numVerts = inVertices.length;\n\n    if(numVerts < 2){\n        return outVertices;\n    }\n\n    var firstVertex = inVertices[inVertices.length-1],\n        lastVertex =   inVertices[0];\n\n    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;\n\n    for(var vi = 0; vi < numVerts; vi++){\n        lastVertex = inVertices[vi];\n        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;\n        if(n_dot_first < 0){\n            if(n_dot_last < 0){\n                // Start < 0, end < 0, so output lastVertex\n                var newv = new Vec3();\n                newv.copy(lastVertex);\n                outVertices.push(newv);\n            } else {\n                // Start < 0, end >= 0, so output intersection\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n            }\n        } else {\n            if(n_dot_last<0){\n                // Start >= 0, end < 0 so output intersection and end\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n                outVertices.push(lastVertex);\n            }\n        }\n        firstVertex = lastVertex;\n        n_dot_first = n_dot_last;\n    }\n    return outVertices;\n};\n\n// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\nConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){\n    var N = this.vertices.length;\n    while(this.worldVertices.length < N){\n        this.worldVertices.push( new Vec3() );\n    }\n\n    var verts = this.vertices,\n        worldVerts = this.worldVertices;\n    for(var i=0; i!==N; i++){\n        quat.vmult( verts[i] , worldVerts[i] );\n        position.vadd( worldVerts[i] , worldVerts[i] );\n    }\n\n    this.worldVerticesNeedsUpdate = false;\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\nConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){\n    var n = this.vertices.length,\n        vertices = this.vertices,\n        worldVert = computeLocalAABB_worldVert;\n\n    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for(var i=0; i<n; i++){\n        var v = vertices[i];\n        if     (v.x < aabbmin.x){\n            aabbmin.x = v.x;\n        } else if(v.x > aabbmax.x){\n            aabbmax.x = v.x;\n        }\n        if     (v.y < aabbmin.y){\n            aabbmin.y = v.y;\n        } else if(v.y > aabbmax.y){\n            aabbmax.y = v.y;\n        }\n        if     (v.z < aabbmin.z){\n            aabbmin.z = v.z;\n        } else if(v.z > aabbmax.z){\n            aabbmax.z = v.z;\n        }\n    }\n};\n\n/**\n * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\n * @method computeWorldFaceNormals\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){\n    var N = this.faceNormals.length;\n    while(this.worldFaceNormals.length < N){\n        this.worldFaceNormals.push( new Vec3() );\n    }\n\n    var normals = this.faceNormals,\n        worldNormals = this.worldFaceNormals;\n    for(var i=0; i!==N; i++){\n        quat.vmult( normals[i] , worldNormals[i] );\n    }\n\n    this.worldFaceNormalsNeedsUpdate = false;\n};\n\n/**\n * @method updateBoundingSphereRadius\n */\nConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){\n    // Assume points are distributed with local (0,0,0) as center\n    var max2 = 0;\n    var verts = this.vertices;\n    for(var i=0, N=verts.length; i!==N; i++) {\n        var norm2 = verts[i].norm2();\n        if(norm2 > max2){\n            max2 = norm2;\n        }\n    }\n    this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\n\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\nConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    var n = this.vertices.length, verts = this.vertices;\n    var minx,miny,minz,maxx,maxy,maxz;\n    for(var i=0; i<n; i++){\n        tempWorldVertex.copy(verts[i]);\n        quat.vmult(tempWorldVertex,tempWorldVertex);\n        pos.vadd(tempWorldVertex,tempWorldVertex);\n        var v = tempWorldVertex;\n        if     (v.x < minx || minx===undefined){\n            minx = v.x;\n        } else if(v.x > maxx || maxx===undefined){\n            maxx = v.x;\n        }\n\n        if     (v.y < miny || miny===undefined){\n            miny = v.y;\n        } else if(v.y > maxy || maxy===undefined){\n            maxy = v.y;\n        }\n\n        if     (v.z < minz || minz===undefined){\n            minz = v.z;\n        } else if(v.z > maxz || maxz===undefined){\n            maxz = v.z;\n        }\n    }\n    min.set(minx,miny,minz);\n    max.set(maxx,maxy,maxz);\n};\n\n/**\n * Get approximate convex volume\n * @method volume\n * @return {Number}\n */\nConvexPolyhedron.prototype.volume = function(){\n    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n\n/**\n * Get an average of all the vertices positions\n * @method getAveragePointLocal\n * @param  {Vec3} target\n * @return {Vec3}\n */\nConvexPolyhedron.prototype.getAveragePointLocal = function(target){\n    target = target || new Vec3();\n    var n = this.vertices.length,\n        verts = this.vertices;\n    for(var i=0; i<n; i++){\n        target.vadd(verts[i],target);\n    }\n    target.mult(1/n,target);\n    return target;\n};\n\n/**\n * Transform all local points. Will change the .vertices\n * @method transformAllPoints\n * @param  {Vec3} offset\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){\n    var n = this.vertices.length,\n        verts = this.vertices;\n\n    // Apply rotation\n    if(quat){\n        // Rotate vertices\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            quat.vmult(v,v);\n        }\n        // Rotate face normals\n        for(var i=0; i<this.faceNormals.length; i++){\n            var v = this.faceNormals[i];\n            quat.vmult(v,v);\n        }\n        /*\n        // Rotate edges\n        for(var i=0; i<this.uniqueEdges.length; i++){\n            var v = this.uniqueEdges[i];\n            quat.vmult(v,v);\n        }*/\n    }\n\n    // Apply offset\n    if(offset){\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            v.vadd(offset,v);\n        }\n    }\n};\n\n/**\n * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.\n * @method pointIsInside\n * @param  {Vec3} p      A point given in local coordinates\n * @return {Boolean}\n */\nvar ConvexPolyhedron_pointIsInside = new Vec3();\nvar ConvexPolyhedron_vToP = new Vec3();\nvar ConvexPolyhedron_vToPointInside = new Vec3();\nConvexPolyhedron.prototype.pointIsInside = function(p){\n    var n = this.vertices.length,\n        verts = this.vertices,\n        faces = this.faces,\n        normals = this.faceNormals;\n    var positiveResult = null;\n    var N = this.faces.length;\n    var pointInside = ConvexPolyhedron_pointIsInside;\n    this.getAveragePointLocal(pointInside);\n    for(var i=0; i<N; i++){\n        var numVertices = this.faces[i].length;\n        var n = normals[i];\n        var v = verts[faces[i][0]]; // We only need one point in the face\n\n        // This dot product determines which side of the edge the point is\n        var vToP = ConvexPolyhedron_vToP;\n        p.vsub(v,vToP);\n        var r1 = n.dot(vToP);\n\n        var vToPointInside = ConvexPolyhedron_vToPointInside;\n        pointInside.vsub(v,vToPointInside);\n        var r2 = n.dot(vToPointInside);\n\n        if((r1<0 && r2>0) || (r1>0 && r2<0)){\n            return false; // Encountered some other sign. Exit.\n        } else {\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return positiveResult ? 1 : -1;\n};\n\n/**\n * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.\n * @static\n * @method project\n * @param {ConvexPolyhedron} hull\n * @param {Vec3} axis\n * @param {Vec3} pos\n * @param {Quaternion} quat\n * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.\n */\nvar project_worldVertex = new Vec3();\nvar project_localAxis = new Vec3();\nvar project_localOrigin = new Vec3();\nConvexPolyhedron.project = function(hull, axis, pos, quat, result){\n    var n = hull.vertices.length,\n        worldVertex = project_worldVertex,\n        localAxis = project_localAxis,\n        max = 0,\n        min = 0,\n        localOrigin = project_localOrigin,\n        vs = hull.vertices;\n\n    localOrigin.setZero();\n\n    // Transform the axis to local\n    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);\n    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);\n    var add = localOrigin.dot(localAxis);\n\n    min = max = vs[0].dot(localAxis);\n\n    for(var i = 1; i < n; i++){\n        var val = vs[i].dot(localAxis);\n\n        if(val > max){\n            max = val;\n        }\n\n        if(val < min){\n            min = val;\n        }\n    }\n\n    min -= add;\n    max -= add;\n\n    if(min > max){\n        // Inconsistent - swap\n        var temp = min;\n        min = max;\n        max = temp;\n    }\n    // Output\n    result[0] = max;\n    result[1] = min;\n};\n"]},"metadata":{},"sourceType":"script"}