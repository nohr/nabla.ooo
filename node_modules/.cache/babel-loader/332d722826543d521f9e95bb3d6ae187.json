{"ast":null,"code":"module.exports = FrictionEquation;\n\nvar Equation = require('./Equation');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Mat3 = require('../math/Mat3');\n/**\n * Constrains the slipping in a contact along a tangent\n * @class FrictionEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g\n * @extends Equation\n */\n\n\nfunction FrictionEquation(bodyA, bodyB, slipForce) {\n  Equation.call(this, bodyA, bodyB, -slipForce, slipForce);\n  this.ri = new Vec3();\n  this.rj = new Vec3();\n  this.t = new Vec3(); // tangent\n}\n\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\nvar FrictionEquation_computeB_temp1 = new Vec3();\nvar FrictionEquation_computeB_temp2 = new Vec3();\n\nFrictionEquation.prototype.computeB = function (h) {\n  var a = this.a,\n      b = this.b,\n      bi = this.bi,\n      bj = this.bj,\n      ri = this.ri,\n      rj = this.rj,\n      rixt = FrictionEquation_computeB_temp1,\n      rjxt = FrictionEquation_computeB_temp2,\n      t = this.t; // Caluclate cross products\n\n  ri.cross(t, rixt);\n  rj.cross(t, rjxt); // G = [-t -rixt t rjxt]\n  // And remember, this is a pure velocity constraint, g is always zero!\n\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB;\n  t.negate(GA.spatial);\n  rixt.negate(GA.rotational);\n  GB.spatial.copy(t);\n  GB.rotational.copy(rjxt);\n  var GW = this.computeGW();\n  var GiMf = this.computeGiMf();\n  var B = -GW * b - h * GiMf;\n  return B;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/FrictionEquation.js"],"names":["module","exports","FrictionEquation","Equation","require","Vec3","Mat3","bodyA","bodyB","slipForce","call","ri","rj","t","prototype","constructor","FrictionEquation_computeB_temp1","FrictionEquation_computeB_temp2","computeB","h","a","b","bi","bj","rixt","rjxt","cross","GA","jacobianElementA","GB","jacobianElementB","negate","spatial","rotational","copy","GW","computeGW","GiMf","computeGiMf","B"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,gBAAjB;;AAEA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,cAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,gBAAT,CAA0BK,KAA1B,EAAiCC,KAAjC,EAAwCC,SAAxC,EAAkD;AAC9CN,EAAAA,QAAQ,CAACO,IAAT,CAAc,IAAd,EAAmBH,KAAnB,EAA0BC,KAA1B,EAAiC,CAACC,SAAlC,EAA6CA,SAA7C;AACA,OAAKE,EAAL,GAAU,IAAIN,IAAJ,EAAV;AACA,OAAKO,EAAL,GAAU,IAAIP,IAAJ,EAAV;AACA,OAAKQ,CAAL,GAAS,IAAIR,IAAJ,EAAT,CAJ8C,CAIzB;AACxB;;AAEDH,gBAAgB,CAACY,SAAjB,GAA6B,IAAIX,QAAJ,EAA7B;AACAD,gBAAgB,CAACY,SAAjB,CAA2BC,WAA3B,GAAyCb,gBAAzC;AAEA,IAAIc,+BAA+B,GAAG,IAAIX,IAAJ,EAAtC;AACA,IAAIY,+BAA+B,GAAG,IAAIZ,IAAJ,EAAtC;;AACAH,gBAAgB,CAACY,SAAjB,CAA2BI,QAA3B,GAAsC,UAASC,CAAT,EAAW;AAC7C,MAAIC,CAAC,GAAG,KAAKA,CAAb;AAAA,MACIC,CAAC,GAAG,KAAKA,CADb;AAAA,MAEIC,EAAE,GAAG,KAAKA,EAFd;AAAA,MAGIC,EAAE,GAAG,KAAKA,EAHd;AAAA,MAIIZ,EAAE,GAAG,KAAKA,EAJd;AAAA,MAKIC,EAAE,GAAG,KAAKA,EALd;AAAA,MAMIY,IAAI,GAAGR,+BANX;AAAA,MAOIS,IAAI,GAAGR,+BAPX;AAAA,MAQIJ,CAAC,GAAG,KAAKA,CARb,CAD6C,CAW7C;;AACAF,EAAAA,EAAE,CAACe,KAAH,CAASb,CAAT,EAAWW,IAAX;AACAZ,EAAAA,EAAE,CAACc,KAAH,CAASb,CAAT,EAAWY,IAAX,EAb6C,CAe7C;AACA;;AACA,MAAIE,EAAE,GAAG,KAAKC,gBAAd;AAAA,MACIC,EAAE,GAAG,KAAKC,gBADd;AAEAjB,EAAAA,CAAC,CAACkB,MAAF,CAASJ,EAAE,CAACK,OAAZ;AACAR,EAAAA,IAAI,CAACO,MAAL,CAAYJ,EAAE,CAACM,UAAf;AACAJ,EAAAA,EAAE,CAACG,OAAH,CAAWE,IAAX,CAAgBrB,CAAhB;AACAgB,EAAAA,EAAE,CAACI,UAAH,CAAcC,IAAd,CAAmBT,IAAnB;AAEA,MAAIU,EAAE,GAAG,KAAKC,SAAL,EAAT;AACA,MAAIC,IAAI,GAAG,KAAKC,WAAL,EAAX;AAEA,MAAIC,CAAC,GAAG,CAAEJ,EAAF,GAAOd,CAAP,GAAWF,CAAC,GAAGkB,IAAvB;AAEA,SAAOE,CAAP;AACH,CA9BD","sourcesContent":["module.exports = FrictionEquation;\n\nvar Equation = require('./Equation');\nvar Vec3 = require('../math/Vec3');\nvar Mat3 = require('../math/Mat3');\n\n/**\n * Constrains the slipping in a contact along a tangent\n * @class FrictionEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g\n * @extends Equation\n */\nfunction FrictionEquation(bodyA, bodyB, slipForce){\n    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);\n    this.ri = new Vec3();\n    this.rj = new Vec3();\n    this.t = new Vec3(); // tangent\n}\n\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\nvar FrictionEquation_computeB_temp1 = new Vec3();\nvar FrictionEquation_computeB_temp2 = new Vec3();\nFrictionEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixt = FrictionEquation_computeB_temp1,\n        rjxt = FrictionEquation_computeB_temp2,\n        t = this.t;\n\n    // Caluclate cross products\n    ri.cross(t,rixt);\n    rj.cross(t,rjxt);\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n    t.negate(GA.spatial);\n    rixt.negate(GA.rotational);\n    GB.spatial.copy(t);\n    GB.rotational.copy(rjxt);\n\n    var GW = this.computeGW();\n    var GiMf = this.computeGiMf();\n\n    var B = - GW * b - h * GiMf;\n\n    return B;\n};\n"]},"metadata":{},"sourceType":"script"}