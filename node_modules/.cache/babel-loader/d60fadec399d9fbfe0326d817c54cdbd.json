{"ast":null,"code":"module.exports = PointToPointConstraint;\n\nvar Constraint = require('./Constraint');\n\nvar ContactEquation = require('../equations/ContactEquation');\n\nvar Vec3 = require('../math/Vec3');\n/**\n * Connects two bodies at given offset points.\n * @class PointToPointConstraint\n * @extends Constraint\n * @constructor\n * @param {Body} bodyA\n * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.\n * @param {Vec3} pivotB See pivotA.\n * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.\n *\n * @example\n *     var bodyA = new Body({ mass: 1 });\n *     var bodyB = new Body({ mass: 1 });\n *     bodyA.position.set(-1, 0, 0);\n *     bodyB.position.set(1, 0, 0);\n *     bodyA.addShape(shapeA);\n *     bodyB.addShape(shapeB);\n *     world.addBody(bodyA);\n *     world.addBody(bodyB);\n *     var localPivotA = new Vec3(1, 0, 0);\n *     var localPivotB = new Vec3(-1, 0, 0);\n *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);\n *     world.addConstraint(constraint);\n */\n\n\nfunction PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {\n  Constraint.call(this, bodyA, bodyB);\n  maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;\n  /**\n   * Pivot, defined locally in bodyA.\n   * @property {Vec3} pivotA\n   */\n\n  this.pivotA = pivotA ? pivotA.clone() : new Vec3();\n  /**\n   * Pivot, defined locally in bodyB.\n   * @property {Vec3} pivotB\n   */\n\n  this.pivotB = pivotB ? pivotB.clone() : new Vec3();\n  /**\n   * @property {ContactEquation} equationX\n   */\n\n  var x = this.equationX = new ContactEquation(bodyA, bodyB);\n  /**\n   * @property {ContactEquation} equationY\n   */\n\n  var y = this.equationY = new ContactEquation(bodyA, bodyB);\n  /**\n   * @property {ContactEquation} equationZ\n   */\n\n  var z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver\n\n  this.equations.push(x, y, z); // Make the equations bidirectional\n\n  x.minForce = y.minForce = z.minForce = -maxForce;\n  x.maxForce = y.maxForce = z.maxForce = maxForce;\n  x.ni.set(1, 0, 0);\n  y.ni.set(0, 1, 0);\n  z.ni.set(0, 0, 1);\n}\n\nPointToPointConstraint.prototype = new Constraint();\n\nPointToPointConstraint.prototype.update = function () {\n  var bodyA = this.bodyA;\n  var bodyB = this.bodyB;\n  var x = this.equationX;\n  var y = this.equationY;\n  var z = this.equationZ; // Rotate the pivots to world space\n\n  bodyA.quaternion.vmult(this.pivotA, x.ri);\n  bodyB.quaternion.vmult(this.pivotB, x.rj);\n  y.ri.copy(x.ri);\n  y.rj.copy(x.rj);\n  z.ri.copy(x.ri);\n  z.rj.copy(x.rj);\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/constraints/PointToPointConstraint.js"],"names":["module","exports","PointToPointConstraint","Constraint","require","ContactEquation","Vec3","bodyA","pivotA","bodyB","pivotB","maxForce","call","clone","x","equationX","y","equationY","z","equationZ","equations","push","minForce","ni","set","prototype","update","quaternion","vmult","ri","rj","copy"],"mappings":"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","sourcesContent":["module.exports = PointToPointConstraint;\n\nvar Constraint = require('./Constraint');\nvar ContactEquation = require('../equations/ContactEquation');\nvar Vec3 = require('../math/Vec3');\n\n/**\n * Connects two bodies at given offset points.\n * @class PointToPointConstraint\n * @extends Constraint\n * @constructor\n * @param {Body} bodyA\n * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.\n * @param {Vec3} pivotB See pivotA.\n * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.\n *\n * @example\n *     var bodyA = new Body({ mass: 1 });\n *     var bodyB = new Body({ mass: 1 });\n *     bodyA.position.set(-1, 0, 0);\n *     bodyB.position.set(1, 0, 0);\n *     bodyA.addShape(shapeA);\n *     bodyB.addShape(shapeB);\n *     world.addBody(bodyA);\n *     world.addBody(bodyB);\n *     var localPivotA = new Vec3(1, 0, 0);\n *     var localPivotB = new Vec3(-1, 0, 0);\n *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);\n *     world.addConstraint(constraint);\n */\nfunction PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;\n\n    /**\n     * Pivot, defined locally in bodyA.\n     * @property {Vec3} pivotA\n     */\n    this.pivotA = pivotA ? pivotA.clone() : new Vec3();\n\n    /**\n     * Pivot, defined locally in bodyB.\n     * @property {Vec3} pivotB\n     */\n    this.pivotB = pivotB ? pivotB.clone() : new Vec3();\n\n    /**\n     * @property {ContactEquation} equationX\n     */\n    var x = this.equationX = new ContactEquation(bodyA,bodyB);\n\n    /**\n     * @property {ContactEquation} equationY\n     */\n    var y = this.equationY = new ContactEquation(bodyA,bodyB);\n\n    /**\n     * @property {ContactEquation} equationZ\n     */\n    var z = this.equationZ = new ContactEquation(bodyA,bodyB);\n\n    // Equations to be fed to the solver\n    this.equations.push(x, y, z);\n\n    // Make the equations bidirectional\n    x.minForce = y.minForce = z.minForce = -maxForce;\n    x.maxForce = y.maxForce = z.maxForce =  maxForce;\n\n    x.ni.set(1, 0, 0);\n    y.ni.set(0, 1, 0);\n    z.ni.set(0, 0, 1);\n}\nPointToPointConstraint.prototype = new Constraint();\n\nPointToPointConstraint.prototype.update = function(){\n    var bodyA = this.bodyA;\n    var bodyB = this.bodyB;\n    var x = this.equationX;\n    var y = this.equationY;\n    var z = this.equationZ;\n\n    // Rotate the pivots to world space\n    bodyA.quaternion.vmult(this.pivotA,x.ri);\n    bodyB.quaternion.vmult(this.pivotB,x.rj);\n\n    y.ri.copy(x.ri);\n    y.rj.copy(x.rj);\n    z.ri.copy(x.ri);\n    z.rj.copy(x.rj);\n};"]},"metadata":{},"sourceType":"script"}