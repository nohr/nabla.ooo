{"ast":null,"code":"module.exports = RotationalEquation;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Mat3 = require('../math/Mat3');\n\nvar Equation = require('./Equation');\n/**\n * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.\n * @class RotationalEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA]\n * @param {Vec3} [options.axisB]\n * @param {number} [options.maxForce]\n * @extends Equation\n */\n\n\nfunction RotationalEquation(bodyA, bodyB, options) {\n  options = options || {};\n  var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;\n  Equation.call(this, bodyA, bodyB, -maxForce, maxForce);\n  this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n  this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n  this.maxAngle = Math.PI / 2;\n}\n\nRotationalEquation.prototype = new Equation();\nRotationalEquation.prototype.constructor = RotationalEquation;\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nRotationalEquation.prototype.computeB = function (h) {\n  var a = this.a,\n      b = this.b,\n      ni = this.axisA,\n      nj = this.axisB,\n      nixnj = tmpVec1,\n      njxni = tmpVec2,\n      GA = this.jacobianElementA,\n      GB = this.jacobianElementB; // Caluclate cross products\n\n  ni.cross(nj, nixnj);\n  nj.cross(ni, njxni); // g = ni * nj\n  // gdot = (nj x ni) * wi + (ni x nj) * wj\n  // G = [0 njxni 0 nixnj]\n  // W = [vi wi vj wj]\n\n  GA.rotational.copy(njxni);\n  GB.rotational.copy(nixnj);\n  var g = Math.cos(this.maxAngle) - ni.dot(nj),\n      GW = this.computeGW(),\n      GiMf = this.computeGiMf();\n  var B = -g * a - GW * b - h * GiMf;\n  return B;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/RotationalEquation.js"],"names":["module","exports","RotationalEquation","Vec3","require","Mat3","Equation","bodyA","bodyB","options","maxForce","call","axisA","clone","axisB","maxAngle","Math","PI","prototype","constructor","tmpVec1","tmpVec2","computeB","h","a","b","ni","nj","nixnj","njxni","GA","jacobianElementA","GB","jacobianElementB","cross","rotational","copy","g","cos","dot","GW","computeGW","GiMf","computeGiMf","B"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,kBAAjB;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,kBAAT,CAA4BK,KAA5B,EAAmCC,KAAnC,EAA0CC,OAA1C,EAAkD;AAC9CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIC,QAAQ,GAAG,OAAOD,OAAO,CAACC,QAAf,KAA6B,WAA7B,GAA2CD,OAAO,CAACC,QAAnD,GAA8D,GAA7E;AAEAJ,EAAAA,QAAQ,CAACK,IAAT,CAAc,IAAd,EAAmBJ,KAAnB,EAAyBC,KAAzB,EAA+B,CAACE,QAAhC,EAA0CA,QAA1C;AAEA,OAAKE,KAAL,GAAaH,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAR,CAAcC,KAAd,EAAhB,GAAwC,IAAIV,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAArD;AACA,OAAKW,KAAL,GAAaL,OAAO,CAACK,KAAR,GAAgBL,OAAO,CAACK,KAAR,CAAcD,KAAd,EAAhB,GAAwC,IAAIV,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAArD;AAEA,OAAKY,QAAL,GAAgBC,IAAI,CAACC,EAAL,GAAU,CAA1B;AACH;;AAEDf,kBAAkB,CAACgB,SAAnB,GAA+B,IAAIZ,QAAJ,EAA/B;AACAJ,kBAAkB,CAACgB,SAAnB,CAA6BC,WAA7B,GAA2CjB,kBAA3C;AAEA,IAAIkB,OAAO,GAAG,IAAIjB,IAAJ,EAAd;AACA,IAAIkB,OAAO,GAAG,IAAIlB,IAAJ,EAAd;;AAEAD,kBAAkB,CAACgB,SAAnB,CAA6BI,QAA7B,GAAwC,UAASC,CAAT,EAAW;AAC/C,MAAIC,CAAC,GAAG,KAAKA,CAAb;AAAA,MACIC,CAAC,GAAG,KAAKA,CADb;AAAA,MAGIC,EAAE,GAAG,KAAKd,KAHd;AAAA,MAIIe,EAAE,GAAG,KAAKb,KAJd;AAAA,MAMIc,KAAK,GAAGR,OANZ;AAAA,MAOIS,KAAK,GAAGR,OAPZ;AAAA,MASIS,EAAE,GAAG,KAAKC,gBATd;AAAA,MAUIC,EAAE,GAAG,KAAKC,gBAVd,CAD+C,CAa/C;;AACAP,EAAAA,EAAE,CAACQ,KAAH,CAASP,EAAT,EAAaC,KAAb;AACAD,EAAAA,EAAE,CAACO,KAAH,CAASR,EAAT,EAAaG,KAAb,EAf+C,CAiB/C;AACA;AACA;AACA;;AACAC,EAAAA,EAAE,CAACK,UAAH,CAAcC,IAAd,CAAmBP,KAAnB;AACAG,EAAAA,EAAE,CAACG,UAAH,CAAcC,IAAd,CAAmBR,KAAnB;AAEA,MAAIS,CAAC,GAAGrB,IAAI,CAACsB,GAAL,CAAS,KAAKvB,QAAd,IAA0BW,EAAE,CAACa,GAAH,CAAOZ,EAAP,CAAlC;AAAA,MACIa,EAAE,GAAG,KAAKC,SAAL,EADT;AAAA,MAEIC,IAAI,GAAG,KAAKC,WAAL,EAFX;AAIA,MAAIC,CAAC,GAAG,CAAEP,CAAF,GAAMb,CAAN,GAAUgB,EAAE,GAAGf,CAAf,GAAmBF,CAAC,GAAGmB,IAA/B;AAEA,SAAOE,CAAP;AACH,CA/BD","sourcesContent":["module.exports = RotationalEquation;\n\nvar Vec3 = require('../math/Vec3');\nvar Mat3 = require('../math/Mat3');\nvar Equation = require('./Equation');\n\n/**\n * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.\n * @class RotationalEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA]\n * @param {Vec3} [options.axisB]\n * @param {number} [options.maxForce]\n * @extends Equation\n */\nfunction RotationalEquation(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);\n\n    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n\n    this.maxAngle = Math.PI / 2;\n}\n\nRotationalEquation.prototype = new Equation();\nRotationalEquation.prototype.constructor = RotationalEquation;\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nRotationalEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n\n        ni = this.axisA,\n        nj = this.axisB,\n\n        nixnj = tmpVec1,\n        njxni = tmpVec2,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // Caluclate cross products\n    ni.cross(nj, nixnj);\n    nj.cross(ni, njxni);\n\n    // g = ni * nj\n    // gdot = (nj x ni) * wi + (ni x nj) * wj\n    // G = [0 njxni 0 nixnj]\n    // W = [vi wi vj wj]\n    GA.rotational.copy(njxni);\n    GB.rotational.copy(nixnj);\n\n    var g = Math.cos(this.maxAngle) - ni.dot(nj),\n        GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h * GiMf;\n\n    return B;\n};\n\n"]},"metadata":{},"sourceType":"script"}