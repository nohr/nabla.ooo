{"ast":null,"code":"module.exports = LockConstraint;\n\nvar Constraint = require('./Constraint');\n\nvar PointToPointConstraint = require('./PointToPointConstraint');\n\nvar RotationalEquation = require('../equations/RotationalEquation');\n\nvar RotationalMotorEquation = require('../equations/RotationalMotorEquation');\n\nvar ContactEquation = require('../equations/ContactEquation');\n\nvar Vec3 = require('../math/Vec3');\n/**\n * Lock constraint. Will remove all degrees of freedom between the bodies.\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\n\n\nfunction LockConstraint(bodyA, bodyB, options) {\n  options = options || {};\n  var maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between\n\n  var pivotA = new Vec3();\n  var pivotB = new Vec3();\n  var halfWay = new Vec3();\n  bodyA.position.vadd(bodyB.position, halfWay);\n  halfWay.scale(0.5, halfWay);\n  bodyB.pointToLocalFrame(halfWay, pivotB);\n  bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies\n\n  PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces\n\n  this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);\n  this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);\n  this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);\n  this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);\n  this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);\n  this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place\n\n  /**\n   * @property {RotationalEquation} rotationalEquation1\n   */\n\n  var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);\n  /**\n   * @property {RotationalEquation} rotationalEquation2\n   */\n\n  var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);\n  /**\n   * @property {RotationalEquation} rotationalEquation3\n   */\n\n  var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);\n  this.equations.push(r1, r2, r3);\n}\n\nLockConstraint.prototype = new PointToPointConstraint();\nLockConstraint.constructor = LockConstraint;\nvar LockConstraint_update_tmpVec1 = new Vec3();\nvar LockConstraint_update_tmpVec2 = new Vec3();\n\nLockConstraint.prototype.update = function () {\n  var bodyA = this.bodyA,\n      bodyB = this.bodyB,\n      motor = this.motorEquation,\n      r1 = this.rotationalEquation1,\n      r2 = this.rotationalEquation2,\n      r3 = this.rotationalEquation3,\n      worldAxisA = LockConstraint_update_tmpVec1,\n      worldAxisB = LockConstraint_update_tmpVec2;\n  PointToPointConstraint.prototype.update.call(this); // These vector pairs must be orthogonal\n\n  bodyA.vectorToWorldFrame(this.xA, r1.axisA);\n  bodyB.vectorToWorldFrame(this.yB, r1.axisB);\n  bodyA.vectorToWorldFrame(this.yA, r2.axisA);\n  bodyB.vectorToWorldFrame(this.zB, r2.axisB);\n  bodyA.vectorToWorldFrame(this.zA, r3.axisA);\n  bodyB.vectorToWorldFrame(this.xB, r3.axisB);\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/constraints/LockConstraint.js"],"names":["module","exports","LockConstraint","Constraint","require","PointToPointConstraint","RotationalEquation","RotationalMotorEquation","ContactEquation","Vec3","bodyA","bodyB","options","maxForce","pivotA","pivotB","halfWay","position","vadd","scale","pointToLocalFrame","call","xA","vectorToLocalFrame","UNIT_X","xB","yA","UNIT_Y","yB","zA","UNIT_Z","zB","r1","rotationalEquation1","r2","rotationalEquation2","r3","rotationalEquation3","equations","push","prototype","constructor","LockConstraint_update_tmpVec1","LockConstraint_update_tmpVec2","update","motor","motorEquation","worldAxisA","worldAxisB","vectorToWorldFrame","axisA","axisB"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,cAAjB;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,0BAAD,CAApC;;AACA,IAAIE,kBAAkB,GAAGF,OAAO,CAAC,iCAAD,CAAhC;;AACA,IAAIG,uBAAuB,GAAGH,OAAO,CAAC,sCAAD,CAArC;;AACA,IAAII,eAAe,GAAGJ,OAAO,CAAC,8BAAD,CAA7B;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,cAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,cAAT,CAAwBQ,KAAxB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA8C;AAC1CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIC,QAAQ,GAAG,OAAOD,OAAO,CAACC,QAAf,KAA6B,WAA7B,GAA2CD,OAAO,CAACC,QAAnD,GAA8D,GAA7E,CAF0C,CAI1C;;AACA,MAAIC,MAAM,GAAG,IAAIL,IAAJ,EAAb;AACA,MAAIM,MAAM,GAAG,IAAIN,IAAJ,EAAb;AACA,MAAIO,OAAO,GAAG,IAAIP,IAAJ,EAAd;AACAC,EAAAA,KAAK,CAACO,QAAN,CAAeC,IAAf,CAAoBP,KAAK,CAACM,QAA1B,EAAoCD,OAApC;AACAA,EAAAA,OAAO,CAACG,KAAR,CAAc,GAAd,EAAmBH,OAAnB;AACAL,EAAAA,KAAK,CAACS,iBAAN,CAAwBJ,OAAxB,EAAiCD,MAAjC;AACAL,EAAAA,KAAK,CAACU,iBAAN,CAAwBJ,OAAxB,EAAiCF,MAAjC,EAX0C,CAa1C;;AACAT,EAAAA,sBAAsB,CAACgB,IAAvB,CAA4B,IAA5B,EAAkCX,KAAlC,EAAyCI,MAAzC,EAAiDH,KAAjD,EAAwDI,MAAxD,EAAgEF,QAAhE,EAd0C,CAgB1C;;AACA,OAAKS,EAAL,GAAUZ,KAAK,CAACa,kBAAN,CAAyBd,IAAI,CAACe,MAA9B,CAAV;AACA,OAAKC,EAAL,GAAUd,KAAK,CAACY,kBAAN,CAAyBd,IAAI,CAACe,MAA9B,CAAV;AACA,OAAKE,EAAL,GAAUhB,KAAK,CAACa,kBAAN,CAAyBd,IAAI,CAACkB,MAA9B,CAAV;AACA,OAAKC,EAAL,GAAUjB,KAAK,CAACY,kBAAN,CAAyBd,IAAI,CAACkB,MAA9B,CAAV;AACA,OAAKE,EAAL,GAAUnB,KAAK,CAACa,kBAAN,CAAyBd,IAAI,CAACqB,MAA9B,CAAV;AACA,OAAKC,EAAL,GAAUpB,KAAK,CAACY,kBAAN,CAAyBd,IAAI,CAACqB,MAA9B,CAAV,CAtB0C,CAwB1C;;AAEA;AACJ;AACA;;AACI,MAAIE,EAAE,GAAG,KAAKC,mBAAL,GAA2B,IAAI3B,kBAAJ,CAAuBI,KAAvB,EAA6BC,KAA7B,EAAmCC,OAAnC,CAApC;AAEA;AACJ;AACA;;AACI,MAAIsB,EAAE,GAAG,KAAKC,mBAAL,GAA2B,IAAI7B,kBAAJ,CAAuBI,KAAvB,EAA6BC,KAA7B,EAAmCC,OAAnC,CAApC;AAEA;AACJ;AACA;;AACI,MAAIwB,EAAE,GAAG,KAAKC,mBAAL,GAA2B,IAAI/B,kBAAJ,CAAuBI,KAAvB,EAA6BC,KAA7B,EAAmCC,OAAnC,CAApC;AAEA,OAAK0B,SAAL,CAAeC,IAAf,CAAoBP,EAApB,EAAwBE,EAAxB,EAA4BE,EAA5B;AACH;;AACDlC,cAAc,CAACsC,SAAf,GAA2B,IAAInC,sBAAJ,EAA3B;AACAH,cAAc,CAACuC,WAAf,GAA6BvC,cAA7B;AAEA,IAAIwC,6BAA6B,GAAG,IAAIjC,IAAJ,EAApC;AACA,IAAIkC,6BAA6B,GAAG,IAAIlC,IAAJ,EAApC;;AAEAP,cAAc,CAACsC,SAAf,CAAyBI,MAAzB,GAAkC,YAAU;AACxC,MAAIlC,KAAK,GAAG,KAAKA,KAAjB;AAAA,MACIC,KAAK,GAAG,KAAKA,KADjB;AAAA,MAEIkC,KAAK,GAAG,KAAKC,aAFjB;AAAA,MAGId,EAAE,GAAG,KAAKC,mBAHd;AAAA,MAIIC,EAAE,GAAG,KAAKC,mBAJd;AAAA,MAKIC,EAAE,GAAG,KAAKC,mBALd;AAAA,MAMIU,UAAU,GAAGL,6BANjB;AAAA,MAOIM,UAAU,GAAGL,6BAPjB;AASAtC,EAAAA,sBAAsB,CAACmC,SAAvB,CAAiCI,MAAjC,CAAwCvB,IAAxC,CAA6C,IAA7C,EAVwC,CAYxC;;AACAX,EAAAA,KAAK,CAACuC,kBAAN,CAAyB,KAAK3B,EAA9B,EAAkCU,EAAE,CAACkB,KAArC;AACAvC,EAAAA,KAAK,CAACsC,kBAAN,CAAyB,KAAKrB,EAA9B,EAAkCI,EAAE,CAACmB,KAArC;AAEAzC,EAAAA,KAAK,CAACuC,kBAAN,CAAyB,KAAKvB,EAA9B,EAAkCQ,EAAE,CAACgB,KAArC;AACAvC,EAAAA,KAAK,CAACsC,kBAAN,CAAyB,KAAKlB,EAA9B,EAAkCG,EAAE,CAACiB,KAArC;AAEAzC,EAAAA,KAAK,CAACuC,kBAAN,CAAyB,KAAKpB,EAA9B,EAAkCO,EAAE,CAACc,KAArC;AACAvC,EAAAA,KAAK,CAACsC,kBAAN,CAAyB,KAAKxB,EAA9B,EAAkCW,EAAE,CAACe,KAArC;AACH,CArBD","sourcesContent":["module.exports = LockConstraint;\n\nvar Constraint = require('./Constraint');\nvar PointToPointConstraint = require('./PointToPointConstraint');\nvar RotationalEquation = require('../equations/RotationalEquation');\nvar RotationalMotorEquation = require('../equations/RotationalMotorEquation');\nvar ContactEquation = require('../equations/ContactEquation');\nvar Vec3 = require('../math/Vec3');\n\n/**\n * Lock constraint. Will remove all degrees of freedom between the bodies.\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\nfunction LockConstraint(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    // Set pivot point in between\n    var pivotA = new Vec3();\n    var pivotB = new Vec3();\n    var halfWay = new Vec3();\n    bodyA.position.vadd(bodyB.position, halfWay);\n    halfWay.scale(0.5, halfWay);\n    bodyB.pointToLocalFrame(halfWay, pivotB);\n    bodyA.pointToLocalFrame(halfWay, pivotA);\n\n    // The point-to-point constraint will keep a point shared between the bodies\n    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n\n    // Store initial rotation of the bodies as unit vectors in the local body spaces\n    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);\n    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);\n    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);\n    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);\n    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);\n    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z);\n\n    // ...and the following rotational equations will keep all rotational DOF's in place\n\n    /**\n     * @property {RotationalEquation} rotationalEquation1\n     */\n    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation2\n     */\n    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation3\n     */\n    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);\n\n    this.equations.push(r1, r2, r3);\n}\nLockConstraint.prototype = new PointToPointConstraint();\nLockConstraint.constructor = LockConstraint;\n\nvar LockConstraint_update_tmpVec1 = new Vec3();\nvar LockConstraint_update_tmpVec2 = new Vec3();\n\nLockConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        motor = this.motorEquation,\n        r1 = this.rotationalEquation1,\n        r2 = this.rotationalEquation2,\n        r3 = this.rotationalEquation3,\n        worldAxisA = LockConstraint_update_tmpVec1,\n        worldAxisB = LockConstraint_update_tmpVec2;\n\n    PointToPointConstraint.prototype.update.call(this);\n\n    // These vector pairs must be orthogonal\n    bodyA.vectorToWorldFrame(this.xA, r1.axisA);\n    bodyB.vectorToWorldFrame(this.yB, r1.axisB);\n\n    bodyA.vectorToWorldFrame(this.yA, r2.axisA);\n    bodyB.vectorToWorldFrame(this.zB, r2.axisB);\n\n    bodyA.vectorToWorldFrame(this.zA, r3.axisA);\n    bodyB.vectorToWorldFrame(this.xB, r3.axisB);\n};\n\n"]},"metadata":{},"sourceType":"script"}