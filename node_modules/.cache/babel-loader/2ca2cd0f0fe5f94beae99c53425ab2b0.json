{"ast":null,"code":"module.exports = Narrowphase;\n\nvar AABB = require('../collision/AABB');\n\nvar Body = require('../objects/Body');\n\nvar Shape = require('../shapes/Shape');\n\nvar Ray = require('../collision/Ray');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Transform = require('../math/Transform');\n\nvar ConvexPolyhedron = require('../shapes/ConvexPolyhedron');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Solver = require('../solver/Solver');\n\nvar Vec3Pool = require('../utils/Vec3Pool');\n\nvar ContactEquation = require('../equations/ContactEquation');\n\nvar FrictionEquation = require('../equations/FrictionEquation');\n/**\n * Helper class for the World. Generates ContactEquations.\n * @class Narrowphase\n * @constructor\n * @todo Sphere-ConvexPolyhedron contacts\n * @todo Contact reduction\n * @todo  should move methods to prototype\n */\n\n\nfunction Narrowphase(world) {\n  /**\n   * Internal storage of pooled contact points.\n   * @property {Array} contactPointPool\n   */\n  this.contactPointPool = [];\n  this.frictionEquationPool = [];\n  this.result = [];\n  this.frictionResult = [];\n  /**\n   * Pooled vectors.\n   * @property {Vec3Pool} v3pool\n   */\n\n  this.v3pool = new Vec3Pool();\n  this.world = world;\n  this.currentContactMaterial = null;\n  /**\n   * @property {Boolean} enableFrictionReduction\n   */\n\n  this.enableFrictionReduction = false;\n}\n/**\n * Make a contact object, by using the internal pool or creating a new one.\n * @method createContactEquation\n * @param {Body} bi\n * @param {Body} bj\n * @param {Shape} si\n * @param {Shape} sj\n * @param {Shape} overrideShapeA\n * @param {Shape} overrideShapeB\n * @return {ContactEquation}\n */\n\n\nNarrowphase.prototype.createContactEquation = function (bi, bj, si, sj, overrideShapeA, overrideShapeB) {\n  var c;\n\n  if (this.contactPointPool.length) {\n    c = this.contactPointPool.pop();\n    c.bi = bi;\n    c.bj = bj;\n  } else {\n    c = new ContactEquation(bi, bj);\n  }\n\n  c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n  var cm = this.currentContactMaterial;\n  c.restitution = cm.restitution;\n  c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);\n  var matA = si.material || bi.material;\n  var matB = sj.material || bj.material;\n\n  if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {\n    c.restitution = matA.restitution * matB.restitution;\n  }\n\n  c.si = overrideShapeA || si;\n  c.sj = overrideShapeB || sj;\n  return c;\n};\n\nNarrowphase.prototype.createFrictionEquationsFromContact = function (contactEquation, outArray) {\n  var bodyA = contactEquation.bi;\n  var bodyB = contactEquation.bj;\n  var shapeA = contactEquation.si;\n  var shapeB = contactEquation.sj;\n  var world = this.world;\n  var cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them\n\n  var friction = cm.friction;\n  var matA = shapeA.material || bodyA.material;\n  var matB = shapeB.material || bodyB.material;\n\n  if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {\n    friction = matA.friction * matB.friction;\n  }\n\n  if (friction > 0) {\n    // Create 2 tangent equations\n    var mug = friction * world.gravity.length();\n    var reducedMass = bodyA.invMass + bodyB.invMass;\n\n    if (reducedMass > 0) {\n      reducedMass = 1 / reducedMass;\n    }\n\n    var pool = this.frictionEquationPool;\n    var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);\n    var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);\n    c1.bi = c2.bi = bodyA;\n    c1.bj = c2.bj = bodyB;\n    c1.minForce = c2.minForce = -mug * reducedMass;\n    c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors\n\n    c1.ri.copy(contactEquation.ri);\n    c1.rj.copy(contactEquation.rj);\n    c2.ri.copy(contactEquation.ri);\n    c2.rj.copy(contactEquation.rj); // Construct tangents\n\n    contactEquation.ni.tangents(c1.t, c2.t); // Set spook params\n\n    c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n    c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n    c1.enabled = c2.enabled = contactEquation.enabled;\n    outArray.push(c1, c2);\n    return true;\n  }\n\n  return false;\n};\n\nvar averageNormal = new Vec3();\nvar averageContactPointA = new Vec3();\nvar averageContactPointB = new Vec3(); // Take the average N latest contact point on the plane.\n\nNarrowphase.prototype.createFrictionFromAverage = function (numContacts) {\n  // The last contactEquation\n  var c = this.result[this.result.length - 1]; // Create the result: two \"average\" friction equations\n\n  if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {\n    return;\n  }\n\n  var f1 = this.frictionResult[this.frictionResult.length - 2];\n  var f2 = this.frictionResult[this.frictionResult.length - 1];\n  averageNormal.setZero();\n  averageContactPointA.setZero();\n  averageContactPointB.setZero();\n  var bodyA = c.bi;\n  var bodyB = c.bj;\n\n  for (var i = 0; i !== numContacts; i++) {\n    c = this.result[this.result.length - 1 - i];\n\n    if (c.bodyA !== bodyA) {\n      averageNormal.vadd(c.ni, averageNormal);\n      averageContactPointA.vadd(c.ri, averageContactPointA);\n      averageContactPointB.vadd(c.rj, averageContactPointB);\n    } else {\n      averageNormal.vsub(c.ni, averageNormal);\n      averageContactPointA.vadd(c.rj, averageContactPointA);\n      averageContactPointB.vadd(c.ri, averageContactPointB);\n    }\n  }\n\n  var invNumContacts = 1 / numContacts;\n  averageContactPointA.scale(invNumContacts, f1.ri);\n  averageContactPointB.scale(invNumContacts, f1.rj);\n  f2.ri.copy(f1.ri); // Should be the same\n\n  f2.rj.copy(f1.rj);\n  averageNormal.normalize();\n  averageNormal.tangents(f1.t, f2.t); // return eq;\n};\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpQuat1 = new Quaternion();\nvar tmpQuat2 = new Quaternion();\n/**\n * Generate all contacts between a list of body pairs\n * @method getContacts\n * @param {array} p1 Array of body indices\n * @param {array} p2 Array of body indices\n * @param {World} world\n * @param {array} result Array to store generated contacts\n * @param {array} oldcontacts Optional. Array of reusable contact objects\n */\n\nNarrowphase.prototype.getContacts = function (p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {\n  // Save old contact objects\n  this.contactPointPool = oldcontacts;\n  this.frictionEquationPool = frictionPool;\n  this.result = result;\n  this.frictionResult = frictionResult;\n  var qi = tmpQuat1;\n  var qj = tmpQuat2;\n  var xi = tmpVec1;\n  var xj = tmpVec2;\n\n  for (var k = 0, N = p1.length; k !== N; k++) {\n    // Get current collision bodies\n    var bi = p1[k],\n        bj = p2[k]; // Get contact material\n\n    var bodyContactMaterial = null;\n\n    if (bi.material && bj.material) {\n      bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;\n    }\n\n    var justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;\n\n    for (var i = 0; i < bi.shapes.length; i++) {\n      bi.quaternion.mult(bi.shapeOrientations[i], qi);\n      bi.quaternion.vmult(bi.shapeOffsets[i], xi);\n      xi.vadd(bi.position, xi);\n      var si = bi.shapes[i];\n\n      for (var j = 0; j < bj.shapes.length; j++) {\n        // Compute world transform of shapes\n        bj.quaternion.mult(bj.shapeOrientations[j], qj);\n        bj.quaternion.vmult(bj.shapeOffsets[j], xj);\n        xj.vadd(bj.position, xj);\n        var sj = bj.shapes[j];\n\n        if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {\n          continue;\n        }\n\n        if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {\n          continue;\n        } // Get collision material\n\n\n        var shapeContactMaterial = null;\n\n        if (si.material && sj.material) {\n          shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;\n        }\n\n        this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts\n\n        var resolver = this[si.type | sj.type];\n\n        if (resolver) {\n          var retval = false;\n\n          if (si.type < sj.type) {\n            retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n          } else {\n            retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);\n          }\n\n          if (retval && justTest) {\n            // Register overlap\n            world.shapeOverlapKeeper.set(si.id, sj.id);\n            world.bodyOverlapKeeper.set(bi.id, bj.id);\n          }\n        }\n      }\n    }\n  }\n};\n\nvar numWarnings = 0;\nvar maxWarnings = 10;\n\nfunction warn(msg) {\n  if (numWarnings > maxWarnings) {\n    return;\n  }\n\n  numWarnings++;\n  console.warn(msg);\n}\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.BOX] = Narrowphase.prototype.boxBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  si.convexPolyhedronRepresentation.material = si.material;\n  sj.convexPolyhedronRepresentation.material = sj.material;\n  si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n  sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n  return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  si.convexPolyhedronRepresentation.material = si.material;\n  si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n  return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  si.convexPolyhedronRepresentation.material = si.material;\n  si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n  return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n};\n/**\n * @method sphereSphere\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\n\nNarrowphase.prototype[Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  if (justTest) {\n    return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);\n  } // We will have only one contact in this case\n\n\n  var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal\n\n  xj.vsub(xi, r.ni);\n  r.ni.normalize(); // Contact point locations\n\n  r.ri.copy(r.ni);\n  r.rj.copy(r.ni);\n  r.ri.mult(si.radius, r.ri);\n  r.rj.mult(-sj.radius, r.rj);\n  r.ri.vadd(xi, r.ri);\n  r.ri.vsub(bi.position, r.ri);\n  r.rj.vadd(xj, r.rj);\n  r.rj.vsub(bj.position, r.rj);\n  this.result.push(r);\n  this.createFrictionEquationsFromContact(r, this.frictionResult);\n};\n/**\n * @method planeTrimesh\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\n\nvar planeTrimesh_normal = new Vec3();\nvar planeTrimesh_relpos = new Vec3();\nvar planeTrimesh_projected = new Vec3();\n\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh = function (planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {\n  // Make contacts!\n  var v = new Vec3();\n  var normal = planeTrimesh_normal;\n  normal.set(0, 0, 1);\n  planeQuat.vmult(normal, normal); // Turn normal according to plane\n\n  for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {\n    // Get world vertex from trimesh\n    trimeshShape.getVertex(i, v); // Safe up\n\n    var v2 = new Vec3();\n    v2.copy(v);\n    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side\n\n    var relpos = planeTrimesh_relpos;\n    v.vsub(planePos, relpos);\n    var dot = normal.dot(relpos);\n\n    if (dot <= 0.0) {\n      if (justTest) {\n        return true;\n      }\n\n      var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);\n      r.ni.copy(normal); // Contact normal is the plane normal\n      // Get vertex position projected on plane\n\n      var projected = planeTrimesh_projected;\n      normal.scale(relpos.dot(normal), projected);\n      v.vsub(projected, projected); // ri is the projected world position minus plane position\n\n      r.ri.copy(projected);\n      r.ri.vsub(planeBody.position, r.ri);\n      r.rj.copy(v);\n      r.rj.vsub(trimeshBody.position, r.rj); // Store result\n\n      this.result.push(r);\n      this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n  }\n};\n/**\n * @method sphereTrimesh\n * @param  {Shape}      sphereShape\n * @param  {Shape}      trimeshShape\n * @param  {Vec3}       spherePos\n * @param  {Vec3}       trimeshPos\n * @param  {Quaternion} sphereQuat\n * @param  {Quaternion} trimeshQuat\n * @param  {Body}       sphereBody\n * @param  {Body}       trimeshBody\n */\n\n\nvar sphereTrimesh_normal = new Vec3();\nvar sphereTrimesh_relpos = new Vec3();\nvar sphereTrimesh_projected = new Vec3();\nvar sphereTrimesh_v = new Vec3();\nvar sphereTrimesh_v2 = new Vec3();\nvar sphereTrimesh_edgeVertexA = new Vec3();\nvar sphereTrimesh_edgeVertexB = new Vec3();\nvar sphereTrimesh_edgeVector = new Vec3();\nvar sphereTrimesh_edgeVectorUnit = new Vec3();\nvar sphereTrimesh_localSpherePos = new Vec3();\nvar sphereTrimesh_tmp = new Vec3();\nvar sphereTrimesh_va = new Vec3();\nvar sphereTrimesh_vb = new Vec3();\nvar sphereTrimesh_vc = new Vec3();\nvar sphereTrimesh_localSphereAABB = new AABB();\nvar sphereTrimesh_triangles = [];\n\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh = function (sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {\n  var edgeVertexA = sphereTrimesh_edgeVertexA;\n  var edgeVertexB = sphereTrimesh_edgeVertexB;\n  var edgeVector = sphereTrimesh_edgeVector;\n  var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;\n  var localSpherePos = sphereTrimesh_localSpherePos;\n  var tmp = sphereTrimesh_tmp;\n  var localSphereAABB = sphereTrimesh_localSphereAABB;\n  var v2 = sphereTrimesh_v2;\n  var relpos = sphereTrimesh_relpos;\n  var triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh\n\n  Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh\n\n  var sphereRadius = sphereShape.radius;\n  localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);\n  localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);\n  trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All\n  // Vertices\n\n  var v = sphereTrimesh_v;\n  var radiusSquared = sphereShape.radius * sphereShape.radius;\n\n  for (var i = 0; i < triangles.length; i++) {\n    for (var j = 0; j < 3; j++) {\n      trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere\n\n      v.vsub(localSpherePos, relpos);\n\n      if (relpos.norm2() <= radiusSquared) {\n        // Safe up\n        v2.copy(v);\n        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);\n        v.vsub(spherePos, relpos);\n\n        if (justTest) {\n          return true;\n        }\n\n        var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);\n        r.ni.copy(relpos);\n        r.ni.normalize(); // ri is the vector from sphere center to the sphere surface\n\n        r.ri.copy(r.ni);\n        r.ri.scale(sphereShape.radius, r.ri);\n        r.ri.vadd(spherePos, r.ri);\n        r.ri.vsub(sphereBody.position, r.ri);\n        r.rj.copy(v);\n        r.rj.vsub(trimeshBody.position, r.rj); // Store result\n\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n      }\n    }\n  } // Check all edges\n\n\n  for (var i = 0; i < triangles.length; i++) {\n    for (var j = 0; j < 3; j++) {\n      trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);\n      trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);\n      edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge\n\n      localSpherePos.vsub(edgeVertexB, tmp);\n      var positionAlongEdgeB = tmp.dot(edgeVector);\n      localSpherePos.vsub(edgeVertexA, tmp);\n      var positionAlongEdgeA = tmp.dot(edgeVector);\n\n      if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {\n        // Now check the orthogonal distance from edge to sphere center\n        localSpherePos.vsub(edgeVertexA, tmp);\n        edgeVectorUnit.copy(edgeVector);\n        edgeVectorUnit.normalize();\n        positionAlongEdgeA = tmp.dot(edgeVectorUnit);\n        edgeVectorUnit.scale(positionAlongEdgeA, tmp);\n        tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame\n\n        var dist = tmp.distanceTo(localSpherePos);\n\n        if (dist < sphereShape.radius) {\n          if (justTest) {\n            return true;\n          }\n\n          var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);\n          tmp.vsub(localSpherePos, r.ni);\n          r.ni.normalize();\n          r.ni.scale(sphereShape.radius, r.ri);\n          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n          tmp.vsub(trimeshBody.position, r.rj);\n          Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n          Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n          this.result.push(r);\n          this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n      }\n    }\n  } // Triangle faces\n\n\n  var va = sphereTrimesh_va;\n  var vb = sphereTrimesh_vb;\n  var vc = sphereTrimesh_vc;\n  var normal = sphereTrimesh_normal;\n\n  for (var i = 0, N = triangles.length; i !== N; i++) {\n    trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);\n    trimeshShape.getNormal(triangles[i], normal);\n    localSpherePos.vsub(va, tmp);\n    var dist = tmp.dot(normal);\n    normal.scale(dist, tmp);\n    localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane\n\n    dist = tmp.distanceTo(localSpherePos);\n\n    if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {\n      if (justTest) {\n        return true;\n      }\n\n      var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);\n      tmp.vsub(localSpherePos, r.ni);\n      r.ni.normalize();\n      r.ni.scale(sphereShape.radius, r.ri);\n      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n      tmp.vsub(trimeshBody.position, r.rj);\n      Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n      Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n      this.result.push(r);\n      this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n  }\n\n  triangles.length = 0;\n};\n\nvar point_on_plane_to_sphere = new Vec3();\nvar plane_to_sphere_ortho = new Vec3();\n/**\n * @method spherePlane\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] = Narrowphase.prototype.spherePlane = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  // We will have one contact in this case\n  var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal\n\n  r.ni.set(0, 0, 1);\n  qj.vmult(r.ni, r.ni);\n  r.ni.negate(r.ni); // body i is the sphere, flip normal\n\n  r.ni.normalize(); // Needed?\n  // Vector from sphere center to contact point\n\n  r.ni.mult(si.radius, r.ri); // Project down sphere on plane\n\n  xi.vsub(xj, point_on_plane_to_sphere);\n  r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);\n  point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane\n\n  if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {\n    if (justTest) {\n      return true;\n    } // Make it relative to the body\n\n\n    var ri = r.ri;\n    var rj = r.rj;\n    ri.vadd(xi, ri);\n    ri.vsub(bi.position, ri);\n    rj.vadd(xj, rj);\n    rj.vsub(bj.position, rj);\n    this.result.push(r);\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n  }\n}; // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\n\n\nvar pointInPolygon_edge = new Vec3();\nvar pointInPolygon_edge_x_normal = new Vec3();\nvar pointInPolygon_vtp = new Vec3();\n\nfunction pointInPolygon(verts, normal, p) {\n  var positiveResult = null;\n  var N = verts.length;\n\n  for (var i = 0; i !== N; i++) {\n    var v = verts[i]; // Get edge to the next vertex\n\n    var edge = pointInPolygon_edge;\n    verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge\n\n    var edge_x_normal = pointInPolygon_edge_x_normal; //var edge_x_normal = new Vec3();\n\n    edge.cross(normal, edge_x_normal); // Get vector between point and current vertex\n\n    var vertex_to_p = pointInPolygon_vtp;\n    p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is\n\n    var r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.\n\n    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {\n      if (positiveResult === null) {\n        positiveResult = r > 0;\n      }\n\n      continue;\n    } else {\n      return false; // Encountered some other sign. Exit.\n    }\n  } // If we got here, all dot products were of the same sign.\n\n\n  return true;\n}\n\nvar box_to_sphere = new Vec3();\nvar sphereBox_ns = new Vec3();\nvar sphereBox_ns1 = new Vec3();\nvar sphereBox_ns2 = new Vec3();\nvar sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nvar sphereBox_sphere_to_corner = new Vec3();\nvar sphereBox_side_ns = new Vec3();\nvar sphereBox_side_ns1 = new Vec3();\nvar sphereBox_side_ns2 = new Vec3();\n/**\n * @method sphereBox\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] = Narrowphase.prototype.sphereBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  var v3pool = this.v3pool; // we refer to the box as body j\n\n  var sides = sphereBox_sides;\n  xi.vsub(xj, box_to_sphere);\n  sj.getSideNormals(sides, qj);\n  var R = si.radius;\n  var penetrating_sides = []; // Check side (plane) intersections\n\n  var found = false; // Store the resulting side penetration info\n\n  var side_ns = sphereBox_side_ns;\n  var side_ns1 = sphereBox_side_ns1;\n  var side_ns2 = sphereBox_side_ns2;\n  var side_h = null;\n  var side_penetrations = 0;\n  var side_dot1 = 0;\n  var side_dot2 = 0;\n  var side_distance = null;\n\n  for (var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {\n    // Get the plane side normal (ns)\n    var ns = sphereBox_ns;\n    ns.copy(sides[idx]);\n    var h = ns.norm();\n    ns.normalize(); // The normal/distance dot product tells which side of the plane we are\n\n    var dot = box_to_sphere.dot(ns);\n\n    if (dot < h + R && dot > 0) {\n      // Intersects plane. Now check the other two dimensions\n      var ns1 = sphereBox_ns1;\n      var ns2 = sphereBox_ns2;\n      ns1.copy(sides[(idx + 1) % 3]);\n      ns2.copy(sides[(idx + 2) % 3]);\n      var h1 = ns1.norm();\n      var h2 = ns2.norm();\n      ns1.normalize();\n      ns2.normalize();\n      var dot1 = box_to_sphere.dot(ns1);\n      var dot2 = box_to_sphere.dot(ns2);\n\n      if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {\n        var dist = Math.abs(dot - h - R);\n\n        if (side_distance === null || dist < side_distance) {\n          side_distance = dist;\n          side_dot1 = dot1;\n          side_dot2 = dot2;\n          side_h = h;\n          side_ns.copy(ns);\n          side_ns1.copy(ns1);\n          side_ns2.copy(ns2);\n          side_penetrations++;\n\n          if (justTest) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  if (side_penetrations) {\n    found = true;\n    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n    side_ns.mult(-R, r.ri); // Sphere r\n\n    r.ni.copy(side_ns);\n    r.ni.negate(r.ni); // Normal should be out of sphere\n\n    side_ns.mult(side_h, side_ns);\n    side_ns1.mult(side_dot1, side_ns1);\n    side_ns.vadd(side_ns1, side_ns);\n    side_ns2.mult(side_dot2, side_ns2);\n    side_ns.vadd(side_ns2, r.rj); // Make relative to bodies\n\n    r.ri.vadd(xi, r.ri);\n    r.ri.vsub(bi.position, r.ri);\n    r.rj.vadd(xj, r.rj);\n    r.rj.vsub(bj.position, r.rj);\n    this.result.push(r);\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n  } // Check corners\n\n\n  var rj = v3pool.get();\n  var sphere_to_corner = sphereBox_sphere_to_corner;\n\n  for (var j = 0; j !== 2 && !found; j++) {\n    for (var k = 0; k !== 2 && !found; k++) {\n      for (var l = 0; l !== 2 && !found; l++) {\n        rj.set(0, 0, 0);\n\n        if (j) {\n          rj.vadd(sides[0], rj);\n        } else {\n          rj.vsub(sides[0], rj);\n        }\n\n        if (k) {\n          rj.vadd(sides[1], rj);\n        } else {\n          rj.vsub(sides[1], rj);\n        }\n\n        if (l) {\n          rj.vadd(sides[2], rj);\n        } else {\n          rj.vsub(sides[2], rj);\n        } // World position of corner\n\n\n        xj.vadd(rj, sphere_to_corner);\n        sphere_to_corner.vsub(xi, sphere_to_corner);\n\n        if (sphere_to_corner.norm2() < R * R) {\n          if (justTest) {\n            return true;\n          }\n\n          found = true;\n          var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n          r.ri.copy(sphere_to_corner);\n          r.ri.normalize();\n          r.ni.copy(r.ri);\n          r.ri.mult(R, r.ri);\n          r.rj.copy(rj); // Make relative to bodies\n\n          r.ri.vadd(xi, r.ri);\n          r.ri.vsub(bi.position, r.ri);\n          r.rj.vadd(xj, r.rj);\n          r.rj.vsub(bj.position, r.rj);\n          this.result.push(r);\n          this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n      }\n    }\n  }\n\n  v3pool.release(rj);\n  rj = null; // Check edges\n\n  var edgeTangent = v3pool.get();\n  var edgeCenter = v3pool.get();\n  var r = v3pool.get(); // r = edge center to sphere center\n\n  var orthogonal = v3pool.get();\n  var dist = v3pool.get();\n  var Nsides = sides.length;\n\n  for (var j = 0; j !== Nsides && !found; j++) {\n    for (var k = 0; k !== Nsides && !found; k++) {\n      if (j % 3 !== k % 3) {\n        // Get edge tangent\n        sides[k].cross(sides[j], edgeTangent);\n        edgeTangent.normalize();\n        sides[j].vadd(sides[k], edgeCenter);\n        r.copy(xi);\n        r.vsub(edgeCenter, r);\n        r.vsub(xj, r);\n        var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction\n\n        edgeTangent.mult(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction\n        // Find the third side orthogonal to this one\n\n        var l = 0;\n\n        while (l === j % 3 || l === k % 3) {\n          l++;\n        } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent\n\n\n        dist.copy(xi);\n        dist.vsub(orthogonal, dist);\n        dist.vsub(edgeCenter, dist);\n        dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it\n\n        var tdist = Math.abs(orthonorm);\n        var ndist = dist.norm();\n\n        if (tdist < sides[l].norm() && ndist < R) {\n          if (justTest) {\n            return true;\n          }\n\n          found = true;\n          var res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n          edgeCenter.vadd(orthogonal, res.rj); // box rj\n\n          res.rj.copy(res.rj);\n          dist.negate(res.ni);\n          res.ni.normalize();\n          res.ri.copy(res.rj);\n          res.ri.vadd(xj, res.ri);\n          res.ri.vsub(xi, res.ri);\n          res.ri.normalize();\n          res.ri.mult(R, res.ri); // Make relative to bodies\n\n          res.ri.vadd(xi, res.ri);\n          res.ri.vsub(bi.position, res.ri);\n          res.rj.vadd(xj, res.rj);\n          res.rj.vsub(bj.position, res.rj);\n          this.result.push(res);\n          this.createFrictionEquationsFromContact(res, this.frictionResult);\n        }\n      }\n    }\n  }\n\n  v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);\n};\n\nvar convex_to_sphere = new Vec3();\nvar sphereConvex_edge = new Vec3();\nvar sphereConvex_edgeUnit = new Vec3();\nvar sphereConvex_sphereToCorner = new Vec3();\nvar sphereConvex_worldCorner = new Vec3();\nvar sphereConvex_worldNormal = new Vec3();\nvar sphereConvex_worldPoint = new Vec3();\nvar sphereConvex_worldSpherePointClosestToPlane = new Vec3();\nvar sphereConvex_penetrationVec = new Vec3();\nvar sphereConvex_sphereToWorldPoint = new Vec3();\n/**\n * @method sphereConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  var v3pool = this.v3pool;\n  xi.vsub(xj, convex_to_sphere);\n  var normals = sj.faceNormals;\n  var faces = sj.faces;\n  var verts = sj.vertices;\n  var R = si.radius;\n  var penetrating_sides = []; // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){\n  //     return;\n  // }\n  // Check corners\n\n  for (var i = 0; i !== verts.length; i++) {\n    var v = verts[i]; // World position of corner\n\n    var worldCorner = sphereConvex_worldCorner;\n    qj.vmult(v, worldCorner);\n    xj.vadd(worldCorner, worldCorner);\n    var sphere_to_corner = sphereConvex_sphereToCorner;\n    worldCorner.vsub(xi, sphere_to_corner);\n\n    if (sphere_to_corner.norm2() < R * R) {\n      if (justTest) {\n        return true;\n      }\n\n      found = true;\n      var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n      r.ri.copy(sphere_to_corner);\n      r.ri.normalize();\n      r.ni.copy(r.ri);\n      r.ri.mult(R, r.ri);\n      worldCorner.vsub(xj, r.rj); // Should be relative to the body.\n\n      r.ri.vadd(xi, r.ri);\n      r.ri.vsub(bi.position, r.ri); // Should be relative to the body.\n\n      r.rj.vadd(xj, r.rj);\n      r.rj.vsub(bj.position, r.rj);\n      this.result.push(r);\n      this.createFrictionEquationsFromContact(r, this.frictionResult);\n      return;\n    }\n  } // Check side (plane) intersections\n\n\n  var found = false;\n\n  for (var i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {\n    var normal = normals[i];\n    var face = faces[i]; // Get world-transformed normal of the face\n\n    var worldNormal = sphereConvex_worldNormal;\n    qj.vmult(normal, worldNormal); // Get a world vertex from the face\n\n    var worldPoint = sphereConvex_worldPoint;\n    qj.vmult(verts[face[0]], worldPoint);\n    worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal\n\n    var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;\n    worldNormal.mult(-R, worldSpherePointClosestToPlane);\n    xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere\n\n    var penetrationVec = sphereConvex_penetrationVec;\n    worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.\n\n    var penetration = penetrationVec.dot(worldNormal);\n    var worldPointToSphere = sphereConvex_sphereToWorldPoint;\n    xi.vsub(worldPoint, worldPointToSphere);\n\n    if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {\n      // Intersects plane. Now check if the sphere is inside the face polygon\n      var faceVerts = []; // Face vertices, in world coords\n\n      for (var j = 0, Nverts = face.length; j !== Nverts; j++) {\n        var worldVertex = v3pool.get();\n        qj.vmult(verts[face[j]], worldVertex);\n        xj.vadd(worldVertex, worldVertex);\n        faceVerts.push(worldVertex);\n      }\n\n      if (pointInPolygon(faceVerts, worldNormal, xi)) {\n        // Is the sphere center in the face polygon?\n        if (justTest) {\n          return true;\n        }\n\n        found = true;\n        var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n        worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact\n\n        worldNormal.negate(r.ni); // Normal pointing out of sphere\n\n        var penetrationVec2 = v3pool.get();\n        worldNormal.mult(-penetration, penetrationVec2);\n        var penetrationSpherePoint = v3pool.get();\n        worldNormal.mult(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);\n\n        xi.vsub(xj, r.rj);\n        r.rj.vadd(penetrationSpherePoint, r.rj);\n        r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.\n\n        r.rj.vadd(xj, r.rj);\n        r.rj.vsub(bj.position, r.rj); // Should be relative to the body.\n\n        r.ri.vadd(xi, r.ri);\n        r.ri.vsub(bi.position, r.ri);\n        v3pool.release(penetrationVec2);\n        v3pool.release(penetrationSpherePoint);\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices\n\n        for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {\n          v3pool.release(faceVerts[j]);\n        }\n\n        return; // We only expect *one* face contact\n      } else {\n        // Edge?\n        for (var j = 0; j !== face.length; j++) {\n          // Get two world transformed vertices\n          var v1 = v3pool.get();\n          var v2 = v3pool.get();\n          qj.vmult(verts[face[(j + 1) % face.length]], v1);\n          qj.vmult(verts[face[(j + 2) % face.length]], v2);\n          xj.vadd(v1, v1);\n          xj.vadd(v2, v2); // Construct edge vector\n\n          var edge = sphereConvex_edge;\n          v2.vsub(v1, edge); // Construct the same vector, but normalized\n\n          var edgeUnit = sphereConvex_edgeUnit;\n          edge.unit(edgeUnit); // p is xi projected onto the edge\n\n          var p = v3pool.get();\n          var v1_to_xi = v3pool.get();\n          xi.vsub(v1, v1_to_xi);\n          var dot = v1_to_xi.dot(edgeUnit);\n          edgeUnit.mult(dot, p);\n          p.vadd(v1, p); // Compute a vector from p to the center of the sphere\n\n          var xi_to_p = v3pool.get();\n          p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius\n          // AND if p is in between v1 and v2\n\n          if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) {\n            // Collision if the edge-sphere distance is less than the radius\n            // Edge contact!\n            if (justTest) {\n              return true;\n            }\n\n            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n            p.vsub(xj, r.rj);\n            p.vsub(xi, r.ni);\n            r.ni.normalize();\n            r.ni.mult(R, r.ri); // Should be relative to the body.\n\n            r.rj.vadd(xj, r.rj);\n            r.rj.vsub(bj.position, r.rj); // Should be relative to the body.\n\n            r.ri.vadd(xi, r.ri);\n            r.ri.vsub(bi.position, r.ri);\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices\n\n            for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {\n              v3pool.release(faceVerts[j]);\n            }\n\n            v3pool.release(v1);\n            v3pool.release(v2);\n            v3pool.release(p);\n            v3pool.release(xi_to_p);\n            v3pool.release(v1_to_xi);\n            return;\n          }\n\n          v3pool.release(v1);\n          v3pool.release(v2);\n          v3pool.release(p);\n          v3pool.release(xi_to_p);\n          v3pool.release(v1_to_xi);\n        }\n      } // Release world vertices\n\n\n      for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {\n        v3pool.release(faceVerts[j]);\n      }\n    }\n  }\n};\n\nvar planeBox_normal = new Vec3();\nvar plane_to_corner = new Vec3();\n/**\n * @method planeBox\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] = Narrowphase.prototype.planeBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  sj.convexPolyhedronRepresentation.material = sj.material;\n  sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n  sj.convexPolyhedronRepresentation.id = sj.id;\n  return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n};\n\nvar planeConvex_v = new Vec3();\nvar planeConvex_normal = new Vec3();\nvar planeConvex_relpos = new Vec3();\nvar planeConvex_projected = new Vec3();\n/**\n * @method planeConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex = function (planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {\n  // Simply return the points behind the plane.\n  var worldVertex = planeConvex_v,\n      worldNormal = planeConvex_normal;\n  worldNormal.set(0, 0, 1);\n  planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation\n\n  var numContacts = 0;\n  var relpos = planeConvex_relpos;\n\n  for (var i = 0; i !== convexShape.vertices.length; i++) {\n    // Get world convex vertex\n    worldVertex.copy(convexShape.vertices[i]);\n    convexQuat.vmult(worldVertex, worldVertex);\n    convexPosition.vadd(worldVertex, worldVertex);\n    worldVertex.vsub(planePosition, relpos);\n    var dot = worldNormal.dot(relpos);\n\n    if (dot <= 0.0) {\n      if (justTest) {\n        return true;\n      }\n\n      var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane\n\n      var projected = planeConvex_projected;\n      worldNormal.mult(worldNormal.dot(relpos), projected);\n      worldVertex.vsub(projected, projected);\n      projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane\n\n      r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane\n      // rj is now just the vector from the convex center to the vertex\n\n      worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body\n\n      r.ri.vadd(planePosition, r.ri);\n      r.ri.vsub(planeBody.position, r.ri);\n      r.rj.vadd(convexPosition, r.rj);\n      r.rj.vsub(convexBody.position, r.rj);\n      this.result.push(r);\n      numContacts++;\n\n      if (!this.enableFrictionReduction) {\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n      }\n    }\n  }\n\n  if (this.enableFrictionReduction && numContacts) {\n    this.createFrictionFromAverage(numContacts);\n  }\n};\n\nvar convexConvex_sepAxis = new Vec3();\nvar convexConvex_q = new Vec3();\n/**\n * @method convexConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {\n  var sepAxis = convexConvex_sepAxis;\n\n  if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {\n    return;\n  }\n\n  if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {\n    var res = [];\n    var q = convexConvex_q;\n    si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);\n    var numContacts = 0;\n\n    for (var j = 0; j !== res.length; j++) {\n      if (justTest) {\n        return true;\n      }\n\n      var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj),\n          ri = r.ri,\n          rj = r.rj;\n      sepAxis.negate(r.ni);\n      res[j].normal.negate(q);\n      q.mult(res[j].depth, q);\n      res[j].point.vadd(q, ri);\n      rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative\n\n      ri.vsub(xi, ri);\n      rj.vsub(xj, rj); // Make relative to bodies\n\n      ri.vadd(xi, ri);\n      ri.vsub(bi.position, ri);\n      rj.vadd(xj, rj);\n      rj.vsub(bj.position, rj);\n      this.result.push(r);\n      numContacts++;\n\n      if (!this.enableFrictionReduction) {\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n      }\n    }\n\n    if (this.enableFrictionReduction && numContacts) {\n      this.createFrictionFromAverage(numContacts);\n    }\n  }\n};\n/**\n * @method convexTrimesh\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =\n// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){\n//     var sepAxis = convexConvex_sepAxis;\n//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n//         return;\n//     }\n//     // Construct a temp hull for each triangle\n//     var hullB = new ConvexPolyhedron();\n//     hullB.faces = [[0,1,2]];\n//     var va = new Vec3();\n//     var vb = new Vec3();\n//     var vc = new Vec3();\n//     hullB.vertices = [\n//         va,\n//         vb,\n//         vc\n//     ];\n//     for (var i = 0; i < sj.indices.length / 3; i++) {\n//         var triangleNormal = new Vec3();\n//         sj.getNormal(i, triangleNormal);\n//         hullB.faceNormals = [triangleNormal];\n//         sj.getTriangleVertices(i, va, vb, vc);\n//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n//         if(!d){\n//             triangleNormal.scale(-1, triangleNormal);\n//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n//             if(!d){\n//                 continue;\n//             }\n//         }\n//         var res = [];\n//         var q = convexConvex_q;\n//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);\n//         for(var j = 0; j !== res.length; j++){\n//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),\n//                 ri = r.ri,\n//                 rj = r.rj;\n//             r.ni.copy(triangleNormal);\n//             r.ni.negate(r.ni);\n//             res[j].normal.negate(q);\n//             q.mult(res[j].depth, q);\n//             res[j].point.vadd(q, ri);\n//             rj.copy(res[j].point);\n//             // Contact points are in world coordinates. Transform back to relative\n//             ri.vsub(xi,ri);\n//             rj.vsub(xj,rj);\n//             // Make relative to bodies\n//             ri.vadd(xi, ri);\n//             ri.vsub(bi.position, ri);\n//             rj.vadd(xj, rj);\n//             rj.vsub(bj.position, rj);\n//             result.push(r);\n//         }\n//     }\n// };\n\n\nvar particlePlane_normal = new Vec3();\nvar particlePlane_relpos = new Vec3();\nvar particlePlane_projected = new Vec3();\n/**\n * @method particlePlane\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {\n  var normal = particlePlane_normal;\n  normal.set(0, 0, 1);\n  bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation\n\n  var relpos = particlePlane_relpos;\n  xi.vsub(bj.position, relpos);\n  var dot = normal.dot(relpos);\n\n  if (dot <= 0.0) {\n    if (justTest) {\n      return true;\n    }\n\n    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n    r.ni.copy(normal); // Contact normal is the plane normal\n\n    r.ni.negate(r.ni);\n    r.ri.set(0, 0, 0); // Center of particle\n    // Get particle position projected on plane\n\n    var projected = particlePlane_projected;\n    normal.mult(normal.dot(xi), projected);\n    xi.vsub(projected, projected); //projected.vadd(bj.position,projected);\n    // rj is now the projected world position minus plane position\n\n    r.rj.copy(projected);\n    this.result.push(r);\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n  }\n};\n\nvar particleSphere_normal = new Vec3();\n/**\n * @method particleSphere\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {\n  // The normal is the unit vector from sphere center to particle center\n  var normal = particleSphere_normal;\n  normal.set(0, 0, 1);\n  xi.vsub(xj, normal);\n  var lengthSquared = normal.norm2();\n\n  if (lengthSquared <= sj.radius * sj.radius) {\n    if (justTest) {\n      return true;\n    }\n\n    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n    normal.normalize();\n    r.rj.copy(normal);\n    r.rj.mult(sj.radius, r.rj);\n    r.ni.copy(normal); // Contact normal\n\n    r.ni.negate(r.ni);\n    r.ri.set(0, 0, 0); // Center of particle\n\n    this.result.push(r);\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n  }\n}; // WIP\n\n\nvar cqj = new Quaternion();\nvar convexParticle_local = new Vec3();\nvar convexParticle_normal = new Vec3();\nvar convexParticle_penetratedFaceNormal = new Vec3();\nvar convexParticle_vertexToParticle = new Vec3();\nvar convexParticle_worldPenetrationVec = new Vec3();\n/**\n * @method convexParticle\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {\n  var penetratedFaceIndex = -1;\n  var penetratedFaceNormal = convexParticle_penetratedFaceNormal;\n  var worldPenetrationVec = convexParticle_worldPenetrationVec;\n  var minPenetration = null;\n  var numDetectedFaces = 0; // Convert particle position xi to local coords in the convex\n\n  var local = convexParticle_local;\n  local.copy(xi);\n  local.vsub(xj, local); // Convert position to relative the convex origin\n\n  qj.conjugate(cqj);\n  cqj.vmult(local, local);\n\n  if (sj.pointIsInside(local)) {\n    if (sj.worldVerticesNeedsUpdate) {\n      sj.computeWorldVertices(xj, qj);\n    }\n\n    if (sj.worldFaceNormalsNeedsUpdate) {\n      sj.computeWorldFaceNormals(qj);\n    } // For each world polygon in the polyhedra\n\n\n    for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {\n      // Construct world face vertices\n      var verts = [sj.worldVertices[sj.faces[i][0]]];\n      var normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.\n\n      xi.vsub(verts[0], convexParticle_vertexToParticle);\n      var penetration = -normal.dot(convexParticle_vertexToParticle);\n\n      if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {\n        if (justTest) {\n          return true;\n        }\n\n        minPenetration = penetration;\n        penetratedFaceIndex = i;\n        penetratedFaceNormal.copy(normal);\n        numDetectedFaces++;\n      }\n    }\n\n    if (penetratedFaceIndex !== -1) {\n      // Setup contact\n      var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);\n      penetratedFaceNormal.mult(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face\n\n      worldPenetrationVec.vadd(xi, worldPenetrationVec);\n      worldPenetrationVec.vsub(xj, worldPenetrationVec);\n      r.rj.copy(worldPenetrationVec); //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);\n      //projectedToFace.copy(r.rj);\n      //qj.vmult(r.rj,r.rj);\n\n      penetratedFaceNormal.negate(r.ni); // Contact normal\n\n      r.ri.set(0, 0, 0); // Center of particle\n\n      var ri = r.ri,\n          rj = r.rj; // Make relative to bodies\n\n      ri.vadd(xi, ri);\n      ri.vsub(bi.position, ri);\n      rj.vadd(xj, rj);\n      rj.vsub(bj.position, rj);\n      this.result.push(r);\n      this.createFrictionEquationsFromContact(r, this.frictionResult);\n    } else {\n      console.warn(\"Point found inside convex, but did not find penetrating face!\");\n    }\n  }\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n  si.convexPolyhedronRepresentation.material = si.material;\n  si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n  return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n};\n\nvar convexHeightfield_tmp1 = new Vec3();\nvar convexHeightfield_tmp2 = new Vec3();\nvar convexHeightfield_faceList = [0];\n/**\n * @method convexHeightfield\n */\n\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function (convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {\n  var data = hfShape.data,\n      w = hfShape.elementSize,\n      radius = convexShape.boundingSphereRadius,\n      worldPillarOffset = convexHeightfield_tmp2,\n      faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!\n\n  var localConvexPos = convexHeightfield_tmp1;\n  Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against\n\n  var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,\n      iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,\n      iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,\n      iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain\n\n  if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {\n    return;\n  } // Clamp index to edges\n\n\n  if (iMinX < 0) {\n    iMinX = 0;\n  }\n\n  if (iMaxX < 0) {\n    iMaxX = 0;\n  }\n\n  if (iMinY < 0) {\n    iMinY = 0;\n  }\n\n  if (iMaxY < 0) {\n    iMaxY = 0;\n  }\n\n  if (iMinX >= data.length) {\n    iMinX = data.length - 1;\n  }\n\n  if (iMaxX >= data.length) {\n    iMaxX = data.length - 1;\n  }\n\n  if (iMaxY >= data[0].length) {\n    iMaxY = data[0].length - 1;\n  }\n\n  if (iMinY >= data[0].length) {\n    iMinY = data[0].length - 1;\n  }\n\n  var minMax = [];\n  hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n  var min = minMax[0];\n  var max = minMax[1]; // Bail out if we're cant touch the bounding height box\n\n  if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {\n    return;\n  }\n\n  for (var i = iMinX; i < iMaxX; i++) {\n    for (var j = iMinY; j < iMaxY; j++) {\n      var intersecting = false; // Lower triangle\n\n      hfShape.getConvexTrianglePillar(i, j, false);\n      Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n\n      if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n        intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);\n      }\n\n      if (justTest && intersecting) {\n        return true;\n      } // Upper triangle\n\n\n      hfShape.getConvexTrianglePillar(i, j, true);\n      Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n\n      if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n        intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);\n      }\n\n      if (justTest && intersecting) {\n        return true;\n      }\n    }\n  }\n};\n\nvar sphereHeightfield_tmp1 = new Vec3();\nvar sphereHeightfield_tmp2 = new Vec3();\n/**\n * @method sphereHeightfield\n */\n\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield = function (sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {\n  var data = hfShape.data,\n      radius = sphereShape.radius,\n      w = hfShape.elementSize,\n      worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!\n\n  var localSpherePos = sphereHeightfield_tmp1;\n  Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against\n\n  var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,\n      iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,\n      iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,\n      iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain\n\n  if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length) {\n    return;\n  } // Clamp index to edges\n\n\n  if (iMinX < 0) {\n    iMinX = 0;\n  }\n\n  if (iMaxX < 0) {\n    iMaxX = 0;\n  }\n\n  if (iMinY < 0) {\n    iMinY = 0;\n  }\n\n  if (iMaxY < 0) {\n    iMaxY = 0;\n  }\n\n  if (iMinX >= data.length) {\n    iMinX = data.length - 1;\n  }\n\n  if (iMaxX >= data.length) {\n    iMaxX = data.length - 1;\n  }\n\n  if (iMaxY >= data[0].length) {\n    iMaxY = data[0].length - 1;\n  }\n\n  if (iMinY >= data[0].length) {\n    iMinY = data[0].length - 1;\n  }\n\n  var minMax = [];\n  hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n  var min = minMax[0];\n  var max = minMax[1]; // Bail out if we're cant touch the bounding height box\n\n  if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {\n    return;\n  }\n\n  var result = this.result;\n\n  for (var i = iMinX; i < iMaxX; i++) {\n    for (var j = iMinY; j < iMaxY; j++) {\n      var numContactsBefore = result.length;\n      var intersecting = false; // Lower triangle\n\n      hfShape.getConvexTrianglePillar(i, j, false);\n      Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n\n      if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n        intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);\n      }\n\n      if (justTest && intersecting) {\n        return true;\n      } // Upper triangle\n\n\n      hfShape.getConvexTrianglePillar(i, j, true);\n      Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n\n      if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n        intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);\n      }\n\n      if (justTest && intersecting) {\n        return true;\n      }\n\n      var numContacts = result.length - numContactsBefore;\n\n      if (numContacts > 2) {\n        return;\n      }\n      /*\n      // Skip all but 1\n      for (var k = 0; k < numContacts - 1; k++) {\n          result.pop();\n      }\n      */\n\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/world/Narrowphase.js"],"names":["module","exports","Narrowphase","AABB","require","Body","Shape","Ray","Vec3","Transform","ConvexPolyhedron","Quaternion","Solver","Vec3Pool","ContactEquation","FrictionEquation","world","contactPointPool","frictionEquationPool","result","frictionResult","v3pool","currentContactMaterial","enableFrictionReduction","prototype","createContactEquation","bi","bj","si","sj","overrideShapeA","overrideShapeB","c","length","pop","enabled","collisionResponse","cm","restitution","setSpookParams","contactEquationStiffness","contactEquationRelaxation","dt","matA","material","matB","createFrictionEquationsFromContact","contactEquation","outArray","bodyA","bodyB","shapeA","shapeB","friction","mug","gravity","reducedMass","invMass","pool","c1","c2","minForce","maxForce","ri","copy","rj","ni","tangents","t","frictionEquationStiffness","frictionEquationRelaxation","push","averageNormal","averageContactPointA","averageContactPointB","createFrictionFromAverage","numContacts","f1","f2","setZero","i","vadd","vsub","invNumContacts","scale","normalize","tmpVec1","tmpVec2","tmpQuat1","tmpQuat2","getContacts","p1","p2","oldcontacts","frictionPool","qi","qj","xi","xj","k","N","bodyContactMaterial","getContactMaterial","justTest","type","KINEMATIC","STATIC","shapes","quaternion","mult","shapeOrientations","vmult","shapeOffsets","position","j","collisionFilterMask","collisionFilterGroup","distanceTo","boundingSphereRadius","shapeContactMaterial","defaultContactMaterial","resolver","retval","call","shapeOverlapKeeper","set","id","bodyOverlapKeeper","numWarnings","maxWarnings","warn","msg","console","types","BOX","boxBox","rsi","rsj","convexPolyhedronRepresentation","convexConvex","CONVEXPOLYHEDRON","boxConvex","PARTICLE","boxParticle","convexParticle","SPHERE","sphereSphere","distanceSquared","Math","pow","radius","r","planeTrimesh_normal","planeTrimesh_relpos","planeTrimesh_projected","PLANE","TRIMESH","planeTrimesh","planeShape","trimeshShape","planePos","trimeshPos","planeQuat","trimeshQuat","planeBody","trimeshBody","v","normal","vertices","getVertex","v2","pointToWorldFrame","relpos","dot","projected","sphereTrimesh_normal","sphereTrimesh_relpos","sphereTrimesh_projected","sphereTrimesh_v","sphereTrimesh_v2","sphereTrimesh_edgeVertexA","sphereTrimesh_edgeVertexB","sphereTrimesh_edgeVector","sphereTrimesh_edgeVectorUnit","sphereTrimesh_localSpherePos","sphereTrimesh_tmp","sphereTrimesh_va","sphereTrimesh_vb","sphereTrimesh_vc","sphereTrimesh_localSphereAABB","sphereTrimesh_triangles","sphereTrimesh","sphereShape","spherePos","sphereQuat","sphereBody","edgeVertexA","edgeVertexB","edgeVector","edgeVectorUnit","localSpherePos","tmp","localSphereAABB","triangles","pointToLocalFrame","sphereRadius","lowerBound","x","y","z","upperBound","getTrianglesInAABB","radiusSquared","indices","norm2","positionAlongEdgeB","positionAlongEdgeA","dist","vectorToWorldFrame","va","vb","vc","getTriangleVertices","getNormal","pointInTriangle","point_on_plane_to_sphere","plane_to_sphere_ortho","spherePlane","negate","pointInPolygon_edge","pointInPolygon_edge_x_normal","pointInPolygon_vtp","pointInPolygon","verts","p","positiveResult","edge","edge_x_normal","cross","vertex_to_p","box_to_sphere","sphereBox_ns","sphereBox_ns1","sphereBox_ns2","sphereBox_sides","sphereBox_sphere_to_corner","sphereBox_side_ns","sphereBox_side_ns1","sphereBox_side_ns2","sphereBox","sides","getSideNormals","R","penetrating_sides","found","side_ns","side_ns1","side_ns2","side_h","side_penetrations","side_dot1","side_dot2","side_distance","idx","nsides","ns","h","norm","ns1","ns2","h1","h2","dot1","dot2","abs","get","sphere_to_corner","l","release","edgeTangent","edgeCenter","orthogonal","Nsides","orthonorm","tdist","ndist","res","convex_to_sphere","sphereConvex_edge","sphereConvex_edgeUnit","sphereConvex_sphereToCorner","sphereConvex_worldCorner","sphereConvex_worldNormal","sphereConvex_worldPoint","sphereConvex_worldSpherePointClosestToPlane","sphereConvex_penetrationVec","sphereConvex_sphereToWorldPoint","sphereConvex","normals","faceNormals","faces","worldCorner","nfaces","face","worldNormal","worldPoint","worldSpherePointClosestToPlane","penetrationVec","penetration","worldPointToSphere","faceVerts","Nverts","worldVertex","penetrationVec2","penetrationSpherePoint","Nfaceverts","v1","edgeUnit","unit","v1_to_xi","xi_to_p","planeBox_normal","plane_to_corner","planeBox","planeConvex","planeConvex_v","planeConvex_normal","planeConvex_relpos","planeConvex_projected","convexShape","planePosition","convexPosition","convexQuat","convexBody","convexConvex_sepAxis","convexConvex_q","faceListA","faceListB","sepAxis","findSeparatingAxis","q","clipAgainstHull","depth","point","particlePlane_normal","particlePlane_relpos","particlePlane_projected","planeParticle","particleSphere_normal","sphereParticle","lengthSquared","cqj","convexParticle_local","convexParticle_normal","convexParticle_penetratedFaceNormal","convexParticle_vertexToParticle","convexParticle_worldPenetrationVec","penetratedFaceIndex","penetratedFaceNormal","worldPenetrationVec","minPenetration","numDetectedFaces","local","conjugate","pointIsInside","worldVerticesNeedsUpdate","computeWorldVertices","worldFaceNormalsNeedsUpdate","computeWorldFaceNormals","worldVertices","worldFaceNormals","HEIGHTFIELD","boxHeightfield","convexHeightfield","convexHeightfield_tmp1","convexHeightfield_tmp2","convexHeightfield_faceList","hfShape","convexPos","hfPos","hfQuat","hfBody","data","w","elementSize","worldPillarOffset","faceList","localConvexPos","iMinX","floor","iMaxX","ceil","iMinY","iMaxY","minMax","getRectMinMax","min","max","intersecting","getConvexTrianglePillar","pillarOffset","pillarConvex","sphereHeightfield_tmp1","sphereHeightfield_tmp2","sphereHeightfield","numContactsBefore"],"mappings":"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","sourcesContent":["module.exports = Narrowphase;\n\nvar AABB = require('../collision/AABB');\nvar Body = require('../objects/Body');\nvar Shape = require('../shapes/Shape');\nvar Ray = require('../collision/Ray');\nvar Vec3 = require('../math/Vec3');\nvar Transform = require('../math/Transform');\nvar ConvexPolyhedron = require('../shapes/ConvexPolyhedron');\nvar Quaternion = require('../math/Quaternion');\nvar Solver = require('../solver/Solver');\nvar Vec3Pool = require('../utils/Vec3Pool');\nvar ContactEquation = require('../equations/ContactEquation');\nvar FrictionEquation = require('../equations/FrictionEquation');\n\n/**\n * Helper class for the World. Generates ContactEquations.\n * @class Narrowphase\n * @constructor\n * @todo Sphere-ConvexPolyhedron contacts\n * @todo Contact reduction\n * @todo  should move methods to prototype\n */\nfunction Narrowphase(world){\n\n    /**\n     * Internal storage of pooled contact points.\n     * @property {Array} contactPointPool\n     */\n    this.contactPointPool = [];\n\n    this.frictionEquationPool = [];\n\n    this.result = [];\n    this.frictionResult = [];\n\n    /**\n     * Pooled vectors.\n     * @property {Vec3Pool} v3pool\n     */\n    this.v3pool = new Vec3Pool();\n\n    this.world = world;\n    this.currentContactMaterial = null;\n\n    /**\n     * @property {Boolean} enableFrictionReduction\n     */\n    this.enableFrictionReduction = false;\n}\n\n/**\n * Make a contact object, by using the internal pool or creating a new one.\n * @method createContactEquation\n * @param {Body} bi\n * @param {Body} bj\n * @param {Shape} si\n * @param {Shape} sj\n * @param {Shape} overrideShapeA\n * @param {Shape} overrideShapeB\n * @return {ContactEquation}\n */\nNarrowphase.prototype.createContactEquation = function(bi, bj, si, sj, overrideShapeA, overrideShapeB){\n    var c;\n    if(this.contactPointPool.length){\n        c = this.contactPointPool.pop();\n        c.bi = bi;\n        c.bj = bj;\n    } else {\n        c = new ContactEquation(bi, bj);\n    }\n\n    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n    var cm = this.currentContactMaterial;\n\n    c.restitution = cm.restitution;\n\n    c.setSpookParams(\n        cm.contactEquationStiffness,\n        cm.contactEquationRelaxation,\n        this.world.dt\n    );\n\n    var matA = si.material || bi.material;\n    var matB = sj.material || bj.material;\n    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){\n        c.restitution = matA.restitution * matB.restitution;\n    }\n\n    c.si = overrideShapeA || si;\n    c.sj = overrideShapeB || sj;\n\n    return c;\n};\n\nNarrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){\n    var bodyA = contactEquation.bi;\n    var bodyB = contactEquation.bj;\n    var shapeA = contactEquation.si;\n    var shapeB = contactEquation.sj;\n\n    var world = this.world;\n    var cm = this.currentContactMaterial;\n\n    // If friction or restitution were specified in the material, use them\n    var friction = cm.friction;\n    var matA = shapeA.material || bodyA.material;\n    var matB = shapeB.material || bodyB.material;\n    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){\n        friction = matA.friction * matB.friction;\n    }\n\n    if(friction > 0){\n\n        // Create 2 tangent equations\n        var mug = friction * world.gravity.length();\n        var reducedMass = (bodyA.invMass + bodyB.invMass);\n        if(reducedMass > 0){\n            reducedMass = 1/reducedMass;\n        }\n        var pool = this.frictionEquationPool;\n        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);\n        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);\n\n        c1.bi = c2.bi = bodyA;\n        c1.bj = c2.bj = bodyB;\n        c1.minForce = c2.minForce = -mug*reducedMass;\n        c1.maxForce = c2.maxForce = mug*reducedMass;\n\n        // Copy over the relative vectors\n        c1.ri.copy(contactEquation.ri);\n        c1.rj.copy(contactEquation.rj);\n        c2.ri.copy(contactEquation.ri);\n        c2.rj.copy(contactEquation.rj);\n\n        // Construct tangents\n        contactEquation.ni.tangents(c1.t, c2.t);\n\n        // Set spook params\n        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n\n        c1.enabled = c2.enabled = contactEquation.enabled;\n\n        outArray.push(c1, c2);\n\n        return true;\n    }\n\n    return false;\n};\n\nvar averageNormal = new Vec3();\nvar averageContactPointA = new Vec3();\nvar averageContactPointB = new Vec3();\n\n// Take the average N latest contact point on the plane.\nNarrowphase.prototype.createFrictionFromAverage = function(numContacts){\n    // The last contactEquation\n    var c = this.result[this.result.length - 1];\n\n    // Create the result: two \"average\" friction equations\n    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {\n        return;\n    }\n\n    var f1 = this.frictionResult[this.frictionResult.length - 2];\n    var f2 = this.frictionResult[this.frictionResult.length - 1];\n\n    averageNormal.setZero();\n    averageContactPointA.setZero();\n    averageContactPointB.setZero();\n\n    var bodyA = c.bi;\n    var bodyB = c.bj;\n    for(var i=0; i!==numContacts; i++){\n        c = this.result[this.result.length - 1 - i];\n        if(c.bodyA !== bodyA){\n            averageNormal.vadd(c.ni, averageNormal);\n            averageContactPointA.vadd(c.ri, averageContactPointA);\n            averageContactPointB.vadd(c.rj, averageContactPointB);\n        } else {\n            averageNormal.vsub(c.ni, averageNormal);\n            averageContactPointA.vadd(c.rj, averageContactPointA);\n            averageContactPointB.vadd(c.ri, averageContactPointB);\n        }\n    }\n\n    var invNumContacts = 1 / numContacts;\n    averageContactPointA.scale(invNumContacts, f1.ri);\n    averageContactPointB.scale(invNumContacts, f1.rj);\n    f2.ri.copy(f1.ri); // Should be the same\n    f2.rj.copy(f1.rj);\n    averageNormal.normalize();\n    averageNormal.tangents(f1.t, f2.t);\n    // return eq;\n};\n\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpQuat1 = new Quaternion();\nvar tmpQuat2 = new Quaternion();\n\n/**\n * Generate all contacts between a list of body pairs\n * @method getContacts\n * @param {array} p1 Array of body indices\n * @param {array} p2 Array of body indices\n * @param {World} world\n * @param {array} result Array to store generated contacts\n * @param {array} oldcontacts Optional. Array of reusable contact objects\n */\nNarrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){\n    // Save old contact objects\n    this.contactPointPool = oldcontacts;\n    this.frictionEquationPool = frictionPool;\n    this.result = result;\n    this.frictionResult = frictionResult;\n\n    var qi = tmpQuat1;\n    var qj = tmpQuat2;\n    var xi = tmpVec1;\n    var xj = tmpVec2;\n\n    for(var k=0, N=p1.length; k!==N; k++){\n\n        // Get current collision bodies\n        var bi = p1[k],\n            bj = p2[k];\n\n        // Get contact material\n        var bodyContactMaterial = null;\n        if(bi.material && bj.material){\n            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;\n        }\n\n        var justTest = (\n            (\n                (bi.type & Body.KINEMATIC) && (bj.type & Body.STATIC)\n            ) || (\n                (bi.type & Body.STATIC) && (bj.type & Body.KINEMATIC)\n            ) || (\n                (bi.type & Body.KINEMATIC) && (bj.type & Body.KINEMATIC)\n            )\n        );\n\n        for (var i = 0; i < bi.shapes.length; i++) {\n            bi.quaternion.mult(bi.shapeOrientations[i], qi);\n            bi.quaternion.vmult(bi.shapeOffsets[i], xi);\n            xi.vadd(bi.position, xi);\n            var si = bi.shapes[i];\n\n            for (var j = 0; j < bj.shapes.length; j++) {\n\n                // Compute world transform of shapes\n                bj.quaternion.mult(bj.shapeOrientations[j], qj);\n                bj.quaternion.vmult(bj.shapeOffsets[j], xj);\n                xj.vadd(bj.position, xj);\n                var sj = bj.shapes[j];\n\n                if(!((si.collisionFilterMask & sj.collisionFilterGroup) && (sj.collisionFilterMask & si.collisionFilterGroup))){\n                    continue;\n                }\n\n                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n                    continue;\n                }\n\n                // Get collision material\n                var shapeContactMaterial = null;\n                if(si.material && sj.material){\n                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;\n                }\n\n                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;\n\n                // Get contacts\n                var resolver = this[si.type | sj.type];\n                if(resolver){\n                    var retval = false;\n                    if (si.type < sj.type) {\n                        retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);\n                    } else {\n                        retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);\n                    }\n\n                    if(retval && justTest){\n                        // Register overlap\n                        world.shapeOverlapKeeper.set(si.id, sj.id);\n                        world.bodyOverlapKeeper.set(bi.id, bj.id);\n                    }\n                }\n            }\n        }\n    }\n};\n\nvar numWarnings = 0;\nvar maxWarnings = 10;\n\nfunction warn(msg){\n    if(numWarnings > maxWarnings){\n        return;\n    }\n\n    numWarnings++;\n\n    console.warn(msg);\n}\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =\nNarrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    si.convexPolyhedronRepresentation.material = si.material;\n    sj.convexPolyhedronRepresentation.material = sj.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n    return this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    return this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =\nNarrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    return this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);\n};\n\n/**\n * @method sphereSphere\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE] =\nNarrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    if(justTest){\n        return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);\n    }\n\n    // We will have only one contact in this case\n    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n\n    // Contact normal\n    xj.vsub(xi, r.ni);\n    r.ni.normalize();\n\n    // Contact point locations\n    r.ri.copy(r.ni);\n    r.rj.copy(r.ni);\n    r.ri.mult(si.radius, r.ri);\n    r.rj.mult(-sj.radius, r.rj);\n\n    r.ri.vadd(xi, r.ri);\n    r.ri.vsub(bi.position, r.ri);\n\n    r.rj.vadd(xj, r.rj);\n    r.rj.vsub(bj.position, r.rj);\n\n    this.result.push(r);\n\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n};\n\n/**\n * @method planeTrimesh\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nvar planeTrimesh_normal = new Vec3();\nvar planeTrimesh_relpos = new Vec3();\nvar planeTrimesh_projected = new Vec3();\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =\nNarrowphase.prototype.planeTrimesh = function(\n    planeShape,\n    trimeshShape,\n    planePos,\n    trimeshPos,\n    planeQuat,\n    trimeshQuat,\n    planeBody,\n    trimeshBody,\n    rsi,\n    rsj,\n    justTest\n){\n    // Make contacts!\n    var v = new Vec3();\n\n    var normal = planeTrimesh_normal;\n    normal.set(0,0,1);\n    planeQuat.vmult(normal,normal); // Turn normal according to plane\n\n    for(var i=0; i<trimeshShape.vertices.length / 3; i++){\n\n        // Get world vertex from trimesh\n        trimeshShape.getVertex(i, v);\n\n        // Safe up\n        var v2 = new Vec3();\n        v2.copy(v);\n        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);\n\n        // Check plane side\n        var relpos = planeTrimesh_relpos;\n        v.vsub(planePos, relpos);\n        var dot = normal.dot(relpos);\n\n        if(dot <= 0.0){\n            if(justTest){\n                return true;\n            }\n\n            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape,rsi,rsj);\n\n            r.ni.copy(normal); // Contact normal is the plane normal\n\n            // Get vertex position projected on plane\n            var projected = planeTrimesh_projected;\n            normal.scale(relpos.dot(normal), projected);\n            v.vsub(projected,projected);\n\n            // ri is the projected world position minus plane position\n            r.ri.copy(projected);\n            r.ri.vsub(planeBody.position, r.ri);\n\n            r.rj.copy(v);\n            r.rj.vsub(trimeshBody.position, r.rj);\n\n            // Store result\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n    }\n};\n\n/**\n * @method sphereTrimesh\n * @param  {Shape}      sphereShape\n * @param  {Shape}      trimeshShape\n * @param  {Vec3}       spherePos\n * @param  {Vec3}       trimeshPos\n * @param  {Quaternion} sphereQuat\n * @param  {Quaternion} trimeshQuat\n * @param  {Body}       sphereBody\n * @param  {Body}       trimeshBody\n */\nvar sphereTrimesh_normal = new Vec3();\nvar sphereTrimesh_relpos = new Vec3();\nvar sphereTrimesh_projected = new Vec3();\nvar sphereTrimesh_v = new Vec3();\nvar sphereTrimesh_v2 = new Vec3();\nvar sphereTrimesh_edgeVertexA = new Vec3();\nvar sphereTrimesh_edgeVertexB = new Vec3();\nvar sphereTrimesh_edgeVector = new Vec3();\nvar sphereTrimesh_edgeVectorUnit = new Vec3();\nvar sphereTrimesh_localSpherePos = new Vec3();\nvar sphereTrimesh_tmp = new Vec3();\nvar sphereTrimesh_va = new Vec3();\nvar sphereTrimesh_vb = new Vec3();\nvar sphereTrimesh_vc = new Vec3();\nvar sphereTrimesh_localSphereAABB = new AABB();\nvar sphereTrimesh_triangles = [];\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =\nNarrowphase.prototype.sphereTrimesh = function (\n    sphereShape,\n    trimeshShape,\n    spherePos,\n    trimeshPos,\n    sphereQuat,\n    trimeshQuat,\n    sphereBody,\n    trimeshBody,\n    rsi,\n    rsj,\n    justTest\n) {\n\n    var edgeVertexA = sphereTrimesh_edgeVertexA;\n    var edgeVertexB = sphereTrimesh_edgeVertexB;\n    var edgeVector = sphereTrimesh_edgeVector;\n    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;\n    var localSpherePos = sphereTrimesh_localSpherePos;\n    var tmp = sphereTrimesh_tmp;\n    var localSphereAABB = sphereTrimesh_localSphereAABB;\n    var v2 = sphereTrimesh_v2;\n    var relpos = sphereTrimesh_relpos;\n    var triangles = sphereTrimesh_triangles;\n\n    // Convert sphere position to local in the trimesh\n    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);\n\n    // Get the aabb of the sphere locally in the trimesh\n    var sphereRadius = sphereShape.radius;\n    localSphereAABB.lowerBound.set(\n        localSpherePos.x - sphereRadius,\n        localSpherePos.y - sphereRadius,\n        localSpherePos.z - sphereRadius\n    );\n    localSphereAABB.upperBound.set(\n        localSpherePos.x + sphereRadius,\n        localSpherePos.y + sphereRadius,\n        localSpherePos.z + sphereRadius\n    );\n\n    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);\n    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All\n\n    // Vertices\n    var v = sphereTrimesh_v;\n    var radiusSquared = sphereShape.radius * sphereShape.radius;\n    for(var i=0; i<triangles.length; i++){\n        for (var j = 0; j < 3; j++) {\n\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);\n\n            // Check vertex overlap in sphere\n            v.vsub(localSpherePos, relpos);\n\n            if(relpos.norm2() <= radiusSquared){\n\n                // Safe up\n                v2.copy(v);\n                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);\n\n                v.vsub(spherePos, relpos);\n\n                if(justTest){\n                    return true;\n                }\n\n                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);\n                r.ni.copy(relpos);\n                r.ni.normalize();\n\n                // ri is the vector from sphere center to the sphere surface\n                r.ri.copy(r.ni);\n                r.ri.scale(sphereShape.radius, r.ri);\n                r.ri.vadd(spherePos, r.ri);\n                r.ri.vsub(sphereBody.position, r.ri);\n\n                r.rj.copy(v);\n                r.rj.vsub(trimeshBody.position, r.rj);\n\n                // Store result\n                this.result.push(r);\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n    }\n\n    // Check all edges\n    for(var i=0; i<triangles.length; i++){\n        for (var j = 0; j < 3; j++) {\n\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);\n            edgeVertexB.vsub(edgeVertexA, edgeVector);\n\n            // Project sphere position to the edge\n            localSpherePos.vsub(edgeVertexB, tmp);\n            var positionAlongEdgeB = tmp.dot(edgeVector);\n\n            localSpherePos.vsub(edgeVertexA, tmp);\n            var positionAlongEdgeA = tmp.dot(edgeVector);\n\n            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){\n\n                // Now check the orthogonal distance from edge to sphere center\n                localSpherePos.vsub(edgeVertexA, tmp);\n\n                edgeVectorUnit.copy(edgeVector);\n                edgeVectorUnit.normalize();\n                positionAlongEdgeA = tmp.dot(edgeVectorUnit);\n\n                edgeVectorUnit.scale(positionAlongEdgeA, tmp);\n                tmp.vadd(edgeVertexA, tmp);\n\n                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame\n                var dist = tmp.distanceTo(localSpherePos);\n                if(dist < sphereShape.radius){\n\n                    if(justTest){\n                        return true;\n                    }\n\n                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);\n\n                    tmp.vsub(localSpherePos, r.ni);\n                    r.ni.normalize();\n                    r.ni.scale(sphereShape.radius, r.ri);\n\n                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n                    tmp.vsub(trimeshBody.position, r.rj);\n\n                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n\n                    this.result.push(r);\n                    this.createFrictionEquationsFromContact(r, this.frictionResult);\n                }\n            }\n        }\n    }\n\n    // Triangle faces\n    var va = sphereTrimesh_va;\n    var vb = sphereTrimesh_vb;\n    var vc = sphereTrimesh_vc;\n    var normal = sphereTrimesh_normal;\n    for(var i=0, N = triangles.length; i !== N; i++){\n        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);\n        trimeshShape.getNormal(triangles[i], normal);\n        localSpherePos.vsub(va, tmp);\n        var dist = tmp.dot(normal);\n        normal.scale(dist, tmp);\n        localSpherePos.vsub(tmp, tmp);\n\n        // tmp is now the sphere position projected to the triangle plane\n        dist = tmp.distanceTo(localSpherePos);\n        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){\n            if(justTest){\n                return true;\n            }\n            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);\n\n            tmp.vsub(localSpherePos, r.ni);\n            r.ni.normalize();\n            r.ni.scale(sphereShape.radius, r.ri);\n\n            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n            tmp.vsub(trimeshBody.position, r.rj);\n\n            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n    }\n\n    triangles.length = 0;\n};\n\nvar point_on_plane_to_sphere = new Vec3();\nvar plane_to_sphere_ortho = new Vec3();\n\n/**\n * @method spherePlane\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =\nNarrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    // We will have one contact in this case\n    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n\n    // Contact normal\n    r.ni.set(0,0,1);\n    qj.vmult(r.ni, r.ni);\n    r.ni.negate(r.ni); // body i is the sphere, flip normal\n    r.ni.normalize(); // Needed?\n\n    // Vector from sphere center to contact point\n    r.ni.mult(si.radius, r.ri);\n\n    // Project down sphere on plane\n    xi.vsub(xj, point_on_plane_to_sphere);\n    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);\n    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane\n\n    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){\n\n        if(justTest){\n            return true;\n        }\n\n        // Make it relative to the body\n        var ri = r.ri;\n        var rj = r.rj;\n        ri.vadd(xi, ri);\n        ri.vsub(bi.position, ri);\n        rj.vadd(xj, rj);\n        rj.vsub(bj.position, rj);\n\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\n// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\nvar pointInPolygon_edge = new Vec3();\nvar pointInPolygon_edge_x_normal = new Vec3();\nvar pointInPolygon_vtp = new Vec3();\nfunction pointInPolygon(verts, normal, p){\n    var positiveResult = null;\n    var N = verts.length;\n    for(var i=0; i!==N; i++){\n        var v = verts[i];\n\n        // Get edge to the next vertex\n        var edge = pointInPolygon_edge;\n        verts[(i+1) % (N)].vsub(v,edge);\n\n        // Get cross product between polygon normal and the edge\n        var edge_x_normal = pointInPolygon_edge_x_normal;\n        //var edge_x_normal = new Vec3();\n        edge.cross(normal,edge_x_normal);\n\n        // Get vector between point and current vertex\n        var vertex_to_p = pointInPolygon_vtp;\n        p.vsub(v,vertex_to_p);\n\n        // This dot product determines which side of the edge the point is\n        var r = edge_x_normal.dot(vertex_to_p);\n\n        // If all such dot products have same sign, we are inside the polygon.\n        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){\n            if(positiveResult===null){\n                positiveResult = r>0;\n            }\n            continue;\n        } else {\n            return false; // Encountered some other sign. Exit.\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return true;\n}\n\nvar box_to_sphere = new Vec3();\nvar sphereBox_ns = new Vec3();\nvar sphereBox_ns1 = new Vec3();\nvar sphereBox_ns2 = new Vec3();\nvar sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];\nvar sphereBox_sphere_to_corner = new Vec3();\nvar sphereBox_side_ns = new Vec3();\nvar sphereBox_side_ns1 = new Vec3();\nvar sphereBox_side_ns2 = new Vec3();\n\n/**\n * @method sphereBox\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =\nNarrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    var v3pool = this.v3pool;\n\n    // we refer to the box as body j\n    var sides = sphereBox_sides;\n    xi.vsub(xj,box_to_sphere);\n    sj.getSideNormals(sides,qj);\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    // Check side (plane) intersections\n    var found = false;\n\n    // Store the resulting side penetration info\n    var side_ns = sphereBox_side_ns;\n    var side_ns1 = sphereBox_side_ns1;\n    var side_ns2 = sphereBox_side_ns2;\n    var side_h = null;\n    var side_penetrations = 0;\n    var side_dot1 = 0;\n    var side_dot2 = 0;\n    var side_distance = null;\n    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){\n        // Get the plane side normal (ns)\n        var ns = sphereBox_ns;\n        ns.copy(sides[idx]);\n\n        var h = ns.norm();\n        ns.normalize();\n\n        // The normal/distance dot product tells which side of the plane we are\n        var dot = box_to_sphere.dot(ns);\n\n        if(dot<h+R && dot>0){\n            // Intersects plane. Now check the other two dimensions\n            var ns1 = sphereBox_ns1;\n            var ns2 = sphereBox_ns2;\n            ns1.copy(sides[(idx+1)%3]);\n            ns2.copy(sides[(idx+2)%3]);\n            var h1 = ns1.norm();\n            var h2 = ns2.norm();\n            ns1.normalize();\n            ns2.normalize();\n            var dot1 = box_to_sphere.dot(ns1);\n            var dot2 = box_to_sphere.dot(ns2);\n            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){\n                var dist = Math.abs(dot-h-R);\n                if(side_distance===null || dist < side_distance){\n                    side_distance = dist;\n                    side_dot1 = dot1;\n                    side_dot2 = dot2;\n                    side_h = h;\n                    side_ns.copy(ns);\n                    side_ns1.copy(ns1);\n                    side_ns2.copy(ns2);\n                    side_penetrations++;\n\n                    if(justTest){\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    if(side_penetrations){\n        found = true;\n        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n        side_ns.mult(-R,r.ri); // Sphere r\n        r.ni.copy(side_ns);\n        r.ni.negate(r.ni); // Normal should be out of sphere\n        side_ns.mult(side_h,side_ns);\n        side_ns1.mult(side_dot1,side_ns1);\n        side_ns.vadd(side_ns1,side_ns);\n        side_ns2.mult(side_dot2,side_ns2);\n        side_ns.vadd(side_ns2,r.rj);\n\n        // Make relative to bodies\n        r.ri.vadd(xi, r.ri);\n        r.ri.vsub(bi.position, r.ri);\n        r.rj.vadd(xj, r.rj);\n        r.rj.vsub(bj.position, r.rj);\n\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n\n    // Check corners\n    var rj = v3pool.get();\n    var sphere_to_corner = sphereBox_sphere_to_corner;\n    for(var j=0; j!==2 && !found; j++){\n        for(var k=0; k!==2 && !found; k++){\n            for(var l=0; l!==2 && !found; l++){\n                rj.set(0,0,0);\n                if(j){\n                    rj.vadd(sides[0],rj);\n                } else {\n                    rj.vsub(sides[0],rj);\n                }\n                if(k){\n                    rj.vadd(sides[1],rj);\n                } else {\n                    rj.vsub(sides[1],rj);\n                }\n                if(l){\n                    rj.vadd(sides[2],rj);\n                } else {\n                    rj.vsub(sides[2],rj);\n                }\n\n                // World position of corner\n                xj.vadd(rj,sphere_to_corner);\n                sphere_to_corner.vsub(xi,sphere_to_corner);\n\n                if(sphere_to_corner.norm2() < R*R){\n                    if(justTest){\n                        return true;\n                    }\n                    found = true;\n                    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n                    r.ri.copy(sphere_to_corner);\n                    r.ri.normalize();\n                    r.ni.copy(r.ri);\n                    r.ri.mult(R,r.ri);\n                    r.rj.copy(rj);\n\n                    // Make relative to bodies\n                    r.ri.vadd(xi, r.ri);\n                    r.ri.vsub(bi.position, r.ri);\n                    r.rj.vadd(xj, r.rj);\n                    r.rj.vsub(bj.position, r.rj);\n\n                    this.result.push(r);\n                    this.createFrictionEquationsFromContact(r, this.frictionResult);\n                }\n            }\n        }\n    }\n    v3pool.release(rj);\n    rj = null;\n\n    // Check edges\n    var edgeTangent = v3pool.get();\n    var edgeCenter = v3pool.get();\n    var r = v3pool.get(); // r = edge center to sphere center\n    var orthogonal = v3pool.get();\n    var dist = v3pool.get();\n    var Nsides = sides.length;\n    for(var j=0; j!==Nsides && !found; j++){\n        for(var k=0; k!==Nsides && !found; k++){\n            if(j%3 !== k%3){\n                // Get edge tangent\n                sides[k].cross(sides[j],edgeTangent);\n                edgeTangent.normalize();\n                sides[j].vadd(sides[k], edgeCenter);\n                r.copy(xi);\n                r.vsub(edgeCenter,r);\n                r.vsub(xj,r);\n                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction\n                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction\n\n                // Find the third side orthogonal to this one\n                var l = 0;\n                while(l===j%3 || l===k%3){\n                    l++;\n                }\n\n                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent\n                dist.copy(xi);\n                dist.vsub(orthogonal,dist);\n                dist.vsub(edgeCenter,dist);\n                dist.vsub(xj,dist);\n\n                // Distances in tangent direction and distance in the plane orthogonal to it\n                var tdist = Math.abs(orthonorm);\n                var ndist = dist.norm();\n\n                if(tdist < sides[l].norm() && ndist<R){\n                    if(justTest){\n                        return true;\n                    }\n                    found = true;\n                    var res = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n                    edgeCenter.vadd(orthogonal,res.rj); // box rj\n                    res.rj.copy(res.rj);\n                    dist.negate(res.ni);\n                    res.ni.normalize();\n\n                    res.ri.copy(res.rj);\n                    res.ri.vadd(xj,res.ri);\n                    res.ri.vsub(xi,res.ri);\n                    res.ri.normalize();\n                    res.ri.mult(R,res.ri);\n\n                    // Make relative to bodies\n                    res.ri.vadd(xi, res.ri);\n                    res.ri.vsub(bi.position, res.ri);\n                    res.rj.vadd(xj, res.rj);\n                    res.rj.vsub(bj.position, res.rj);\n\n                    this.result.push(res);\n                    this.createFrictionEquationsFromContact(res, this.frictionResult);\n                }\n            }\n        }\n    }\n    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);\n};\n\nvar convex_to_sphere = new Vec3();\nvar sphereConvex_edge = new Vec3();\nvar sphereConvex_edgeUnit = new Vec3();\nvar sphereConvex_sphereToCorner = new Vec3();\nvar sphereConvex_worldCorner = new Vec3();\nvar sphereConvex_worldNormal = new Vec3();\nvar sphereConvex_worldPoint = new Vec3();\nvar sphereConvex_worldSpherePointClosestToPlane = new Vec3();\nvar sphereConvex_penetrationVec = new Vec3();\nvar sphereConvex_sphereToWorldPoint = new Vec3();\n\n/**\n * @method sphereConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    var v3pool = this.v3pool;\n    xi.vsub(xj,convex_to_sphere);\n    var normals = sj.faceNormals;\n    var faces = sj.faces;\n    var verts = sj.vertices;\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){\n    //     return;\n    // }\n\n    // Check corners\n    for(var i=0; i!==verts.length; i++){\n        var v = verts[i];\n\n        // World position of corner\n        var worldCorner = sphereConvex_worldCorner;\n        qj.vmult(v,worldCorner);\n        xj.vadd(worldCorner,worldCorner);\n        var sphere_to_corner = sphereConvex_sphereToCorner;\n        worldCorner.vsub(xi, sphere_to_corner);\n        if(sphere_to_corner.norm2() < R * R){\n            if(justTest){\n                return true;\n            }\n            found = true;\n            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n            r.ri.copy(sphere_to_corner);\n            r.ri.normalize();\n            r.ni.copy(r.ri);\n            r.ri.mult(R,r.ri);\n            worldCorner.vsub(xj,r.rj);\n\n            // Should be relative to the body.\n            r.ri.vadd(xi, r.ri);\n            r.ri.vsub(bi.position, r.ri);\n\n            // Should be relative to the body.\n            r.rj.vadd(xj, r.rj);\n            r.rj.vsub(bj.position, r.rj);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n            return;\n        }\n    }\n\n    // Check side (plane) intersections\n    var found = false;\n    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){\n        var normal = normals[i];\n        var face = faces[i];\n\n        // Get world-transformed normal of the face\n        var worldNormal = sphereConvex_worldNormal;\n        qj.vmult(normal,worldNormal);\n\n        // Get a world vertex from the face\n        var worldPoint = sphereConvex_worldPoint;\n        qj.vmult(verts[face[0]],worldPoint);\n        worldPoint.vadd(xj,worldPoint);\n\n        // Get a point on the sphere, closest to the face normal\n        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;\n        worldNormal.mult(-R, worldSpherePointClosestToPlane);\n        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);\n\n        // Vector from a face point to the closest point on the sphere\n        var penetrationVec = sphereConvex_penetrationVec;\n        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);\n\n        // The penetration. Negative value means overlap.\n        var penetration = penetrationVec.dot(worldNormal);\n\n        var worldPointToSphere = sphereConvex_sphereToWorldPoint;\n        xi.vsub(worldPoint, worldPointToSphere);\n\n        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){\n            // Intersects plane. Now check if the sphere is inside the face polygon\n            var faceVerts = []; // Face vertices, in world coords\n            for(var j=0, Nverts=face.length; j!==Nverts; j++){\n                var worldVertex = v3pool.get();\n                qj.vmult(verts[face[j]], worldVertex);\n                xj.vadd(worldVertex,worldVertex);\n                faceVerts.push(worldVertex);\n            }\n\n            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?\n                if(justTest){\n                    return true;\n                }\n                found = true;\n                var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n\n                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact\n                worldNormal.negate(r.ni); // Normal pointing out of sphere\n\n                var penetrationVec2 = v3pool.get();\n                worldNormal.mult(-penetration, penetrationVec2);\n                var penetrationSpherePoint = v3pool.get();\n                worldNormal.mult(-R, penetrationSpherePoint);\n\n                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);\n                xi.vsub(xj,r.rj);\n                r.rj.vadd(penetrationSpherePoint,r.rj);\n                r.rj.vadd(penetrationVec2 , r.rj);\n\n                // Should be relative to the body.\n                r.rj.vadd(xj, r.rj);\n                r.rj.vsub(bj.position, r.rj);\n\n                // Should be relative to the body.\n                r.ri.vadd(xi, r.ri);\n                r.ri.vsub(bi.position, r.ri);\n\n                v3pool.release(penetrationVec2);\n                v3pool.release(penetrationSpherePoint);\n\n                this.result.push(r);\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n\n                // Release world vertices\n                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                    v3pool.release(faceVerts[j]);\n                }\n\n                return; // We only expect *one* face contact\n            } else {\n                // Edge?\n                for(var j=0; j!==face.length; j++){\n\n                    // Get two world transformed vertices\n                    var v1 = v3pool.get();\n                    var v2 = v3pool.get();\n                    qj.vmult(verts[face[(j+1)%face.length]], v1);\n                    qj.vmult(verts[face[(j+2)%face.length]], v2);\n                    xj.vadd(v1, v1);\n                    xj.vadd(v2, v2);\n\n                    // Construct edge vector\n                    var edge = sphereConvex_edge;\n                    v2.vsub(v1,edge);\n\n                    // Construct the same vector, but normalized\n                    var edgeUnit = sphereConvex_edgeUnit;\n                    edge.unit(edgeUnit);\n\n                    // p is xi projected onto the edge\n                    var p = v3pool.get();\n                    var v1_to_xi = v3pool.get();\n                    xi.vsub(v1, v1_to_xi);\n                    var dot = v1_to_xi.dot(edgeUnit);\n                    edgeUnit.mult(dot, p);\n                    p.vadd(v1, p);\n\n                    // Compute a vector from p to the center of the sphere\n                    var xi_to_p = v3pool.get();\n                    p.vsub(xi, xi_to_p);\n\n                    // Collision if the edge-sphere distance is less than the radius\n                    // AND if p is in between v1 and v2\n                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius\n                        // Edge contact!\n                        if(justTest){\n                            return true;\n                        }\n                        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n                        p.vsub(xj,r.rj);\n\n                        p.vsub(xi,r.ni);\n                        r.ni.normalize();\n\n                        r.ni.mult(R,r.ri);\n\n                        // Should be relative to the body.\n                        r.rj.vadd(xj, r.rj);\n                        r.rj.vsub(bj.position, r.rj);\n\n                        // Should be relative to the body.\n                        r.ri.vadd(xi, r.ri);\n                        r.ri.vsub(bi.position, r.ri);\n\n                        this.result.push(r);\n                        this.createFrictionEquationsFromContact(r, this.frictionResult);\n\n                        // Release world vertices\n                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                            v3pool.release(faceVerts[j]);\n                        }\n\n                        v3pool.release(v1);\n                        v3pool.release(v2);\n                        v3pool.release(p);\n                        v3pool.release(xi_to_p);\n                        v3pool.release(v1_to_xi);\n\n                        return;\n                    }\n\n                    v3pool.release(v1);\n                    v3pool.release(v2);\n                    v3pool.release(p);\n                    v3pool.release(xi_to_p);\n                    v3pool.release(v1_to_xi);\n                }\n            }\n\n            // Release world vertices\n            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                v3pool.release(faceVerts[j]);\n            }\n        }\n    }\n};\n\nvar planeBox_normal = new Vec3();\nvar plane_to_corner = new Vec3();\n\n/**\n * @method planeBox\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =\nNarrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    sj.convexPolyhedronRepresentation.material = sj.material;\n    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n    sj.convexPolyhedronRepresentation.id = sj.id;\n    return this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest);\n};\n\nvar planeConvex_v = new Vec3();\nvar planeConvex_normal = new Vec3();\nvar planeConvex_relpos = new Vec3();\nvar planeConvex_projected = new Vec3();\n\n/**\n * @method planeConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.planeConvex = function(\n    planeShape,\n    convexShape,\n    planePosition,\n    convexPosition,\n    planeQuat,\n    convexQuat,\n    planeBody,\n    convexBody,\n    si,\n    sj,\n    justTest\n){\n    // Simply return the points behind the plane.\n    var worldVertex = planeConvex_v,\n        worldNormal = planeConvex_normal;\n    worldNormal.set(0,0,1);\n    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation\n\n    var numContacts = 0;\n    var relpos = planeConvex_relpos;\n    for(var i = 0; i !== convexShape.vertices.length; i++){\n\n        // Get world convex vertex\n        worldVertex.copy(convexShape.vertices[i]);\n        convexQuat.vmult(worldVertex, worldVertex);\n        convexPosition.vadd(worldVertex, worldVertex);\n        worldVertex.vsub(planePosition, relpos);\n\n        var dot = worldNormal.dot(relpos);\n        if(dot <= 0.0){\n            if(justTest){\n                return true;\n            }\n\n            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);\n\n            // Get vertex position projected on plane\n            var projected = planeConvex_projected;\n            worldNormal.mult(worldNormal.dot(relpos),projected);\n            worldVertex.vsub(projected, projected);\n            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane\n\n            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane\n\n            // rj is now just the vector from the convex center to the vertex\n            worldVertex.vsub(convexPosition, r.rj);\n\n            // Make it relative to the body\n            r.ri.vadd(planePosition, r.ri);\n            r.ri.vsub(planeBody.position, r.ri);\n            r.rj.vadd(convexPosition, r.rj);\n            r.rj.vsub(convexBody.position, r.rj);\n\n            this.result.push(r);\n            numContacts++;\n            if(!this.enableFrictionReduction){\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction && numContacts){\n        this.createFrictionFromAverage(numContacts);\n    }\n};\n\nvar convexConvex_sepAxis = new Vec3();\nvar convexConvex_q = new Vec3();\n\n/**\n * @method convexConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest,faceListA,faceListB){\n    var sepAxis = convexConvex_sepAxis;\n\n    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n        return;\n    }\n\n    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){\n        var res = [];\n        var q = convexConvex_q;\n        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);\n        var numContacts = 0;\n        for(var j = 0; j !== res.length; j++){\n            if(justTest){\n                return true;\n            }\n            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),\n                ri = r.ri,\n                rj = r.rj;\n            sepAxis.negate(r.ni);\n            res[j].normal.negate(q);\n            q.mult(res[j].depth, q);\n            res[j].point.vadd(q, ri);\n            rj.copy(res[j].point);\n\n            // Contact points are in world coordinates. Transform back to relative\n            ri.vsub(xi,ri);\n            rj.vsub(xj,rj);\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            this.result.push(r);\n            numContacts++;\n            if(!this.enableFrictionReduction){\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n        if(this.enableFrictionReduction && numContacts){\n            this.createFrictionFromAverage(numContacts);\n        }\n    }\n};\n\n\n/**\n * @method convexTrimesh\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =\n// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){\n//     var sepAxis = convexConvex_sepAxis;\n\n//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n//         return;\n//     }\n\n//     // Construct a temp hull for each triangle\n//     var hullB = new ConvexPolyhedron();\n\n//     hullB.faces = [[0,1,2]];\n//     var va = new Vec3();\n//     var vb = new Vec3();\n//     var vc = new Vec3();\n//     hullB.vertices = [\n//         va,\n//         vb,\n//         vc\n//     ];\n\n//     for (var i = 0; i < sj.indices.length / 3; i++) {\n\n//         var triangleNormal = new Vec3();\n//         sj.getNormal(i, triangleNormal);\n//         hullB.faceNormals = [triangleNormal];\n\n//         sj.getTriangleVertices(i, va, vb, vc);\n\n//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n//         if(!d){\n//             triangleNormal.scale(-1, triangleNormal);\n//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n\n//             if(!d){\n//                 continue;\n//             }\n//         }\n\n//         var res = [];\n//         var q = convexConvex_q;\n//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);\n//         for(var j = 0; j !== res.length; j++){\n//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),\n//                 ri = r.ri,\n//                 rj = r.rj;\n//             r.ni.copy(triangleNormal);\n//             r.ni.negate(r.ni);\n//             res[j].normal.negate(q);\n//             q.mult(res[j].depth, q);\n//             res[j].point.vadd(q, ri);\n//             rj.copy(res[j].point);\n\n//             // Contact points are in world coordinates. Transform back to relative\n//             ri.vsub(xi,ri);\n//             rj.vsub(xj,rj);\n\n//             // Make relative to bodies\n//             ri.vadd(xi, ri);\n//             ri.vsub(bi.position, ri);\n//             rj.vadd(xj, rj);\n//             rj.vsub(bj.position, rj);\n\n//             result.push(r);\n//         }\n//     }\n// };\n\nvar particlePlane_normal = new Vec3();\nvar particlePlane_relpos = new Vec3();\nvar particlePlane_projected = new Vec3();\n\n/**\n * @method particlePlane\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =\nNarrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){\n    var normal = particlePlane_normal;\n    normal.set(0,0,1);\n    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation\n    var relpos = particlePlane_relpos;\n    xi.vsub(bj.position,relpos);\n    var dot = normal.dot(relpos);\n    if(dot <= 0.0){\n\n        if(justTest){\n            return true;\n        }\n\n        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n        r.ni.copy(normal); // Contact normal is the plane normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n\n        // Get particle position projected on plane\n        var projected = particlePlane_projected;\n        normal.mult(normal.dot(xi),projected);\n        xi.vsub(projected,projected);\n        //projected.vadd(bj.position,projected);\n\n        // rj is now the projected world position minus plane position\n        r.rj.copy(projected);\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\nvar particleSphere_normal = new Vec3();\n\n/**\n * @method particleSphere\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =\nNarrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){\n    // The normal is the unit vector from sphere center to particle center\n    var normal = particleSphere_normal;\n    normal.set(0,0,1);\n    xi.vsub(xj,normal);\n    var lengthSquared = normal.norm2();\n\n    if(lengthSquared <= sj.radius * sj.radius){\n        if(justTest){\n            return true;\n        }\n        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n        normal.normalize();\n        r.rj.copy(normal);\n        r.rj.mult(sj.radius,r.rj);\n        r.ni.copy(normal); // Contact normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\n// WIP\nvar cqj = new Quaternion();\nvar convexParticle_local = new Vec3();\nvar convexParticle_normal = new Vec3();\nvar convexParticle_penetratedFaceNormal = new Vec3();\nvar convexParticle_vertexToParticle = new Vec3();\nvar convexParticle_worldPenetrationVec = new Vec3();\n\n/**\n * @method convexParticle\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){\n    var penetratedFaceIndex = -1;\n    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;\n    var worldPenetrationVec = convexParticle_worldPenetrationVec;\n    var minPenetration = null;\n    var numDetectedFaces = 0;\n\n    // Convert particle position xi to local coords in the convex\n    var local = convexParticle_local;\n    local.copy(xi);\n    local.vsub(xj,local); // Convert position to relative the convex origin\n    qj.conjugate(cqj);\n    cqj.vmult(local,local);\n\n    if(sj.pointIsInside(local)){\n\n        if(sj.worldVerticesNeedsUpdate){\n            sj.computeWorldVertices(xj,qj);\n        }\n        if(sj.worldFaceNormalsNeedsUpdate){\n            sj.computeWorldFaceNormals(qj);\n        }\n\n        // For each world polygon in the polyhedra\n        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){\n\n            // Construct world face vertices\n            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];\n            var normal = sj.worldFaceNormals[i];\n\n            // Check how much the particle penetrates the polygon plane.\n            xi.vsub(verts[0],convexParticle_vertexToParticle);\n            var penetration = -normal.dot(convexParticle_vertexToParticle);\n            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){\n\n                if(justTest){\n                    return true;\n                }\n\n                minPenetration = penetration;\n                penetratedFaceIndex = i;\n                penetratedFaceNormal.copy(normal);\n                numDetectedFaces++;\n            }\n        }\n\n        if(penetratedFaceIndex!==-1){\n            // Setup contact\n            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);\n            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);\n\n            // rj is the particle position projected to the face\n            worldPenetrationVec.vadd(xi,worldPenetrationVec);\n            worldPenetrationVec.vsub(xj,worldPenetrationVec);\n            r.rj.copy(worldPenetrationVec);\n            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);\n            //projectedToFace.copy(r.rj);\n\n            //qj.vmult(r.rj,r.rj);\n            penetratedFaceNormal.negate( r.ni ); // Contact normal\n            r.ri.set(0,0,0); // Center of particle\n\n            var ri = r.ri,\n                rj = r.rj;\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        } else {\n            console.warn(\"Point found inside convex, but did not find penetrating face!\");\n        }\n    }\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    return this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);\n};\n\nvar convexHeightfield_tmp1 = new Vec3();\nvar convexHeightfield_tmp2 = new Vec3();\nvar convexHeightfield_faceList = [0];\n\n/**\n * @method convexHeightfield\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function (\n    convexShape,\n    hfShape,\n    convexPos,\n    hfPos,\n    convexQuat,\n    hfQuat,\n    convexBody,\n    hfBody,\n    rsi,\n    rsj,\n    justTest\n){\n    var data = hfShape.data,\n        w = hfShape.elementSize,\n        radius = convexShape.boundingSphereRadius,\n        worldPillarOffset = convexHeightfield_tmp2,\n        faceList = convexHeightfield_faceList;\n\n    // Get sphere position to heightfield local!\n    var localConvexPos = convexHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,\n        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){\n        return;\n    }\n\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            var intersecting = false;\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n                intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);\n            }\n\n            if(justTest && intersecting){\n                return true;\n            }\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n                intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);\n            }\n\n            if(justTest && intersecting){\n                return true;\n            }\n        }\n    }\n};\n\nvar sphereHeightfield_tmp1 = new Vec3();\nvar sphereHeightfield_tmp2 = new Vec3();\n\n/**\n * @method sphereHeightfield\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.sphereHeightfield = function (\n    sphereShape,\n    hfShape,\n    spherePos,\n    hfPos,\n    sphereQuat,\n    hfQuat,\n    sphereBody,\n    hfBody,\n    rsi,\n    rsj,\n    justTest\n){\n    var data = hfShape.data,\n        radius = sphereShape.radius,\n        w = hfShape.elementSize,\n        worldPillarOffset = sphereHeightfield_tmp2;\n\n    // Get sphere position to heightfield local!\n    var localSpherePos = sphereHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,\n        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){\n        return;\n    }\n\n    var result = this.result;\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            var numContactsBefore = result.length;\n\n            var intersecting = false;\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n                intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);\n            }\n\n            if(justTest && intersecting){\n                return true;\n            }\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n                intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);\n            }\n\n            if(justTest && intersecting){\n                return true;\n            }\n\n            var numContacts = result.length - numContactsBefore;\n\n            if(numContacts > 2){\n                return;\n            }\n            /*\n            // Skip all but 1\n            for (var k = 0; k < numContacts - 1; k++) {\n                result.pop();\n            }\n            */\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}