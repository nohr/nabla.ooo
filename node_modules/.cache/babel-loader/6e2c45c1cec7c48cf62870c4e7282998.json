{"ast":null,"code":"module.exports = Constraint;\n\nvar Utils = require('../utils/Utils');\n/**\n * Constraint base class\n * @class Constraint\n * @author schteppe\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {boolean} [options.collideConnected=true]\n * @param {boolean} [options.wakeUpBodies=true]\n */\n\n\nfunction Constraint(bodyA, bodyB, options) {\n  options = Utils.defaults(options, {\n    collideConnected: true,\n    wakeUpBodies: true\n  });\n  /**\n   * Equations to be solved in this constraint\n   * @property equations\n   * @type {Array}\n   */\n\n  this.equations = [];\n  /**\n   * @property {Body} bodyA\n   */\n\n  this.bodyA = bodyA;\n  /**\n   * @property {Body} bodyB\n   */\n\n  this.bodyB = bodyB;\n  /**\n   * @property {Number} id\n   */\n\n  this.id = Constraint.idCounter++;\n  /**\n   * Set to true if you want the bodies to collide when they are connected.\n   * @property collideConnected\n   * @type {boolean}\n   */\n\n  this.collideConnected = options.collideConnected;\n\n  if (options.wakeUpBodies) {\n    if (bodyA) {\n      bodyA.wakeUp();\n    }\n\n    if (bodyB) {\n      bodyB.wakeUp();\n    }\n  }\n}\n/**\n * Update all the equations with data.\n * @method update\n */\n\n\nConstraint.prototype.update = function () {\n  throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n/**\n * Enables all equations in the constraint.\n * @method enable\n */\n\n\nConstraint.prototype.enable = function () {\n  var eqs = this.equations;\n\n  for (var i = 0; i < eqs.length; i++) {\n    eqs[i].enabled = true;\n  }\n};\n/**\n * Disables all equations in the constraint.\n * @method disable\n */\n\n\nConstraint.prototype.disable = function () {\n  var eqs = this.equations;\n\n  for (var i = 0; i < eqs.length; i++) {\n    eqs[i].enabled = false;\n  }\n};\n\nConstraint.idCounter = 0;","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/constraints/Constraint.js"],"names":["module","exports","Constraint","Utils","require","bodyA","bodyB","options","defaults","collideConnected","wakeUpBodies","equations","id","idCounter","wakeUp","prototype","update","Error","enable","eqs","i","length","enabled","disable"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,UAAT,CAAoBG,KAApB,EAA2BC,KAA3B,EAAkCC,OAAlC,EAA0C;AACtCA,EAAAA,OAAO,GAAGJ,KAAK,CAACK,QAAN,CAAeD,OAAf,EAAuB;AAC7BE,IAAAA,gBAAgB,EAAG,IADU;AAE7BC,IAAAA,YAAY,EAAG;AAFc,GAAvB,CAAV;AAKA;AACJ;AACA;AACA;AACA;;AACI,OAAKC,SAAL,GAAiB,EAAjB;AAEA;AACJ;AACA;;AACI,OAAKN,KAAL,GAAaA,KAAb;AAEA;AACJ;AACA;;AACI,OAAKC,KAAL,GAAaA,KAAb;AAEA;AACJ;AACA;;AACI,OAAKM,EAAL,GAAUV,UAAU,CAACW,SAAX,EAAV;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKJ,gBAAL,GAAwBF,OAAO,CAACE,gBAAhC;;AAEA,MAAGF,OAAO,CAACG,YAAX,EAAwB;AACpB,QAAGL,KAAH,EAAS;AACLA,MAAAA,KAAK,CAACS,MAAN;AACH;;AACD,QAAGR,KAAH,EAAS;AACLA,MAAAA,KAAK,CAACQ,MAAN;AACH;AACJ;AACJ;AAED;AACA;AACA;AACA;;;AACAZ,UAAU,CAACa,SAAX,CAAqBC,MAArB,GAA8B,YAAU;AACpC,QAAM,IAAIC,KAAJ,CAAU,+DAAV,CAAN;AACH,CAFD;AAIA;AACA;AACA;AACA;;;AACAf,UAAU,CAACa,SAAX,CAAqBG,MAArB,GAA8B,YAAU;AACpC,MAAIC,GAAG,GAAG,KAAKR,SAAf;;AACA,OAAI,IAAIS,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACD,GAAG,CAACE,MAAnB,EAA2BD,CAAC,EAA5B,EAA+B;AAC3BD,IAAAA,GAAG,CAACC,CAAD,CAAH,CAAOE,OAAP,GAAiB,IAAjB;AACH;AACJ,CALD;AAOA;AACA;AACA;AACA;;;AACApB,UAAU,CAACa,SAAX,CAAqBQ,OAArB,GAA+B,YAAU;AACrC,MAAIJ,GAAG,GAAG,KAAKR,SAAf;;AACA,OAAI,IAAIS,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACD,GAAG,CAACE,MAAnB,EAA2BD,CAAC,EAA5B,EAA+B;AAC3BD,IAAAA,GAAG,CAACC,CAAD,CAAH,CAAOE,OAAP,GAAiB,KAAjB;AACH;AACJ,CALD;;AAOApB,UAAU,CAACW,SAAX,GAAuB,CAAvB","sourcesContent":["module.exports = Constraint;\n\nvar Utils = require('../utils/Utils');\n\n/**\n * Constraint base class\n * @class Constraint\n * @author schteppe\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {boolean} [options.collideConnected=true]\n * @param {boolean} [options.wakeUpBodies=true]\n */\nfunction Constraint(bodyA, bodyB, options){\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * @property {Number} id\n     */\n    this.id = Constraint.idCounter++;\n\n    /**\n     * Set to true if you want the bodies to collide when they are connected.\n     * @property collideConnected\n     * @type {boolean}\n     */\n    this.collideConnected = options.collideConnected;\n\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * Update all the equations with data.\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\n/**\n * Enables all equations in the constraint.\n * @method enable\n */\nConstraint.prototype.enable = function(){\n    var eqs = this.equations;\n    for(var i=0; i<eqs.length; i++){\n        eqs[i].enabled = true;\n    }\n};\n\n/**\n * Disables all equations in the constraint.\n * @method disable\n */\nConstraint.prototype.disable = function(){\n    var eqs = this.equations;\n    for(var i=0; i<eqs.length; i++){\n        eqs[i].enabled = false;\n    }\n};\n\nConstraint.idCounter = 0;\n"]},"metadata":{},"sourceType":"script"}