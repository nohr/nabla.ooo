{"ast":null,"code":"module.exports = OverlapKeeper;\n/**\n * @class OverlapKeeper\n * @constructor\n */\n\nfunction OverlapKeeper() {\n  this.current = [];\n  this.previous = [];\n}\n\nOverlapKeeper.prototype.getKey = function (i, j) {\n  if (j < i) {\n    var temp = j;\n    j = i;\n    i = temp;\n  }\n\n  return i << 16 | j;\n};\n/**\n * @method set\n * @param {Number} i\n * @param {Number} j\n */\n\n\nOverlapKeeper.prototype.set = function (i, j) {\n  // Insertion sort. This way the diff will have linear complexity.\n  var key = this.getKey(i, j);\n  var current = this.current;\n  var index = 0;\n\n  while (key > current[index]) {\n    index++;\n  }\n\n  if (key === current[index]) {\n    return; // Pair was already added\n  }\n\n  for (var j = current.length - 1; j >= index; j--) {\n    current[j + 1] = current[j];\n  }\n\n  current[index] = key;\n};\n/**\n * @method tick\n */\n\n\nOverlapKeeper.prototype.tick = function () {\n  var tmp = this.current;\n  this.current = this.previous;\n  this.previous = tmp;\n  this.current.length = 0;\n};\n\nfunction unpackAndPush(array, key) {\n  array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);\n}\n/**\n * @method getDiff\n * @param  {array} additions\n * @param  {array} removals\n */\n\n\nOverlapKeeper.prototype.getDiff = function (additions, removals) {\n  var a = this.current;\n  var b = this.previous;\n  var al = a.length;\n  var bl = b.length;\n  var j = 0;\n\n  for (var i = 0; i < al; i++) {\n    var found = false;\n    var keyA = a[i];\n\n    while (keyA > b[j]) {\n      j++;\n    }\n\n    found = keyA === b[j];\n\n    if (!found) {\n      unpackAndPush(additions, keyA);\n    }\n  }\n\n  j = 0;\n\n  for (var i = 0; i < bl; i++) {\n    var found = false;\n    var keyB = b[i];\n\n    while (keyB > a[j]) {\n      j++;\n    }\n\n    found = a[j] === keyB;\n\n    if (!found) {\n      unpackAndPush(removals, keyB);\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/collision/OverlapKeeper.js"],"names":["module","exports","OverlapKeeper","current","previous","prototype","getKey","i","j","temp","set","key","index","length","tick","tmp","unpackAndPush","array","push","getDiff","additions","removals","a","b","al","bl","found","keyA","keyB"],"mappings":"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","sourcesContent":["module.exports = OverlapKeeper;\n\n/**\n * @class OverlapKeeper\n * @constructor\n */\nfunction OverlapKeeper() {\n    this.current = [];\n    this.previous = [];\n}\n\nOverlapKeeper.prototype.getKey = function(i, j) {\n    if (j < i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n    return (i << 16) | j;\n};\n\n\n/**\n * @method set\n * @param {Number} i\n * @param {Number} j\n */\nOverlapKeeper.prototype.set = function(i, j) {\n    // Insertion sort. This way the diff will have linear complexity.\n    var key = this.getKey(i, j);\n    var current = this.current;\n    var index = 0;\n    while(key > current[index]){\n        index++;\n    }\n    if(key === current[index]){\n        return; // Pair was already added\n    }\n    for(var j=current.length-1; j>=index; j--){\n        current[j + 1] = current[j];\n    }\n    current[index] = key;\n};\n\n/**\n * @method tick\n */\nOverlapKeeper.prototype.tick = function() {\n    var tmp = this.current;\n    this.current = this.previous;\n    this.previous = tmp;\n    this.current.length = 0;\n};\n\nfunction unpackAndPush(array, key){\n    array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);\n}\n\n/**\n * @method getDiff\n * @param  {array} additions\n * @param  {array} removals\n */\nOverlapKeeper.prototype.getDiff = function(additions, removals) {\n    var a = this.current;\n    var b = this.previous;\n    var al = a.length;\n    var bl = b.length;\n\n    var j=0;\n    for (var i = 0; i < al; i++) {\n        var found = false;\n        var keyA = a[i];\n        while(keyA > b[j]){\n            j++;\n        }\n        found = keyA === b[j];\n\n        if(!found){\n            unpackAndPush(additions, keyA);\n        }\n    }\n    j = 0;\n    for (var i = 0; i < bl; i++) {\n        var found = false;\n        var keyB = b[i];\n        while(keyB > a[j]){\n            j++;\n        }\n        found = a[j] === keyB;\n\n        if(!found){\n            unpackAndPush(removals, keyB);\n        }\n    }\n};"]},"metadata":{},"sourceType":"script"}