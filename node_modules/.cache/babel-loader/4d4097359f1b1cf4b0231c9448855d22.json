{"ast":null,"code":"/* global performance */\nmodule.exports = World;\n\nvar Shape = require('../shapes/Shape');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar GSSolver = require('../solver/GSSolver');\n\nvar ContactEquation = require('../equations/ContactEquation');\n\nvar FrictionEquation = require('../equations/FrictionEquation');\n\nvar Narrowphase = require('./Narrowphase');\n\nvar EventTarget = require('../utils/EventTarget');\n\nvar ArrayCollisionMatrix = require('../collision/ArrayCollisionMatrix');\n\nvar OverlapKeeper = require('../collision/OverlapKeeper');\n\nvar Material = require('../material/Material');\n\nvar ContactMaterial = require('../material/ContactMaterial');\n\nvar Body = require('../objects/Body');\n\nvar TupleDictionary = require('../utils/TupleDictionary');\n\nvar RaycastResult = require('../collision/RaycastResult');\n\nvar AABB = require('../collision/AABB');\n\nvar Ray = require('../collision/Ray');\n\nvar NaiveBroadphase = require('../collision/NaiveBroadphase');\n/**\n * The physics world\n * @class World\n * @constructor\n * @extends EventTarget\n * @param {object} [options]\n * @param {Vec3} [options.gravity]\n * @param {boolean} [options.allowSleep]\n * @param {Broadphase} [options.broadphase]\n * @param {Solver} [options.solver]\n * @param {boolean} [options.quatNormalizeFast]\n * @param {number} [options.quatNormalizeSkip]\n */\n\n\nfunction World(options) {\n  options = options || {};\n  EventTarget.apply(this);\n  /**\n   * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is \"fresh\" inside event callbacks.\n   * @property {Number} dt\n   */\n\n  this.dt = -1;\n  /**\n   * Makes bodies go to sleep when they've been inactive\n   * @property allowSleep\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.allowSleep = !!options.allowSleep;\n  /**\n   * All the current contacts (instances of ContactEquation) in the world.\n   * @property contacts\n   * @type {Array}\n   */\n\n  this.contacts = [];\n  this.frictionEquations = [];\n  /**\n   * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).\n   * @property quatNormalizeSkip\n   * @type {Number}\n   * @default 0\n   */\n\n  this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;\n  /**\n   * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.\n   * @property quatNormalizeFast\n   * @type {Boolean}\n   * @see Quaternion.normalizeFast\n   * @see Quaternion.normalize\n   * @default false\n   */\n\n  this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;\n  /**\n   * The wall-clock time since simulation start\n   * @property time\n   * @type {Number}\n   */\n\n  this.time = 0.0;\n  /**\n   * Number of timesteps taken since start\n   * @property stepnumber\n   * @type {Number}\n   */\n\n  this.stepnumber = 0; /// Default and last timestep sizes\n\n  this.default_dt = 1 / 60;\n  this.nextId = 0;\n  /**\n   * @property gravity\n   * @type {Vec3}\n   */\n\n  this.gravity = new Vec3();\n\n  if (options.gravity) {\n    this.gravity.copy(options.gravity);\n  }\n  /**\n   * The broadphase algorithm to use. Default is NaiveBroadphase\n   * @property broadphase\n   * @type {Broadphase}\n   */\n\n\n  this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();\n  /**\n   * @property bodies\n   * @type {Array}\n   */\n\n  this.bodies = [];\n  /**\n   * The solver algorithm to use. Default is GSSolver\n   * @property solver\n   * @type {Solver}\n   */\n\n  this.solver = options.solver !== undefined ? options.solver : new GSSolver();\n  /**\n   * @property constraints\n   * @type {Array}\n   */\n\n  this.constraints = [];\n  /**\n   * @property narrowphase\n   * @type {Narrowphase}\n   */\n\n  this.narrowphase = new Narrowphase(this);\n  /**\n   * @property {ArrayCollisionMatrix} collisionMatrix\n  * @type {ArrayCollisionMatrix}\n  */\n\n  this.collisionMatrix = new ArrayCollisionMatrix();\n  /**\n   * CollisionMatrix from the previous step.\n   * @property {ArrayCollisionMatrix} collisionMatrixPrevious\n  * @type {ArrayCollisionMatrix}\n  */\n\n  this.collisionMatrixPrevious = new ArrayCollisionMatrix();\n  this.bodyOverlapKeeper = new OverlapKeeper();\n  this.shapeOverlapKeeper = new OverlapKeeper();\n  /**\n   * All added materials\n   * @property materials\n   * @type {Array}\n   */\n\n  this.materials = [];\n  /**\n   * @property contactmaterials\n   * @type {Array}\n   */\n\n  this.contactmaterials = [];\n  /**\n   * Used to look up a ContactMaterial given two instances of Material.\n   * @property {TupleDictionary} contactMaterialTable\n   */\n\n  this.contactMaterialTable = new TupleDictionary();\n  this.defaultMaterial = new Material(\"default\");\n  /**\n   * This contact material is used if no suitable contactmaterial is found for a contact.\n   * @property defaultContactMaterial\n   * @type {ContactMaterial}\n   */\n\n  this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {\n    friction: 0.3,\n    restitution: 0.0\n  });\n  /**\n   * @property doProfiling\n   * @type {Boolean}\n   */\n\n  this.doProfiling = false;\n  /**\n   * @property profile\n   * @type {Object}\n   */\n\n  this.profile = {\n    solve: 0,\n    makeContactConstraints: 0,\n    broadphase: 0,\n    integrate: 0,\n    narrowphase: 0\n  };\n  /**\n   * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/\n   * @property {Number} accumulator\n   */\n\n  this.accumulator = 0;\n  /**\n   * @property subsystems\n   * @type {Array}\n   */\n\n  this.subsystems = [];\n  /**\n   * Dispatched after a body has been added to the world.\n   * @event addBody\n   * @param {Body} body The body that has been added to the world.\n   */\n\n  this.addBodyEvent = {\n    type: \"addBody\",\n    body: null\n  };\n  /**\n   * Dispatched after a body has been removed from the world.\n   * @event removeBody\n   * @param {Body} body The body that has been removed from the world.\n   */\n\n  this.removeBodyEvent = {\n    type: \"removeBody\",\n    body: null\n  };\n  this.idToBodyMap = {};\n  this.broadphase.setWorld(this);\n}\n\nWorld.prototype = new EventTarget(); // Temp stuff\n\nvar tmpAABB1 = new AABB();\nvar tmpArray1 = [];\nvar tmpRay = new Ray();\n/**\n * Get the contact material between materials m1 and m2\n * @method getContactMaterial\n * @param {Material} m1\n * @param {Material} m2\n * @return {ContactMaterial} The contact material if it was found.\n */\n\nWorld.prototype.getContactMaterial = function (m1, m2) {\n  return this.contactMaterialTable.get(m1.id, m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];\n};\n/**\n * Get number of objects in the world.\n * @method numObjects\n * @return {Number}\n * @deprecated\n */\n\n\nWorld.prototype.numObjects = function () {\n  return this.bodies.length;\n};\n/**\n * Store old collision state info\n * @method collisionMatrixTick\n */\n\n\nWorld.prototype.collisionMatrixTick = function () {\n  var temp = this.collisionMatrixPrevious;\n  this.collisionMatrixPrevious = this.collisionMatrix;\n  this.collisionMatrix = temp;\n  this.collisionMatrix.reset();\n  this.bodyOverlapKeeper.tick();\n  this.shapeOverlapKeeper.tick();\n};\n/**\n * Add a rigid body to the simulation.\n * @method add\n * @param {Body} body\n * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.\n * @todo Adding an array of bodies should be possible. This would save some loops too\n * @deprecated Use .addBody instead\n */\n\n\nWorld.prototype.add = World.prototype.addBody = function (body) {\n  if (this.bodies.indexOf(body) !== -1) {\n    return;\n  }\n\n  body.index = this.bodies.length;\n  this.bodies.push(body);\n  body.world = this;\n  body.initPosition.copy(body.position);\n  body.initVelocity.copy(body.velocity);\n  body.timeLastSleepy = this.time;\n\n  if (body instanceof Body) {\n    body.initAngularVelocity.copy(body.angularVelocity);\n    body.initQuaternion.copy(body.quaternion);\n  }\n\n  this.collisionMatrix.setNumObjects(this.bodies.length);\n  this.addBodyEvent.body = body;\n  this.idToBodyMap[body.id] = body;\n  this.dispatchEvent(this.addBodyEvent);\n};\n/**\n * Add a constraint to the simulation.\n * @method addConstraint\n * @param {Constraint} c\n */\n\n\nWorld.prototype.addConstraint = function (c) {\n  this.constraints.push(c);\n};\n/**\n * Removes a constraint\n * @method removeConstraint\n * @param {Constraint} c\n */\n\n\nWorld.prototype.removeConstraint = function (c) {\n  var idx = this.constraints.indexOf(c);\n\n  if (idx !== -1) {\n    this.constraints.splice(idx, 1);\n  }\n};\n/**\n * Raycast test\n * @method rayTest\n * @param {Vec3} from\n * @param {Vec3} to\n * @param {RaycastResult} result\n * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.\n */\n\n\nWorld.prototype.rayTest = function (from, to, result) {\n  if (result instanceof RaycastResult) {\n    // Do raycastclosest\n    this.raycastClosest(from, to, {\n      skipBackfaces: true\n    }, result);\n  } else {\n    // Do raycastAll\n    this.raycastAll(from, to, {\n      skipBackfaces: true\n    }, result);\n  }\n};\n/**\n * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.\n * @method raycastAll\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {Function} callback\n * @return {boolean} True if any body was hit.\n */\n\n\nWorld.prototype.raycastAll = function (from, to, options, callback) {\n  options.mode = Ray.ALL;\n  options.from = from;\n  options.to = to;\n  options.callback = callback;\n  return tmpRay.intersectWorld(this, options);\n};\n/**\n * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.\n * @method raycastAny\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\n\n\nWorld.prototype.raycastAny = function (from, to, options, result) {\n  options.mode = Ray.ANY;\n  options.from = from;\n  options.to = to;\n  options.result = result;\n  return tmpRay.intersectWorld(this, options);\n};\n/**\n * Ray cast, and return information of the closest hit.\n * @method raycastClosest\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\n\n\nWorld.prototype.raycastClosest = function (from, to, options, result) {\n  options.mode = Ray.CLOSEST;\n  options.from = from;\n  options.to = to;\n  options.result = result;\n  return tmpRay.intersectWorld(this, options);\n};\n/**\n * Remove a rigid body from the simulation.\n * @method remove\n * @param {Body} body\n * @deprecated Use .removeBody instead\n */\n\n\nWorld.prototype.remove = function (body) {\n  body.world = null;\n  var n = this.bodies.length - 1,\n      bodies = this.bodies,\n      idx = bodies.indexOf(body);\n\n  if (idx !== -1) {\n    bodies.splice(idx, 1); // Todo: should use a garbage free method\n    // Recompute index\n\n    for (var i = 0; i !== bodies.length; i++) {\n      bodies[i].index = i;\n    }\n\n    this.collisionMatrix.setNumObjects(n);\n    this.removeBodyEvent.body = body;\n    delete this.idToBodyMap[body.id];\n    this.dispatchEvent(this.removeBodyEvent);\n  }\n};\n/**\n * Remove a rigid body from the simulation.\n * @method removeBody\n * @param {Body} body\n */\n\n\nWorld.prototype.removeBody = World.prototype.remove;\n\nWorld.prototype.getBodyById = function (id) {\n  return this.idToBodyMap[id];\n}; // TODO Make a faster map\n\n\nWorld.prototype.getShapeById = function (id) {\n  var bodies = this.bodies;\n\n  for (var i = 0, bl = bodies.length; i < bl; i++) {\n    var shapes = bodies[i].shapes;\n\n    for (var j = 0, sl = shapes.length; j < sl; j++) {\n      var shape = shapes[j];\n\n      if (shape.id === id) {\n        return shape;\n      }\n    }\n  }\n};\n/**\n * Adds a material to the World.\n * @method addMaterial\n * @param {Material} m\n * @todo Necessary?\n */\n\n\nWorld.prototype.addMaterial = function (m) {\n  this.materials.push(m);\n};\n/**\n * Adds a contact material to the World\n * @method addContactMaterial\n * @param {ContactMaterial} cmat\n */\n\n\nWorld.prototype.addContactMaterial = function (cmat) {\n  // Add contact material\n  this.contactmaterials.push(cmat); // Add current contact material to the material table\n\n  this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);\n}; // performance.now()\n\n\nif (typeof performance === 'undefined') {\n  performance = {};\n}\n\nif (!performance.now) {\n  var nowOffset = Date.now();\n\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n\n  performance.now = function () {\n    return Date.now() - nowOffset;\n  };\n}\n\nvar step_tmp1 = new Vec3();\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // fixed timestepping without interpolation\n *     world.step(1/60);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\n\nWorld.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n  maxSubSteps = maxSubSteps || 10;\n  timeSinceLastCalled = timeSinceLastCalled || 0;\n\n  if (timeSinceLastCalled === 0) {\n    // Fixed, simple stepping\n    this.internalStep(dt); // Increment time\n\n    this.time += dt;\n  } else {\n    this.accumulator += timeSinceLastCalled;\n    var substeps = 0;\n\n    while (this.accumulator >= dt && substeps < maxSubSteps) {\n      // Do fixed steps to catch up\n      this.internalStep(dt);\n      this.accumulator -= dt;\n      substeps++;\n    }\n\n    var t = this.accumulator % dt / dt;\n\n    for (var j = 0; j !== this.bodies.length; j++) {\n      var b = this.bodies[j];\n      b.previousPosition.lerp(b.position, t, b.interpolatedPosition);\n      b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);\n      b.previousQuaternion.normalize();\n    }\n\n    this.time += timeSinceLastCalled;\n  }\n};\n\nvar\n/**\n * Dispatched after the world has stepped forward in time.\n * @event postStep\n */\nWorld_step_postStepEvent = {\n  type: \"postStep\"\n},\n    // Reusable event objects to save memory\n\n/**\n * Dispatched before the world steps forward in time.\n * @event preStep\n */\nWorld_step_preStepEvent = {\n  type: \"preStep\"\n},\n    World_step_collideEvent = {\n  type: Body.COLLIDE_EVENT_NAME,\n  body: null,\n  contact: null\n},\n    World_step_oldContacts = [],\n    // Pools for unused objects\nWorld_step_frictionEquationPool = [],\n    World_step_p1 = [],\n    // Reusable arrays for collision pairs\nWorld_step_p2 = [],\n    World_step_gvec = new Vec3(),\n    // Temporary vectors and quats\nWorld_step_vi = new Vec3(),\n    World_step_vj = new Vec3(),\n    World_step_wi = new Vec3(),\n    World_step_wj = new Vec3(),\n    World_step_t1 = new Vec3(),\n    World_step_t2 = new Vec3(),\n    World_step_rixn = new Vec3(),\n    World_step_rjxn = new Vec3(),\n    World_step_step_q = new Quaternion(),\n    World_step_step_w = new Quaternion(),\n    World_step_step_wq = new Quaternion(),\n    invI_tau_dt = new Vec3();\n\nWorld.prototype.internalStep = function (dt) {\n  this.dt = dt;\n  var world = this,\n      that = this,\n      contacts = this.contacts,\n      p1 = World_step_p1,\n      p2 = World_step_p2,\n      N = this.numObjects(),\n      bodies = this.bodies,\n      solver = this.solver,\n      gravity = this.gravity,\n      doProfiling = this.doProfiling,\n      profile = this.profile,\n      DYNAMIC = Body.DYNAMIC,\n      profilingStart,\n      constraints = this.constraints,\n      frictionEquationPool = World_step_frictionEquationPool,\n      gnorm = gravity.norm(),\n      gx = gravity.x,\n      gy = gravity.y,\n      gz = gravity.z,\n      i = 0;\n\n  if (doProfiling) {\n    profilingStart = performance.now();\n  } // Add gravity to all objects\n\n\n  for (i = 0; i !== N; i++) {\n    var bi = bodies[i];\n\n    if (bi.type === DYNAMIC) {\n      // Only for dynamic bodies\n      var f = bi.force,\n          m = bi.mass;\n      f.x += m * gx;\n      f.y += m * gy;\n      f.z += m * gz;\n    }\n  } // Update subsystems\n\n\n  for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {\n    this.subsystems[i].update();\n  } // Collision detection\n\n\n  if (doProfiling) {\n    profilingStart = performance.now();\n  }\n\n  p1.length = 0; // Clean up pair arrays from last step\n\n  p2.length = 0;\n  this.broadphase.collisionPairs(this, p1, p2);\n\n  if (doProfiling) {\n    profile.broadphase = performance.now() - profilingStart;\n  } // Remove constrained pairs with collideConnected == false\n\n\n  var Nconstraints = constraints.length;\n\n  for (i = 0; i !== Nconstraints; i++) {\n    var c = constraints[i];\n\n    if (!c.collideConnected) {\n      for (var j = p1.length - 1; j >= 0; j -= 1) {\n        if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {\n          p1.splice(j, 1);\n          p2.splice(j, 1);\n        }\n      }\n    }\n  }\n\n  this.collisionMatrixTick(); // Generate contacts\n\n  if (doProfiling) {\n    profilingStart = performance.now();\n  }\n\n  var oldcontacts = World_step_oldContacts;\n  var NoldContacts = contacts.length;\n\n  for (i = 0; i !== NoldContacts; i++) {\n    oldcontacts.push(contacts[i]);\n  }\n\n  contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse\n\n  var NoldFrictionEquations = this.frictionEquations.length;\n\n  for (i = 0; i !== NoldFrictionEquations; i++) {\n    frictionEquationPool.push(this.frictionEquations[i]);\n  }\n\n  this.frictionEquations.length = 0;\n  this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused\n  this.frictionEquations, frictionEquationPool);\n\n  if (doProfiling) {\n    profile.narrowphase = performance.now() - profilingStart;\n  } // Loop over all collisions\n\n\n  if (doProfiling) {\n    profilingStart = performance.now();\n  } // Add all friction eqs\n\n\n  for (var i = 0; i < this.frictionEquations.length; i++) {\n    solver.addEquation(this.frictionEquations[i]);\n  }\n\n  var ncontacts = contacts.length;\n\n  for (var k = 0; k !== ncontacts; k++) {\n    // Current contact\n    var c = contacts[k]; // Get current collision indeces\n\n    var bi = c.bi,\n        bj = c.bj,\n        si = c.si,\n        sj = c.sj; // Get collision properties\n\n    var cm;\n\n    if (bi.material && bj.material) {\n      cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;\n    } else {\n      cm = this.defaultContactMaterial;\n    } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n\n    var mu = cm.friction; // c.restitution = cm.restitution;\n    // If friction or restitution were specified in the material, use them\n\n    if (bi.material && bj.material) {\n      if (bi.material.friction >= 0 && bj.material.friction >= 0) {\n        mu = bi.material.friction * bj.material.friction;\n      }\n\n      if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {\n        c.restitution = bi.material.restitution * bj.material.restitution;\n      }\n    } // c.setSpookParams(\n    //           cm.contactEquationStiffness,\n    //           cm.contactEquationRelaxation,\n    //           dt\n    //       );\n\n\n    solver.addEquation(c); // // Add friction constraint equation\n    // if(mu > 0){\n    // \t// Create 2 tangent equations\n    // \tvar mug = mu * gnorm;\n    // \tvar reducedMass = (bi.invMass + bj.invMass);\n    // \tif(reducedMass > 0){\n    // \t\treducedMass = 1/reducedMass;\n    // \t}\n    // \tvar pool = frictionEquationPool;\n    // \tvar c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n    // \tvar c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n    // \tthis.frictionEquations.push(c1, c2);\n    // \tc1.bi = c2.bi = bi;\n    // \tc1.bj = c2.bj = bj;\n    // \tc1.minForce = c2.minForce = -mug*reducedMass;\n    // \tc1.maxForce = c2.maxForce = mug*reducedMass;\n    // \t// Copy over the relative vectors\n    // \tc1.ri.copy(c.ri);\n    // \tc1.rj.copy(c.rj);\n    // \tc2.ri.copy(c.ri);\n    // \tc2.rj.copy(c.rj);\n    // \t// Construct tangents\n    // \tc.ni.tangents(c1.t, c2.t);\n    //           // Set spook params\n    //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n    //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n    //           c1.enabled = c2.enabled = c.enabled;\n    // \t// Add equations to solver\n    // \tsolver.addEquation(c1);\n    // \tsolver.addEquation(c2);\n    // }\n\n    if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {\n      var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();\n      var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);\n\n      if (speedSquaredB >= speedLimitSquaredB * 2) {\n        bi._wakeUpAfterNarrowphase = true;\n      }\n    }\n\n    if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {\n      var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();\n      var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);\n\n      if (speedSquaredA >= speedLimitSquaredA * 2) {\n        bj._wakeUpAfterNarrowphase = true;\n      }\n    } // Now we know that i and j are in contact. Set collision matrix state\n\n\n    this.collisionMatrix.set(bi, bj, true);\n\n    if (!this.collisionMatrixPrevious.get(bi, bj)) {\n      // First contact!\n      // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.\n      World_step_collideEvent.body = bj;\n      World_step_collideEvent.contact = c;\n      bi.dispatchEvent(World_step_collideEvent);\n      World_step_collideEvent.body = bi;\n      bj.dispatchEvent(World_step_collideEvent);\n    }\n\n    this.bodyOverlapKeeper.set(bi.id, bj.id);\n    this.shapeOverlapKeeper.set(si.id, sj.id);\n  }\n\n  this.emitContactEvents();\n\n  if (doProfiling) {\n    profile.makeContactConstraints = performance.now() - profilingStart;\n    profilingStart = performance.now();\n  } // Wake up bodies\n\n\n  for (i = 0; i !== N; i++) {\n    var bi = bodies[i];\n\n    if (bi._wakeUpAfterNarrowphase) {\n      bi.wakeUp();\n      bi._wakeUpAfterNarrowphase = false;\n    }\n  } // Add user-added constraints\n\n\n  var Nconstraints = constraints.length;\n\n  for (i = 0; i !== Nconstraints; i++) {\n    var c = constraints[i];\n    c.update();\n\n    for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {\n      var eq = c.equations[j];\n      solver.addEquation(eq);\n    }\n  } // Solve the constrained system\n\n\n  solver.solve(dt, this);\n\n  if (doProfiling) {\n    profile.solve = performance.now() - profilingStart;\n  } // Remove all contacts from solver\n\n\n  solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details\n\n  var pow = Math.pow;\n\n  for (i = 0; i !== N; i++) {\n    var bi = bodies[i];\n\n    if (bi.type & DYNAMIC) {\n      // Only for dynamic bodies\n      var ld = pow(1.0 - bi.linearDamping, dt);\n      var v = bi.velocity;\n      v.mult(ld, v);\n      var av = bi.angularVelocity;\n\n      if (av) {\n        var ad = pow(1.0 - bi.angularDamping, dt);\n        av.mult(ad, av);\n      }\n    }\n  }\n\n  this.dispatchEvent(World_step_preStepEvent); // Invoke pre-step callbacks\n\n  for (i = 0; i !== N; i++) {\n    var bi = bodies[i];\n\n    if (bi.preStep) {\n      bi.preStep.call(bi);\n    }\n  } // Leap frog\n  // vnew = v + h*f/m\n  // xnew = x + h*vnew\n\n\n  if (doProfiling) {\n    profilingStart = performance.now();\n  }\n\n  var stepnumber = this.stepnumber;\n  var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;\n  var quatNormalizeFast = this.quatNormalizeFast;\n\n  for (i = 0; i !== N; i++) {\n    bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);\n  }\n\n  this.clearForces();\n  this.broadphase.dirty = true;\n\n  if (doProfiling) {\n    profile.integrate = performance.now() - profilingStart;\n  } // Update world time\n\n\n  this.time += dt;\n  this.stepnumber += 1;\n  this.dispatchEvent(World_step_postStepEvent); // Invoke post-step callbacks\n\n  for (i = 0; i !== N; i++) {\n    var bi = bodies[i];\n    var postStep = bi.postStep;\n\n    if (postStep) {\n      postStep.call(bi);\n    }\n  } // Sleeping update\n\n\n  if (this.allowSleep) {\n    for (i = 0; i !== N; i++) {\n      bodies[i].sleepTick(this.time);\n    }\n  }\n};\n\nWorld.prototype.emitContactEvents = function () {\n  var additions = [];\n  var removals = [];\n  var beginContactEvent = {\n    type: 'beginContact',\n    bodyA: null,\n    bodyB: null\n  };\n  var endContactEvent = {\n    type: 'endContact',\n    bodyA: null,\n    bodyB: null\n  };\n  var beginShapeContactEvent = {\n    type: 'beginShapeContact',\n    bodyA: null,\n    bodyB: null,\n    shapeA: null,\n    shapeB: null\n  };\n  var endShapeContactEvent = {\n    type: 'endShapeContact',\n    bodyA: null,\n    bodyB: null,\n    shapeA: null,\n    shapeB: null\n  };\n  return function () {\n    var hasBeginContact = this.hasAnyEventListener('beginContact');\n    var hasEndContact = this.hasAnyEventListener('endContact');\n\n    if (hasBeginContact || hasEndContact) {\n      this.bodyOverlapKeeper.getDiff(additions, removals);\n    }\n\n    if (hasBeginContact) {\n      for (var i = 0, l = additions.length; i < l; i += 2) {\n        beginContactEvent.bodyA = this.getBodyById(additions[i]);\n        beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);\n        this.dispatchEvent(beginContactEvent);\n      }\n\n      beginContactEvent.bodyA = beginContactEvent.bodyB = null;\n    }\n\n    if (hasEndContact) {\n      for (var i = 0, l = removals.length; i < l; i += 2) {\n        endContactEvent.bodyA = this.getBodyById(removals[i]);\n        endContactEvent.bodyB = this.getBodyById(removals[i + 1]);\n        this.dispatchEvent(endContactEvent);\n      }\n\n      endContactEvent.bodyA = endContactEvent.bodyB = null;\n    }\n\n    additions.length = removals.length = 0;\n    var hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');\n    var hasEndShapeContact = this.hasAnyEventListener('endShapeContact');\n\n    if (hasBeginShapeContact || hasEndShapeContact) {\n      this.shapeOverlapKeeper.getDiff(additions, removals);\n    }\n\n    if (hasBeginShapeContact) {\n      for (var i = 0, l = additions.length; i < l; i += 2) {\n        var shapeA = this.getShapeById(additions[i]);\n        var shapeB = this.getShapeById(additions[i + 1]);\n        beginShapeContactEvent.shapeA = shapeA;\n        beginShapeContactEvent.shapeB = shapeB;\n        beginShapeContactEvent.bodyA = shapeA.body;\n        beginShapeContactEvent.bodyB = shapeB.body;\n        this.dispatchEvent(beginShapeContactEvent);\n      }\n\n      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;\n    }\n\n    if (hasEndShapeContact) {\n      for (var i = 0, l = removals.length; i < l; i += 2) {\n        var shapeA = this.getShapeById(removals[i]);\n        var shapeB = this.getShapeById(removals[i + 1]);\n        endShapeContactEvent.shapeA = shapeA;\n        endShapeContactEvent.shapeB = shapeB;\n        endShapeContactEvent.bodyA = shapeA.body;\n        endShapeContactEvent.bodyB = shapeB.body;\n        this.dispatchEvent(endShapeContactEvent);\n      }\n\n      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;\n    }\n  };\n}();\n/**\n * Sets all body forces in the world to zero.\n * @method clearForces\n */\n\n\nWorld.prototype.clearForces = function () {\n  var bodies = this.bodies;\n  var N = bodies.length;\n\n  for (var i = 0; i !== N; i++) {\n    var b = bodies[i],\n        force = b.force,\n        tau = b.torque;\n    b.force.set(0, 0, 0);\n    b.torque.set(0, 0, 0);\n  }\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/world/World.js"],"names":["module","exports","World","Shape","require","Vec3","Quaternion","GSSolver","ContactEquation","FrictionEquation","Narrowphase","EventTarget","ArrayCollisionMatrix","OverlapKeeper","Material","ContactMaterial","Body","TupleDictionary","RaycastResult","AABB","Ray","NaiveBroadphase","options","apply","dt","allowSleep","contacts","frictionEquations","quatNormalizeSkip","undefined","quatNormalizeFast","time","stepnumber","default_dt","nextId","gravity","copy","broadphase","bodies","solver","constraints","narrowphase","collisionMatrix","collisionMatrixPrevious","bodyOverlapKeeper","shapeOverlapKeeper","materials","contactmaterials","contactMaterialTable","defaultMaterial","defaultContactMaterial","friction","restitution","doProfiling","profile","solve","makeContactConstraints","integrate","accumulator","subsystems","addBodyEvent","type","body","removeBodyEvent","idToBodyMap","setWorld","prototype","tmpAABB1","tmpArray1","tmpRay","getContactMaterial","m1","m2","get","id","numObjects","length","collisionMatrixTick","temp","reset","tick","add","addBody","indexOf","index","push","world","initPosition","position","initVelocity","velocity","timeLastSleepy","initAngularVelocity","angularVelocity","initQuaternion","quaternion","setNumObjects","dispatchEvent","addConstraint","c","removeConstraint","idx","splice","rayTest","from","to","result","raycastClosest","skipBackfaces","raycastAll","callback","mode","ALL","intersectWorld","raycastAny","ANY","CLOSEST","remove","n","i","removeBody","getBodyById","getShapeById","bl","shapes","j","sl","shape","addMaterial","m","addContactMaterial","cmat","set","performance","now","nowOffset","Date","timing","navigationStart","step_tmp1","step","timeSinceLastCalled","maxSubSteps","internalStep","substeps","t","b","previousPosition","lerp","interpolatedPosition","previousQuaternion","slerp","interpolatedQuaternion","normalize","World_step_postStepEvent","World_step_preStepEvent","World_step_collideEvent","COLLIDE_EVENT_NAME","contact","World_step_oldContacts","World_step_frictionEquationPool","World_step_p1","World_step_p2","World_step_gvec","World_step_vi","World_step_vj","World_step_wi","World_step_wj","World_step_t1","World_step_t2","World_step_rixn","World_step_rjxn","World_step_step_q","World_step_step_w","World_step_step_wq","invI_tau_dt","that","p1","p2","N","DYNAMIC","profilingStart","frictionEquationPool","gnorm","norm","gx","x","gy","y","gz","z","bi","f","force","mass","Nsubsystems","update","collisionPairs","Nconstraints","collideConnected","bodyA","bodyB","oldcontacts","NoldContacts","NoldFrictionEquations","getContacts","addEquation","ncontacts","k","bj","si","sj","cm","material","mu","sleepState","SLEEPING","AWAKE","STATIC","speedSquaredB","norm2","speedLimitSquaredB","Math","pow","sleepSpeedLimit","_wakeUpAfterNarrowphase","speedSquaredA","speedLimitSquaredA","emitContactEvents","wakeUp","Neq","equations","eq","removeAllEquations","ld","linearDamping","v","mult","av","ad","angularDamping","preStep","call","quatNormalize","clearForces","dirty","postStep","sleepTick","additions","removals","beginContactEvent","endContactEvent","beginShapeContactEvent","shapeA","shapeB","endShapeContactEvent","hasBeginContact","hasAnyEventListener","hasEndContact","getDiff","l","hasBeginShapeContact","hasEndShapeContact","tau","torque"],"mappings":"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","sourcesContent":["/* global performance */\n\nmodule.exports = World;\n\nvar Shape = require('../shapes/Shape');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar GSSolver = require('../solver/GSSolver');\nvar ContactEquation = require('../equations/ContactEquation');\nvar FrictionEquation = require('../equations/FrictionEquation');\nvar Narrowphase = require('./Narrowphase');\nvar EventTarget = require('../utils/EventTarget');\nvar ArrayCollisionMatrix = require('../collision/ArrayCollisionMatrix');\nvar OverlapKeeper = require('../collision/OverlapKeeper');\nvar Material = require('../material/Material');\nvar ContactMaterial = require('../material/ContactMaterial');\nvar Body = require('../objects/Body');\nvar TupleDictionary = require('../utils/TupleDictionary');\nvar RaycastResult = require('../collision/RaycastResult');\nvar AABB = require('../collision/AABB');\nvar Ray = require('../collision/Ray');\nvar NaiveBroadphase = require('../collision/NaiveBroadphase');\n\n/**\n * The physics world\n * @class World\n * @constructor\n * @extends EventTarget\n * @param {object} [options]\n * @param {Vec3} [options.gravity]\n * @param {boolean} [options.allowSleep]\n * @param {Broadphase} [options.broadphase]\n * @param {Solver} [options.solver]\n * @param {boolean} [options.quatNormalizeFast]\n * @param {number} [options.quatNormalizeSkip]\n */\nfunction World(options){\n    options = options || {};\n    EventTarget.apply(this);\n\n    /**\n     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is \"fresh\" inside event callbacks.\n     * @property {Number} dt\n     */\n    this.dt = -1;\n\n    /**\n     * Makes bodies go to sleep when they've been inactive\n     * @property allowSleep\n     * @type {Boolean}\n     * @default false\n     */\n    this.allowSleep = !!options.allowSleep;\n\n    /**\n     * All the current contacts (instances of ContactEquation) in the world.\n     * @property contacts\n     * @type {Array}\n     */\n    this.contacts = [];\n    this.frictionEquations = [];\n\n    /**\n     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).\n     * @property quatNormalizeSkip\n     * @type {Number}\n     * @default 0\n     */\n    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;\n\n    /**\n     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.\n     * @property quatNormalizeFast\n     * @type {Boolean}\n     * @see Quaternion.normalizeFast\n     * @see Quaternion.normalize\n     * @default false\n     */\n    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;\n\n    /**\n     * The wall-clock time since simulation start\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n\n    /**\n     * Number of timesteps taken since start\n     * @property stepnumber\n     * @type {Number}\n     */\n    this.stepnumber = 0;\n\n    /// Default and last timestep sizes\n    this.default_dt = 1/60;\n\n    this.nextId = 0;\n    /**\n     * @property gravity\n     * @type {Vec3}\n     */\n    this.gravity = new Vec3();\n    if(options.gravity){\n        this.gravity.copy(options.gravity);\n    }\n\n    /**\n     * The broadphase algorithm to use. Default is NaiveBroadphase\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();\n\n    /**\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n\n    /**\n     * The solver algorithm to use. Default is GSSolver\n     * @property solver\n     * @type {Solver}\n     */\n    this.solver = options.solver !== undefined ? options.solver : new GSSolver();\n\n    /**\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase(this);\n\n    /**\n     * @property {ArrayCollisionMatrix} collisionMatrix\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrix = new ArrayCollisionMatrix();\n\n    /**\n     * CollisionMatrix from the previous step.\n     * @property {ArrayCollisionMatrix} collisionMatrixPrevious\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrixPrevious = new ArrayCollisionMatrix();\n\n    this.bodyOverlapKeeper = new OverlapKeeper();\n    this.shapeOverlapKeeper = new OverlapKeeper();\n\n    /**\n     * All added materials\n     * @property materials\n     * @type {Array}\n     */\n    this.materials = [];\n\n    /**\n     * @property contactmaterials\n     * @type {Array}\n     */\n    this.contactmaterials = [];\n\n    /**\n     * Used to look up a ContactMaterial given two instances of Material.\n     * @property {TupleDictionary} contactMaterialTable\n     */\n    this.contactMaterialTable = new TupleDictionary();\n\n    this.defaultMaterial = new Material(\"default\");\n\n    /**\n     * This contact material is used if no suitable contactmaterial is found for a contact.\n     * @property defaultContactMaterial\n     * @type {ContactMaterial}\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });\n\n    /**\n     * @property doProfiling\n     * @type {Boolean}\n     */\n    this.doProfiling = false;\n\n    /**\n     * @property profile\n     * @type {Object}\n     */\n    this.profile = {\n        solve:0,\n        makeContactConstraints:0,\n        broadphase:0,\n        integrate:0,\n        narrowphase:0,\n    };\n\n    /**\n     * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/\n     * @property {Number} accumulator\n     */\n    this.accumulator = 0;\n\n    /**\n     * @property subsystems\n     * @type {Array}\n     */\n    this.subsystems = [];\n\n    /**\n     * Dispatched after a body has been added to the world.\n     * @event addBody\n     * @param {Body} body The body that has been added to the world.\n     */\n    this.addBodyEvent = {\n        type:\"addBody\",\n        body : null\n    };\n\n    /**\n     * Dispatched after a body has been removed from the world.\n     * @event removeBody\n     * @param {Body} body The body that has been removed from the world.\n     */\n    this.removeBodyEvent = {\n        type:\"removeBody\",\n        body : null\n    };\n\n    this.idToBodyMap = {};\n\n    this.broadphase.setWorld(this);\n}\nWorld.prototype = new EventTarget();\n\n// Temp stuff\nvar tmpAABB1 = new AABB();\nvar tmpArray1 = [];\nvar tmpRay = new Ray();\n\n/**\n * Get the contact material between materials m1 and m2\n * @method getContactMaterial\n * @param {Material} m1\n * @param {Material} m2\n * @return {ContactMaterial} The contact material if it was found.\n */\nWorld.prototype.getContactMaterial = function(m1,m2){\n    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];\n};\n\n/**\n * Get number of objects in the world.\n * @method numObjects\n * @return {Number}\n * @deprecated\n */\nWorld.prototype.numObjects = function(){\n    return this.bodies.length;\n};\n\n/**\n * Store old collision state info\n * @method collisionMatrixTick\n */\nWorld.prototype.collisionMatrixTick = function(){\n\tvar temp = this.collisionMatrixPrevious;\n\tthis.collisionMatrixPrevious = this.collisionMatrix;\n\tthis.collisionMatrix = temp;\n\tthis.collisionMatrix.reset();\n\n    this.bodyOverlapKeeper.tick();\n    this.shapeOverlapKeeper.tick();\n};\n\n/**\n * Add a rigid body to the simulation.\n * @method add\n * @param {Body} body\n * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.\n * @todo Adding an array of bodies should be possible. This would save some loops too\n * @deprecated Use .addBody instead\n */\nWorld.prototype.add = World.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) !== -1){\n        return;\n    }\n    body.index = this.bodies.length;\n    this.bodies.push(body);\n    body.world = this;\n    body.initPosition.copy(body.position);\n    body.initVelocity.copy(body.velocity);\n    body.timeLastSleepy = this.time;\n    if(body instanceof Body){\n        body.initAngularVelocity.copy(body.angularVelocity);\n        body.initQuaternion.copy(body.quaternion);\n    }\n\tthis.collisionMatrix.setNumObjects(this.bodies.length);\n    this.addBodyEvent.body = body;\n    this.idToBodyMap[body.id] = body;\n    this.dispatchEvent(this.addBodyEvent);\n};\n\n/**\n * Add a constraint to the simulation.\n * @method addConstraint\n * @param {Constraint} c\n */\nWorld.prototype.addConstraint = function(c){\n    this.constraints.push(c);\n};\n\n/**\n * Removes a constraint\n * @method removeConstraint\n * @param {Constraint} c\n */\nWorld.prototype.removeConstraint = function(c){\n    var idx = this.constraints.indexOf(c);\n    if(idx!==-1){\n        this.constraints.splice(idx,1);\n    }\n};\n\n/**\n * Raycast test\n * @method rayTest\n * @param {Vec3} from\n * @param {Vec3} to\n * @param {RaycastResult} result\n * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.\n */\nWorld.prototype.rayTest = function(from, to, result){\n    if(result instanceof RaycastResult){\n        // Do raycastclosest\n        this.raycastClosest(from, to, {\n            skipBackfaces: true\n        }, result);\n    } else {\n        // Do raycastAll\n        this.raycastAll(from, to, {\n            skipBackfaces: true\n        }, result);\n    }\n};\n\n/**\n * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.\n * @method raycastAll\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {Function} callback\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastAll = function(from, to, options, callback){\n    options.mode = Ray.ALL;\n    options.from = from;\n    options.to = to;\n    options.callback = callback;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.\n * @method raycastAny\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastAny = function(from, to, options, result){\n    options.mode = Ray.ANY;\n    options.from = from;\n    options.to = to;\n    options.result = result;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Ray cast, and return information of the closest hit.\n * @method raycastClosest\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastClosest = function(from, to, options, result){\n    options.mode = Ray.CLOSEST;\n    options.from = from;\n    options.to = to;\n    options.result = result;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Remove a rigid body from the simulation.\n * @method remove\n * @param {Body} body\n * @deprecated Use .removeBody instead\n */\nWorld.prototype.remove = function(body){\n    body.world = null;\n    var n = this.bodies.length - 1,\n        bodies = this.bodies,\n        idx = bodies.indexOf(body);\n    if(idx !== -1){\n        bodies.splice(idx, 1); // Todo: should use a garbage free method\n\n        // Recompute index\n        for(var i=0; i!==bodies.length; i++){\n            bodies[i].index = i;\n        }\n\n        this.collisionMatrix.setNumObjects(n);\n        this.removeBodyEvent.body = body;\n        delete this.idToBodyMap[body.id];\n        this.dispatchEvent(this.removeBodyEvent);\n    }\n};\n\n/**\n * Remove a rigid body from the simulation.\n * @method removeBody\n * @param {Body} body\n */\nWorld.prototype.removeBody = World.prototype.remove;\n\nWorld.prototype.getBodyById = function(id){\n    return this.idToBodyMap[id];\n};\n\n// TODO Make a faster map\nWorld.prototype.getShapeById = function(id){\n    var bodies = this.bodies;\n    for(var i=0, bl = bodies.length; i<bl; i++){\n        var shapes = bodies[i].shapes;\n        for (var j = 0, sl = shapes.length; j < sl; j++) {\n            var shape = shapes[j];\n            if(shape.id === id){\n                return shape;\n            }\n        }\n    }\n};\n\n/**\n * Adds a material to the World.\n * @method addMaterial\n * @param {Material} m\n * @todo Necessary?\n */\nWorld.prototype.addMaterial = function(m){\n    this.materials.push(m);\n};\n\n/**\n * Adds a contact material to the World\n * @method addContactMaterial\n * @param {ContactMaterial} cmat\n */\nWorld.prototype.addContactMaterial = function(cmat) {\n\n    // Add contact material\n    this.contactmaterials.push(cmat);\n\n    // Add current contact material to the material table\n    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);\n};\n\n// performance.now()\nif(typeof performance === 'undefined'){\n    performance = {};\n}\nif(!performance.now){\n    var nowOffset = Date.now();\n    if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n    }\n    performance.now = function(){\n        return Date.now() - nowOffset;\n    };\n}\n\nvar step_tmp1 = new Vec3();\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // fixed timestepping without interpolation\n *     world.step(1/60);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        this.accumulator += timeSinceLastCalled;\n        var substeps = 0;\n        while (this.accumulator >= dt && substeps < maxSubSteps) {\n            // Do fixed steps to catch up\n            this.internalStep(dt);\n            this.accumulator -= dt;\n            substeps++;\n        }\n\n        var t = (this.accumulator % dt) / dt;\n        for(var j=0; j !== this.bodies.length; j++){\n            var b = this.bodies[j];\n            b.previousPosition.lerp(b.position, t, b.interpolatedPosition);\n            b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);\n            b.previousQuaternion.normalize();\n        }\n        this.time += timeSinceLastCalled;\n    }\n};\n\nvar\n    /**\n     * Dispatched after the world has stepped forward in time.\n     * @event postStep\n     */\n    World_step_postStepEvent = {type:\"postStep\"}, // Reusable event objects to save memory\n    /**\n     * Dispatched before the world steps forward in time.\n     * @event preStep\n     */\n    World_step_preStepEvent = {type:\"preStep\"},\n    World_step_collideEvent = {type:Body.COLLIDE_EVENT_NAME, body:null, contact:null },\n    World_step_oldContacts = [], // Pools for unused objects\n    World_step_frictionEquationPool = [],\n    World_step_p1 = [], // Reusable arrays for collision pairs\n    World_step_p2 = [],\n    World_step_gvec = new Vec3(), // Temporary vectors and quats\n    World_step_vi = new Vec3(),\n    World_step_vj = new Vec3(),\n    World_step_wi = new Vec3(),\n    World_step_wj = new Vec3(),\n    World_step_t1 = new Vec3(),\n    World_step_t2 = new Vec3(),\n    World_step_rixn = new Vec3(),\n    World_step_rjxn = new Vec3(),\n    World_step_step_q = new Quaternion(),\n    World_step_step_w = new Quaternion(),\n    World_step_step_wq = new Quaternion(),\n    invI_tau_dt = new Vec3();\nWorld.prototype.internalStep = function(dt){\n    this.dt = dt;\n\n    var world = this,\n        that = this,\n        contacts = this.contacts,\n        p1 = World_step_p1,\n        p2 = World_step_p2,\n        N = this.numObjects(),\n        bodies = this.bodies,\n        solver = this.solver,\n        gravity = this.gravity,\n        doProfiling = this.doProfiling,\n        profile = this.profile,\n        DYNAMIC = Body.DYNAMIC,\n        profilingStart,\n        constraints = this.constraints,\n        frictionEquationPool = World_step_frictionEquationPool,\n        gnorm = gravity.norm(),\n        gx = gravity.x,\n        gy = gravity.y,\n        gz = gravity.z,\n        i=0;\n\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n\n    // Add gravity to all objects\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type === DYNAMIC){ // Only for dynamic bodies\n            var f = bi.force, m = bi.mass;\n            f.x += m*gx;\n            f.y += m*gy;\n            f.z += m*gz;\n        }\n    }\n\n    // Update subsystems\n    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){\n        this.subsystems[i].update();\n    }\n\n    // Collision detection\n    if(doProfiling){ profilingStart = performance.now(); }\n    p1.length = 0; // Clean up pair arrays from last step\n    p2.length = 0;\n    this.broadphase.collisionPairs(this,p1,p2);\n    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j = p1.length-1; j>=0; j-=1){\n                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||\n                    (c.bodyB === p1[j] && c.bodyA === p2[j])){\n                    p1.splice(j, 1);\n                    p2.splice(j, 1);\n                }\n            }\n        }\n    }\n\n    this.collisionMatrixTick();\n\n    // Generate contacts\n    if(doProfiling){ profilingStart = performance.now(); }\n    var oldcontacts = World_step_oldContacts;\n    var NoldContacts = contacts.length;\n\n    for(i=0; i!==NoldContacts; i++){\n        oldcontacts.push(contacts[i]);\n    }\n    contacts.length = 0;\n\n    // Transfer FrictionEquation from current list to the pool for reuse\n    var NoldFrictionEquations = this.frictionEquations.length;\n    for(i=0; i!==NoldFrictionEquations; i++){\n        frictionEquationPool.push(this.frictionEquations[i]);\n    }\n    this.frictionEquations.length = 0;\n\n    this.narrowphase.getContacts(\n        p1,\n        p2,\n        this,\n        contacts,\n        oldcontacts, // To be reused\n        this.frictionEquations,\n        frictionEquationPool\n    );\n\n    if(doProfiling){\n        profile.narrowphase = performance.now() - profilingStart;\n    }\n\n    // Loop over all collisions\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n\n    // Add all friction eqs\n    for (var i = 0; i < this.frictionEquations.length; i++) {\n        solver.addEquation(this.frictionEquations[i]);\n    }\n\n    var ncontacts = contacts.length;\n    for(var k=0; k!==ncontacts; k++){\n\n        // Current contact\n        var c = contacts[k];\n\n        // Get current collision indeces\n        var bi = c.bi,\n            bj = c.bj,\n            si = c.si,\n            sj = c.sj;\n\n        // Get collision properties\n        var cm;\n        if(bi.material && bj.material){\n            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;\n        } else {\n            cm = this.defaultContactMaterial;\n        }\n\n        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n        var mu = cm.friction;\n        // c.restitution = cm.restitution;\n\n        // If friction or restitution were specified in the material, use them\n        if(bi.material && bj.material){\n            if(bi.material.friction >= 0 && bj.material.friction >= 0){\n                mu = bi.material.friction * bj.material.friction;\n            }\n\n            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){\n                c.restitution = bi.material.restitution * bj.material.restitution;\n            }\n        }\n\n\t\t// c.setSpookParams(\n  //           cm.contactEquationStiffness,\n  //           cm.contactEquationRelaxation,\n  //           dt\n  //       );\n\n\t\tsolver.addEquation(c);\n\n\t\t// // Add friction constraint equation\n\t\t// if(mu > 0){\n\n\t\t// \t// Create 2 tangent equations\n\t\t// \tvar mug = mu * gnorm;\n\t\t// \tvar reducedMass = (bi.invMass + bj.invMass);\n\t\t// \tif(reducedMass > 0){\n\t\t// \t\treducedMass = 1/reducedMass;\n\t\t// \t}\n\t\t// \tvar pool = frictionEquationPool;\n\t\t// \tvar c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t// \tvar c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t// \tthis.frictionEquations.push(c1, c2);\n\n\t\t// \tc1.bi = c2.bi = bi;\n\t\t// \tc1.bj = c2.bj = bj;\n\t\t// \tc1.minForce = c2.minForce = -mug*reducedMass;\n\t\t// \tc1.maxForce = c2.maxForce = mug*reducedMass;\n\n\t\t// \t// Copy over the relative vectors\n\t\t// \tc1.ri.copy(c.ri);\n\t\t// \tc1.rj.copy(c.rj);\n\t\t// \tc2.ri.copy(c.ri);\n\t\t// \tc2.rj.copy(c.rj);\n\n\t\t// \t// Construct tangents\n\t\t// \tc.ni.tangents(c1.t, c2.t);\n\n  //           // Set spook params\n  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n\n  //           c1.enabled = c2.enabled = c.enabled;\n\n\t\t// \t// Add equations to solver\n\t\t// \tsolver.addEquation(c1);\n\t\t// \tsolver.addEquation(c2);\n\t\t// }\n\n        if( bi.allowSleep &&\n            bi.type === Body.DYNAMIC &&\n            bi.sleepState  === Body.SLEEPING &&\n            bj.sleepState  === Body.AWAKE &&\n            bj.type !== Body.STATIC\n        ){\n            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();\n            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n            if(speedSquaredB >= speedLimitSquaredB*2){\n                bi._wakeUpAfterNarrowphase = true;\n            }\n        }\n\n        if( bj.allowSleep &&\n            bj.type === Body.DYNAMIC &&\n            bj.sleepState  === Body.SLEEPING &&\n            bi.sleepState  === Body.AWAKE &&\n            bi.type !== Body.STATIC\n        ){\n            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();\n            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n            if(speedSquaredA >= speedLimitSquaredA*2){\n                bj._wakeUpAfterNarrowphase = true;\n            }\n        }\n\n        // Now we know that i and j are in contact. Set collision matrix state\n\t\tthis.collisionMatrix.set(bi, bj, true);\n\n        if (!this.collisionMatrixPrevious.get(bi, bj)) {\n            // First contact!\n            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.\n            World_step_collideEvent.body = bj;\n            World_step_collideEvent.contact = c;\n            bi.dispatchEvent(World_step_collideEvent);\n\n            World_step_collideEvent.body = bi;\n            bj.dispatchEvent(World_step_collideEvent);\n        }\n\n        this.bodyOverlapKeeper.set(bi.id, bj.id);\n        this.shapeOverlapKeeper.set(si.id, sj.id);\n    }\n\n    this.emitContactEvents();\n\n    if(doProfiling){\n        profile.makeContactConstraints = performance.now() - profilingStart;\n        profilingStart = performance.now();\n    }\n\n    // Wake up bodies\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi._wakeUpAfterNarrowphase){\n            bi.wakeUp();\n            bi._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Add user-added constraints\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        c.update();\n        for(var j=0, Neq=c.equations.length; j!==Neq; j++){\n            var eq = c.equations[j];\n            solver.addEquation(eq);\n        }\n    }\n\n    // Solve the constrained system\n    solver.solve(dt,this);\n\n    if(doProfiling){\n        profile.solve = performance.now() - profilingStart;\n    }\n\n    // Remove all contacts from solver\n    solver.removeAllEquations();\n\n    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details\n    var pow = Math.pow;\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type & DYNAMIC){ // Only for dynamic bodies\n            var ld = pow(1.0 - bi.linearDamping,dt);\n            var v = bi.velocity;\n            v.mult(ld,v);\n            var av = bi.angularVelocity;\n            if(av){\n                var ad = pow(1.0 - bi.angularDamping,dt);\n                av.mult(ad,av);\n            }\n        }\n    }\n\n    this.dispatchEvent(World_step_preStepEvent);\n\n    // Invoke pre-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.preStep){\n            bi.preStep.call(bi);\n        }\n    }\n\n    // Leap frog\n    // vnew = v + h*f/m\n    // xnew = x + h*vnew\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n    var stepnumber = this.stepnumber;\n    var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;\n    var quatNormalizeFast = this.quatNormalizeFast;\n\n    for(i=0; i!==N; i++){\n        bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);\n    }\n    this.clearForces();\n\n    this.broadphase.dirty = true;\n\n    if(doProfiling){\n        profile.integrate = performance.now() - profilingStart;\n    }\n\n    // Update world time\n    this.time += dt;\n    this.stepnumber += 1;\n\n    this.dispatchEvent(World_step_postStepEvent);\n\n    // Invoke post-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        var postStep = bi.postStep;\n        if(postStep){\n            postStep.call(bi);\n        }\n    }\n\n    // Sleeping update\n    if(this.allowSleep){\n        for(i=0; i!==N; i++){\n            bodies[i].sleepTick(this.time);\n        }\n    }\n};\n\nWorld.prototype.emitContactEvents = (function(){\n    var additions = [];\n    var removals = [];\n    var beginContactEvent = {\n        type: 'beginContact',\n        bodyA: null,\n        bodyB: null\n    };\n    var endContactEvent = {\n        type: 'endContact',\n        bodyA: null,\n        bodyB: null\n    };\n    var beginShapeContactEvent = {\n        type: 'beginShapeContact',\n        bodyA: null,\n        bodyB: null,\n        shapeA: null,\n        shapeB: null\n    };\n    var endShapeContactEvent = {\n        type: 'endShapeContact',\n        bodyA: null,\n        bodyB: null,\n        shapeA: null,\n        shapeB: null\n    };\n    return function(){\n        var hasBeginContact = this.hasAnyEventListener('beginContact');\n        var hasEndContact = this.hasAnyEventListener('endContact');\n\n        if(hasBeginContact || hasEndContact){\n            this.bodyOverlapKeeper.getDiff(additions, removals);\n        }\n\n        if(hasBeginContact){\n            for (var i = 0, l = additions.length; i < l; i += 2) {\n                beginContactEvent.bodyA = this.getBodyById(additions[i]);\n                beginContactEvent.bodyB = this.getBodyById(additions[i+1]);\n                this.dispatchEvent(beginContactEvent);\n            }\n            beginContactEvent.bodyA = beginContactEvent.bodyB = null;\n        }\n\n        if(hasEndContact){\n            for (var i = 0, l = removals.length; i < l; i += 2) {\n                endContactEvent.bodyA = this.getBodyById(removals[i]);\n                endContactEvent.bodyB = this.getBodyById(removals[i+1]);\n                this.dispatchEvent(endContactEvent);\n            }\n            endContactEvent.bodyA = endContactEvent.bodyB = null;\n        }\n\n        additions.length = removals.length = 0;\n\n        var hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');\n        var hasEndShapeContact = this.hasAnyEventListener('endShapeContact');\n\n        if(hasBeginShapeContact || hasEndShapeContact){\n            this.shapeOverlapKeeper.getDiff(additions, removals);\n        }\n\n        if(hasBeginShapeContact){\n            for (var i = 0, l = additions.length; i < l; i += 2) {\n                var shapeA = this.getShapeById(additions[i]);\n                var shapeB = this.getShapeById(additions[i+1]);\n                beginShapeContactEvent.shapeA = shapeA;\n                beginShapeContactEvent.shapeB = shapeB;\n                beginShapeContactEvent.bodyA = shapeA.body;\n                beginShapeContactEvent.bodyB = shapeB.body;\n                this.dispatchEvent(beginShapeContactEvent);\n            }\n            beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;\n        }\n\n        if(hasEndShapeContact){\n            for (var i = 0, l = removals.length; i < l; i += 2) {\n                var shapeA = this.getShapeById(removals[i]);\n                var shapeB = this.getShapeById(removals[i+1]);\n                endShapeContactEvent.shapeA = shapeA;\n                endShapeContactEvent.shapeB = shapeB;\n                endShapeContactEvent.bodyA = shapeA.body;\n                endShapeContactEvent.bodyB = shapeB.body;\n                this.dispatchEvent(endShapeContactEvent);\n            }\n            endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;\n        }\n\n    };\n})();\n\n/**\n * Sets all body forces in the world to zero.\n * @method clearForces\n */\nWorld.prototype.clearForces = function(){\n    var bodies = this.bodies;\n    var N = bodies.length;\n    for(var i=0; i !== N; i++){\n        var b = bodies[i],\n            force = b.force,\n            tau = b.torque;\n\n        b.force.set(0,0,0);\n        b.torque.set(0,0,0);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}