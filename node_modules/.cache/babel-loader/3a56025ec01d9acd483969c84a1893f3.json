{"ast":null,"code":"module.exports = SplitSolver;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Solver = require('./Solver');\n\nvar Body = require('../objects/Body');\n/**\n * Splits the equations into islands and solves them independently. Can improve performance.\n * @class SplitSolver\n * @constructor\n * @extends Solver\n * @param {Solver} subsolver\n */\n\n\nfunction SplitSolver(subsolver) {\n  Solver.call(this);\n  this.iterations = 10;\n  this.tolerance = 1e-7;\n  this.subsolver = subsolver;\n  this.nodes = [];\n  this.nodePool = []; // Create needed nodes, reuse if possible\n\n  while (this.nodePool.length < 128) {\n    this.nodePool.push(this.createNode());\n  }\n}\n\nSplitSolver.prototype = new Solver(); // Returns the number of subsystems\n\nvar SplitSolver_solve_nodes = []; // All allocated node objects\n\nvar SplitSolver_solve_nodePool = []; // All allocated node objects\n\nvar SplitSolver_solve_eqs = []; // Temp array\n\nvar SplitSolver_solve_bds = []; // Temp array\n\nvar SplitSolver_solve_dummyWorld = {\n  bodies: []\n}; // Temp object\n\nvar STATIC = Body.STATIC;\n\nfunction getUnvisitedNode(nodes) {\n  var Nnodes = nodes.length;\n\n  for (var i = 0; i !== Nnodes; i++) {\n    var node = nodes[i];\n\n    if (!node.visited && !(node.body.type & STATIC)) {\n      return node;\n    }\n  }\n\n  return false;\n}\n\nvar queue = [];\n\nfunction bfs(root, visitFunc, bds, eqs) {\n  queue.push(root);\n  root.visited = true;\n  visitFunc(root, bds, eqs);\n\n  while (queue.length) {\n    var node = queue.pop(); // Loop over unvisited child nodes\n\n    var child;\n\n    while (child = getUnvisitedNode(node.children)) {\n      child.visited = true;\n      visitFunc(child, bds, eqs);\n      queue.push(child);\n    }\n  }\n}\n\nfunction visitFunc(node, bds, eqs) {\n  bds.push(node.body);\n  var Neqs = node.eqs.length;\n\n  for (var i = 0; i !== Neqs; i++) {\n    var eq = node.eqs[i];\n\n    if (eqs.indexOf(eq) === -1) {\n      eqs.push(eq);\n    }\n  }\n}\n\nSplitSolver.prototype.createNode = function () {\n  return {\n    body: null,\n    children: [],\n    eqs: [],\n    visited: false\n  };\n};\n/**\n * Solve the subsystems\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\n\n\nSplitSolver.prototype.solve = function (dt, world) {\n  var nodes = SplitSolver_solve_nodes,\n      nodePool = this.nodePool,\n      bodies = world.bodies,\n      equations = this.equations,\n      Neq = equations.length,\n      Nbodies = bodies.length,\n      subsolver = this.subsolver; // Create needed nodes, reuse if possible\n\n  while (nodePool.length < Nbodies) {\n    nodePool.push(this.createNode());\n  }\n\n  nodes.length = Nbodies;\n\n  for (var i = 0; i < Nbodies; i++) {\n    nodes[i] = nodePool[i];\n  } // Reset node values\n\n\n  for (var i = 0; i !== Nbodies; i++) {\n    var node = nodes[i];\n    node.body = bodies[i];\n    node.children.length = 0;\n    node.eqs.length = 0;\n    node.visited = false;\n  }\n\n  for (var k = 0; k !== Neq; k++) {\n    var eq = equations[k],\n        i = bodies.indexOf(eq.bi),\n        j = bodies.indexOf(eq.bj),\n        ni = nodes[i],\n        nj = nodes[j];\n    ni.children.push(nj);\n    ni.eqs.push(eq);\n    nj.children.push(ni);\n    nj.eqs.push(eq);\n  }\n\n  var child,\n      n = 0,\n      eqs = SplitSolver_solve_eqs;\n  subsolver.tolerance = this.tolerance;\n  subsolver.iterations = this.iterations;\n  var dummyWorld = SplitSolver_solve_dummyWorld;\n\n  while (child = getUnvisitedNode(nodes)) {\n    eqs.length = 0;\n    dummyWorld.bodies.length = 0;\n    bfs(child, visitFunc, dummyWorld.bodies, eqs);\n    var Neqs = eqs.length;\n    eqs = eqs.sort(sortById);\n\n    for (var i = 0; i !== Neqs; i++) {\n      subsolver.addEquation(eqs[i]);\n    }\n\n    var iter = subsolver.solve(dt, dummyWorld);\n    subsolver.removeAllEquations();\n    n++;\n  }\n\n  return n;\n};\n\nfunction sortById(a, b) {\n  return b.id - a.id;\n}","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/solver/SplitSolver.js"],"names":["module","exports","SplitSolver","Vec3","require","Quaternion","Solver","Body","subsolver","call","iterations","tolerance","nodes","nodePool","length","push","createNode","prototype","SplitSolver_solve_nodes","SplitSolver_solve_nodePool","SplitSolver_solve_eqs","SplitSolver_solve_bds","SplitSolver_solve_dummyWorld","bodies","STATIC","getUnvisitedNode","Nnodes","i","node","visited","body","type","queue","bfs","root","visitFunc","bds","eqs","pop","child","children","Neqs","eq","indexOf","solve","dt","world","equations","Neq","Nbodies","k","bi","j","bj","ni","nj","n","dummyWorld","sort","sortById","addEquation","iter","removeAllEquations","a","b","id"],"mappings":"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","sourcesContent":["module.exports = SplitSolver;\n\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Solver = require('./Solver');\nvar Body = require('../objects/Body');\n\n/**\n * Splits the equations into islands and solves them independently. Can improve performance.\n * @class SplitSolver\n * @constructor\n * @extends Solver\n * @param {Solver} subsolver\n */\nfunction SplitSolver(subsolver){\n    Solver.call(this);\n    this.iterations = 10;\n    this.tolerance = 1e-7;\n    this.subsolver = subsolver;\n    this.nodes = [];\n    this.nodePool = [];\n\n    // Create needed nodes, reuse if possible\n    while(this.nodePool.length < 128){\n        this.nodePool.push(this.createNode());\n    }\n}\nSplitSolver.prototype = new Solver();\n\n// Returns the number of subsystems\nvar SplitSolver_solve_nodes = []; // All allocated node objects\nvar SplitSolver_solve_nodePool = []; // All allocated node objects\nvar SplitSolver_solve_eqs = [];   // Temp array\nvar SplitSolver_solve_bds = [];   // Temp array\nvar SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object\n\nvar STATIC = Body.STATIC;\nfunction getUnvisitedNode(nodes){\n    var Nnodes = nodes.length;\n    for(var i=0; i!==Nnodes; i++){\n        var node = nodes[i];\n        if(!node.visited && !(node.body.type & STATIC)){\n            return node;\n        }\n    }\n    return false;\n}\n\nvar queue = [];\nfunction bfs(root,visitFunc,bds,eqs){\n    queue.push(root);\n    root.visited = true;\n    visitFunc(root,bds,eqs);\n    while(queue.length) {\n        var node = queue.pop();\n        // Loop over unvisited child nodes\n        var child;\n        while((child = getUnvisitedNode(node.children))) {\n            child.visited = true;\n            visitFunc(child,bds,eqs);\n            queue.push(child);\n        }\n    }\n}\n\nfunction visitFunc(node,bds,eqs){\n    bds.push(node.body);\n    var Neqs = node.eqs.length;\n    for(var i=0; i!==Neqs; i++){\n        var eq = node.eqs[i];\n        if(eqs.indexOf(eq) === -1){\n            eqs.push(eq);\n        }\n    }\n}\n\nSplitSolver.prototype.createNode = function(){\n    return { body:null, children:[], eqs:[], visited:false };\n};\n\n/**\n * Solve the subsystems\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSplitSolver.prototype.solve = function(dt,world){\n    var nodes=SplitSolver_solve_nodes,\n        nodePool=this.nodePool,\n        bodies=world.bodies,\n        equations=this.equations,\n        Neq=equations.length,\n        Nbodies=bodies.length,\n        subsolver=this.subsolver;\n\n    // Create needed nodes, reuse if possible\n    while(nodePool.length < Nbodies){\n        nodePool.push(this.createNode());\n    }\n    nodes.length = Nbodies;\n    for (var i = 0; i < Nbodies; i++) {\n        nodes[i] = nodePool[i];\n    }\n\n    // Reset node values\n    for(var i=0; i!==Nbodies; i++){\n        var node = nodes[i];\n        node.body = bodies[i];\n        node.children.length = 0;\n        node.eqs.length = 0;\n        node.visited = false;\n    }\n    for(var k=0; k!==Neq; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bi),\n            j=bodies.indexOf(eq.bj),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.children.push(nj);\n        ni.eqs.push(eq);\n        nj.children.push(ni);\n        nj.eqs.push(eq);\n    }\n\n    var child, n=0, eqs=SplitSolver_solve_eqs;\n\n    subsolver.tolerance = this.tolerance;\n    subsolver.iterations = this.iterations;\n\n    var dummyWorld = SplitSolver_solve_dummyWorld;\n    while((child = getUnvisitedNode(nodes))){\n        eqs.length = 0;\n        dummyWorld.bodies.length = 0;\n        bfs(child, visitFunc, dummyWorld.bodies, eqs);\n\n        var Neqs = eqs.length;\n\n        eqs = eqs.sort(sortById);\n\n        for(var i=0; i!==Neqs; i++){\n            subsolver.addEquation(eqs[i]);\n        }\n\n        var iter = subsolver.solve(dt,dummyWorld);\n        subsolver.removeAllEquations();\n        n++;\n    }\n\n    return n;\n};\n\nfunction sortById(a, b){\n    return b.id - a.id;\n}"]},"metadata":{},"sourceType":"script"}