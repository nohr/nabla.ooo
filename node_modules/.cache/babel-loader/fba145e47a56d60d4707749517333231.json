{"ast":null,"code":"module.exports = RotationalMotorEquation;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Mat3 = require('../math/Mat3');\n\nvar Equation = require('./Equation');\n/**\n * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.\n * @class RotationalMotorEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} maxForce\n * @extends Equation\n */\n\n\nfunction RotationalMotorEquation(bodyA, bodyB, maxForce) {\n  maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;\n  Equation.call(this, bodyA, bodyB, -maxForce, maxForce);\n  /**\n   * World oriented rotational axis\n   * @property {Vec3} axisA\n   */\n\n  this.axisA = new Vec3();\n  /**\n   * World oriented rotational axis\n   * @property {Vec3} axisB\n   */\n\n  this.axisB = new Vec3(); // World oriented rotational axis\n\n  /**\n   * Motor velocity\n   * @property {Number} targetVelocity\n   */\n\n  this.targetVelocity = 0;\n}\n\nRotationalMotorEquation.prototype = new Equation();\nRotationalMotorEquation.prototype.constructor = RotationalMotorEquation;\n\nRotationalMotorEquation.prototype.computeB = function (h) {\n  var a = this.a,\n      b = this.b,\n      bi = this.bi,\n      bj = this.bj,\n      axisA = this.axisA,\n      axisB = this.axisB,\n      GA = this.jacobianElementA,\n      GB = this.jacobianElementB; // g = 0\n  // gdot = axisA * wi - axisB * wj\n  // gdot = G * W = G * [vi wi vj wj]\n  // =>\n  // G = [0 axisA 0 -axisB]\n\n  GA.rotational.copy(axisA);\n  axisB.negate(GB.rotational);\n  var GW = this.computeGW() - this.targetVelocity,\n      GiMf = this.computeGiMf();\n  var B = -GW * b - h * GiMf;\n  return B;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/RotationalMotorEquation.js"],"names":["module","exports","RotationalMotorEquation","Vec3","require","Mat3","Equation","bodyA","bodyB","maxForce","call","axisA","axisB","targetVelocity","prototype","constructor","computeB","h","a","b","bi","bj","GA","jacobianElementA","GB","jacobianElementB","rotational","copy","negate","GW","computeGW","GiMf","computeGiMf","B"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,uBAAjB;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,CAAiCK,KAAjC,EAAwCC,KAAxC,EAA+CC,QAA/C,EAAwD;AACpDA,EAAAA,QAAQ,GAAG,OAAOA,QAAP,KAAmB,WAAnB,GAAiCA,QAAjC,GAA4C,GAAvD;AACAH,EAAAA,QAAQ,CAACI,IAAT,CAAc,IAAd,EAAmBH,KAAnB,EAAyBC,KAAzB,EAA+B,CAACC,QAAhC,EAAyCA,QAAzC;AAEA;AACJ;AACA;AACA;;AACI,OAAKE,KAAL,GAAa,IAAIR,IAAJ,EAAb;AAEA;AACJ;AACA;AACA;;AACI,OAAKS,KAAL,GAAa,IAAIT,IAAJ,EAAb,CAdoD,CAc3B;;AAEzB;AACJ;AACA;AACA;;AACI,OAAKU,cAAL,GAAsB,CAAtB;AACH;;AAEDX,uBAAuB,CAACY,SAAxB,GAAoC,IAAIR,QAAJ,EAApC;AACAJ,uBAAuB,CAACY,SAAxB,CAAkCC,WAAlC,GAAgDb,uBAAhD;;AAEAA,uBAAuB,CAACY,SAAxB,CAAkCE,QAAlC,GAA6C,UAASC,CAAT,EAAW;AACpD,MAAIC,CAAC,GAAG,KAAKA,CAAb;AAAA,MACIC,CAAC,GAAG,KAAKA,CADb;AAAA,MAEIC,EAAE,GAAG,KAAKA,EAFd;AAAA,MAGIC,EAAE,GAAG,KAAKA,EAHd;AAAA,MAKIV,KAAK,GAAG,KAAKA,KALjB;AAAA,MAMIC,KAAK,GAAG,KAAKA,KANjB;AAAA,MAQIU,EAAE,GAAG,KAAKC,gBARd;AAAA,MASIC,EAAE,GAAG,KAAKC,gBATd,CADoD,CAYpD;AACA;AACA;AACA;AACA;;AAEAH,EAAAA,EAAE,CAACI,UAAH,CAAcC,IAAd,CAAmBhB,KAAnB;AACAC,EAAAA,KAAK,CAACgB,MAAN,CAAaJ,EAAE,CAACE,UAAhB;AAEA,MAAIG,EAAE,GAAG,KAAKC,SAAL,KAAmB,KAAKjB,cAAjC;AAAA,MACIkB,IAAI,GAAG,KAAKC,WAAL,EADX;AAGA,MAAIC,CAAC,GAAG,CAAEJ,EAAF,GAAOV,CAAP,GAAWF,CAAC,GAAGc,IAAvB;AAEA,SAAOE,CAAP;AACH,CA3BD","sourcesContent":["module.exports = RotationalMotorEquation;\n\nvar Vec3 = require('../math/Vec3');\nvar Mat3 = require('../math/Mat3');\nvar Equation = require('./Equation');\n\n/**\n * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.\n * @class RotationalMotorEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} maxForce\n * @extends Equation\n */\nfunction RotationalMotorEquation(bodyA, bodyB, maxForce){\n    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;\n    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);\n\n    /**\n     * World oriented rotational axis\n     * @property {Vec3} axisA\n     */\n    this.axisA = new Vec3();\n\n    /**\n     * World oriented rotational axis\n     * @property {Vec3} axisB\n     */\n    this.axisB = new Vec3(); // World oriented rotational axis\n\n    /**\n     * Motor velocity\n     * @property {Number} targetVelocity\n     */\n    this.targetVelocity = 0;\n}\n\nRotationalMotorEquation.prototype = new Equation();\nRotationalMotorEquation.prototype.constructor = RotationalMotorEquation;\n\nRotationalMotorEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n\n        axisA = this.axisA,\n        axisB = this.axisB,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // g = 0\n    // gdot = axisA * wi - axisB * wj\n    // gdot = G * W = G * [vi wi vj wj]\n    // =>\n    // G = [0 axisA 0 -axisB]\n\n    GA.rotational.copy(axisA);\n    axisB.negate(GB.rotational);\n\n    var GW = this.computeGW() - this.targetVelocity,\n        GiMf = this.computeGiMf();\n\n    var B = - GW * b - h * GiMf;\n\n    return B;\n};\n"]},"metadata":{},"sourceType":"script"}