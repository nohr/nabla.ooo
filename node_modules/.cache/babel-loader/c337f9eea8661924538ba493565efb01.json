{"ast":null,"code":"module.exports = GSSolver;\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Solver = require('./Solver');\n/**\n * Constraint equation Gauss-Seidel solver.\n * @class GSSolver\n * @constructor\n * @todo The spook parameters should be specified for each constraint, not globally.\n * @author schteppe / https://github.com/schteppe\n * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\n * @extends Solver\n */\n\n\nfunction GSSolver() {\n  Solver.call(this);\n  /**\n   * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.\n   * @property iterations\n   * @type {Number}\n   * @todo write more about solver and iterations in the wiki\n   */\n\n  this.iterations = 10;\n  /**\n   * When tolerance is reached, the system is assumed to be converged.\n   * @property tolerance\n   * @type {Number}\n   */\n\n  this.tolerance = 1e-7;\n}\n\nGSSolver.prototype = new Solver();\nvar GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.\n\nvar GSSolver_solve_invCs = [];\nvar GSSolver_solve_Bs = [];\n\nGSSolver.prototype.solve = function (dt, world) {\n  var iter = 0,\n      maxIter = this.iterations,\n      tolSquared = this.tolerance * this.tolerance,\n      equations = this.equations,\n      Neq = equations.length,\n      bodies = world.bodies,\n      Nbodies = bodies.length,\n      h = dt,\n      q,\n      B,\n      invC,\n      deltalambda,\n      deltalambdaTot,\n      GWlambda,\n      lambdaj; // Update solve mass\n\n  if (Neq !== 0) {\n    for (var i = 0; i !== Nbodies; i++) {\n      bodies[i].updateSolveMassProperties();\n    }\n  } // Things that does not change during iteration can be computed once\n\n\n  var invCs = GSSolver_solve_invCs,\n      Bs = GSSolver_solve_Bs,\n      lambda = GSSolver_solve_lambda;\n  invCs.length = Neq;\n  Bs.length = Neq;\n  lambda.length = Neq;\n\n  for (var i = 0; i !== Neq; i++) {\n    var c = equations[i];\n    lambda[i] = 0.0;\n    Bs[i] = c.computeB(h);\n    invCs[i] = 1.0 / c.computeC();\n  }\n\n  if (Neq !== 0) {\n    // Reset vlambda\n    for (var i = 0; i !== Nbodies; i++) {\n      var b = bodies[i],\n          vlambda = b.vlambda,\n          wlambda = b.wlambda;\n      vlambda.set(0, 0, 0);\n      wlambda.set(0, 0, 0);\n    } // Iterate over equations\n\n\n    for (iter = 0; iter !== maxIter; iter++) {\n      // Accumulate the total error for each iteration.\n      deltalambdaTot = 0.0;\n\n      for (var j = 0; j !== Neq; j++) {\n        var c = equations[j]; // Compute iteration\n\n        B = Bs[j];\n        invC = invCs[j];\n        lambdaj = lambda[j];\n        GWlambda = c.computeGWlambda();\n        deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval\n\n        if (lambdaj + deltalambda < c.minForce) {\n          deltalambda = c.minForce - lambdaj;\n        } else if (lambdaj + deltalambda > c.maxForce) {\n          deltalambda = c.maxForce - lambdaj;\n        }\n\n        lambda[j] += deltalambda;\n        deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)\n\n        c.addToWlambda(deltalambda);\n      } // If the total error is small enough - stop iterate\n\n\n      if (deltalambdaTot * deltalambdaTot < tolSquared) {\n        break;\n      }\n    } // Add result to velocity\n\n\n    for (var i = 0; i !== Nbodies; i++) {\n      var b = bodies[i],\n          v = b.velocity,\n          w = b.angularVelocity;\n      b.vlambda.vmul(b.linearFactor, b.vlambda);\n      v.vadd(b.vlambda, v);\n      b.wlambda.vmul(b.angularFactor, b.wlambda);\n      w.vadd(b.wlambda, w);\n    } // Set the .multiplier property of each equation\n\n\n    var l = equations.length;\n    var invDt = 1 / h;\n\n    while (l--) {\n      equations[l].multiplier = lambda[l] * invDt;\n    }\n  }\n\n  return iter;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/solver/GSSolver.js"],"names":["module","exports","GSSolver","Vec3","require","Quaternion","Solver","call","iterations","tolerance","prototype","GSSolver_solve_lambda","GSSolver_solve_invCs","GSSolver_solve_Bs","solve","dt","world","iter","maxIter","tolSquared","equations","Neq","length","bodies","Nbodies","h","q","B","invC","deltalambda","deltalambdaTot","GWlambda","lambdaj","i","updateSolveMassProperties","invCs","Bs","lambda","c","computeB","computeC","b","vlambda","wlambda","set","j","computeGWlambda","eps","minForce","maxForce","addToWlambda","v","velocity","w","angularVelocity","vmul","linearFactor","vadd","angularFactor","l","invDt","multiplier"],"mappings":"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","sourcesContent":["module.exports = GSSolver;\n\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Solver = require('./Solver');\n\n/**\n * Constraint equation Gauss-Seidel solver.\n * @class GSSolver\n * @constructor\n * @todo The spook parameters should be specified for each constraint, not globally.\n * @author schteppe / https://github.com/schteppe\n * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\n * @extends Solver\n */\nfunction GSSolver(){\n    Solver.call(this);\n\n    /**\n     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.\n     * @property iterations\n     * @type {Number}\n     * @todo write more about solver and iterations in the wiki\n     */\n    this.iterations = 10;\n\n    /**\n     * When tolerance is reached, the system is assumed to be converged.\n     * @property tolerance\n     * @type {Number}\n     */\n    this.tolerance = 1e-7;\n}\nGSSolver.prototype = new Solver();\n\nvar GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.\nvar GSSolver_solve_invCs = [];\nvar GSSolver_solve_Bs = [];\nGSSolver.prototype.solve = function(dt,world){\n    var iter = 0,\n        maxIter = this.iterations,\n        tolSquared = this.tolerance*this.tolerance,\n        equations = this.equations,\n        Neq = equations.length,\n        bodies = world.bodies,\n        Nbodies = bodies.length,\n        h = dt,\n        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;\n\n    // Update solve mass\n    if(Neq !== 0){\n        for(var i=0; i!==Nbodies; i++){\n            bodies[i].updateSolveMassProperties();\n        }\n    }\n\n    // Things that does not change during iteration can be computed once\n    var invCs = GSSolver_solve_invCs,\n        Bs = GSSolver_solve_Bs,\n        lambda = GSSolver_solve_lambda;\n    invCs.length = Neq;\n    Bs.length = Neq;\n    lambda.length = Neq;\n    for(var i=0; i!==Neq; i++){\n        var c = equations[i];\n        lambda[i] = 0.0;\n        Bs[i] = c.computeB(h);\n        invCs[i] = 1.0 / c.computeC();\n    }\n\n    if(Neq !== 0){\n\n        // Reset vlambda\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                vlambda=b.vlambda,\n                wlambda=b.wlambda;\n            vlambda.set(0,0,0);\n            wlambda.set(0,0,0);\n        }\n\n        // Iterate over equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(var j=0; j!==Neq; j++){\n\n                var c = equations[j];\n\n                // Compute iteration\n                B = Bs[j];\n                invC = invCs[j];\n                lambdaj = lambda[j];\n                GWlambda = c.computeGWlambda();\n                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );\n\n                // Clamp if we are not within the min/max interval\n                if(lambdaj + deltalambda < c.minForce){\n                    deltalambda = c.minForce - lambdaj;\n                } else if(lambdaj + deltalambda > c.maxForce){\n                    deltalambda = c.maxForce - lambdaj;\n                }\n                lambda[j] += deltalambda;\n\n                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)\n\n                c.addToWlambda(deltalambda);\n            }\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot < tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                v=b.velocity,\n                w=b.angularVelocity;\n\n            b.vlambda.vmul(b.linearFactor, b.vlambda);\n            v.vadd(b.vlambda, v);\n\n            b.wlambda.vmul(b.angularFactor, b.wlambda);\n            w.vadd(b.wlambda, w);\n        }\n\n        // Set the .multiplier property of each equation\n        var l = equations.length;\n        var invDt = 1 / h;\n        while(l--){\n            equations[l].multiplier = lambda[l] * invDt;\n        }\n    }\n\n    return iter;\n};\n"]},"metadata":{},"sourceType":"script"}