{"ast":null,"code":"var Body = require('./Body');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar RaycastResult = require('../collision/RaycastResult');\n\nvar Ray = require('../collision/Ray');\n\nvar WheelInfo = require('../objects/WheelInfo');\n\nmodule.exports = RaycastVehicle;\n/**\n * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.\n * @class RaycastVehicle\n * @constructor\n * @param {object} [options]\n * @param {Body} [options.chassisBody] The car chassis body.\n * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2\n * @param {integer} [options.indexLeftAxis]\n * @param {integer} [options.indexUpAxis]\n */\n\nfunction RaycastVehicle(options) {\n  /**\n   * @property {Body} chassisBody\n   */\n  this.chassisBody = options.chassisBody;\n  /**\n   * An array of WheelInfo objects.\n   * @property {array} wheelInfos\n   */\n\n  this.wheelInfos = [];\n  /**\n   * Will be set to true if the car is sliding.\n   * @property {boolean} sliding\n   */\n\n  this.sliding = false;\n  /**\n   * @property {World} world\n   */\n\n  this.world = null;\n  /**\n   * Index of the right axis, 0=x, 1=y, 2=z\n   * @property {integer} indexRightAxis\n   * @default 1\n   */\n\n  this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 1;\n  /**\n   * Index of the forward axis, 0=x, 1=y, 2=z\n   * @property {integer} indexForwardAxis\n   * @default 0\n   */\n\n  this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;\n  /**\n   * Index of the up axis, 0=x, 1=y, 2=z\n   * @property {integer} indexUpAxis\n   * @default 2\n   */\n\n  this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 2;\n}\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpVec3 = new Vec3();\nvar tmpVec4 = new Vec3();\nvar tmpVec5 = new Vec3();\nvar tmpVec6 = new Vec3();\nvar tmpRay = new Ray();\n/**\n * Add a wheel. For information about the options, see WheelInfo.\n * @method addWheel\n * @param {object} [options]\n */\n\nRaycastVehicle.prototype.addWheel = function (options) {\n  options = options || {};\n  var info = new WheelInfo(options);\n  var index = this.wheelInfos.length;\n  this.wheelInfos.push(info);\n  return index;\n};\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n */\n\n\nRaycastVehicle.prototype.setSteeringValue = function (value, wheelIndex) {\n  var wheel = this.wheelInfos[wheelIndex];\n  wheel.steering = value;\n};\n\nvar torque = new Vec3();\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method applyEngineForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\n\nRaycastVehicle.prototype.applyEngineForce = function (value, wheelIndex) {\n  this.wheelInfos[wheelIndex].engineForce = value;\n};\n/**\n * Set the braking force of a wheel\n * @method setBrake\n * @param {number} brake\n * @param {integer} wheelIndex\n */\n\n\nRaycastVehicle.prototype.setBrake = function (brake, wheelIndex) {\n  this.wheelInfos[wheelIndex].brake = brake;\n};\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\n\n\nRaycastVehicle.prototype.addToWorld = function (world) {\n  var constraints = this.constraints;\n  world.addBody(this.chassisBody);\n  var that = this;\n\n  this.preStepCallback = function () {\n    that.updateVehicle(world.dt);\n  };\n\n  world.addEventListener('preStep', this.preStepCallback);\n  this.world = world;\n};\n/**\n * Get one of the wheel axles, world-oriented.\n * @private\n * @method getVehicleAxisWorld\n * @param  {integer} axisIndex\n * @param  {Vec3} result\n */\n\n\nRaycastVehicle.prototype.getVehicleAxisWorld = function (axisIndex, result) {\n  result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);\n  this.chassisBody.vectorToWorldFrame(result, result);\n};\n\nRaycastVehicle.prototype.updateVehicle = function (timeStep) {\n  var wheelInfos = this.wheelInfos;\n  var numWheels = wheelInfos.length;\n  var chassisBody = this.chassisBody;\n\n  for (var i = 0; i < numWheels; i++) {\n    this.updateWheelTransform(i);\n  }\n\n  this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();\n  var forwardWorld = new Vec3();\n  this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);\n\n  if (forwardWorld.dot(chassisBody.velocity) < 0) {\n    this.currentVehicleSpeedKmHour *= -1;\n  } // simulate suspension\n\n\n  for (var i = 0; i < numWheels; i++) {\n    this.castRay(wheelInfos[i]);\n  }\n\n  this.updateSuspension(timeStep);\n  var impulse = new Vec3();\n  var relpos = new Vec3();\n\n  for (var i = 0; i < numWheels; i++) {\n    //apply suspension force\n    var wheel = wheelInfos[i];\n    var suspensionForce = wheel.suspensionForce;\n\n    if (suspensionForce > wheel.maxSuspensionForce) {\n      suspensionForce = wheel.maxSuspensionForce;\n    }\n\n    wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);\n    wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);\n    chassisBody.applyImpulse(impulse, relpos);\n  }\n\n  this.updateFriction(timeStep);\n  var hitNormalWorldScaledWithProj = new Vec3();\n  var fwd = new Vec3();\n  var vel = new Vec3();\n\n  for (i = 0; i < numWheels; i++) {\n    var wheel = wheelInfos[i]; //var relpos = new Vec3();\n    //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);\n\n    chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction\n\n    var m = 1;\n\n    switch (this.indexUpAxis) {\n      case 1:\n        m = -1;\n        break;\n    }\n\n    if (wheel.isInContact) {\n      this.getVehicleAxisWorld(this.indexForwardAxis, fwd);\n      var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);\n      wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);\n      fwd.vsub(hitNormalWorldScaledWithProj, fwd);\n      var proj2 = fwd.dot(vel);\n      wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;\n    }\n\n    if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {\n      // Apply custom rotation when accelerating and sliding\n      wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;\n    } // Lock wheels\n\n\n    if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {\n      wheel.deltaRotation = 0;\n    }\n\n    wheel.rotation += wheel.deltaRotation; // Use the old value\n\n    wheel.deltaRotation *= 0.99; // damping of rotation when not in contact\n  }\n};\n\nRaycastVehicle.prototype.updateSuspension = function (deltaTime) {\n  var chassisBody = this.chassisBody;\n  var chassisMass = chassisBody.mass;\n  var wheelInfos = this.wheelInfos;\n  var numWheels = wheelInfos.length;\n\n  for (var w_it = 0; w_it < numWheels; w_it++) {\n    var wheel = wheelInfos[w_it];\n\n    if (wheel.isInContact) {\n      var force; // Spring\n\n      var susp_length = wheel.suspensionRestLength;\n      var current_length = wheel.suspensionLength;\n      var length_diff = susp_length - current_length;\n      force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper\n\n      var projected_rel_vel = wheel.suspensionRelativeVelocity;\n      var susp_damping;\n\n      if (projected_rel_vel < 0) {\n        susp_damping = wheel.dampingCompression;\n      } else {\n        susp_damping = wheel.dampingRelaxation;\n      }\n\n      force -= susp_damping * projected_rel_vel;\n      wheel.suspensionForce = force * chassisMass;\n\n      if (wheel.suspensionForce < 0) {\n        wheel.suspensionForce = 0;\n      }\n    } else {\n      wheel.suspensionForce = 0;\n    }\n  }\n};\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\n\n\nRaycastVehicle.prototype.removeFromWorld = function (world) {\n  var constraints = this.constraints;\n  world.remove(this.chassisBody);\n  world.removeEventListener('preStep', this.preStepCallback);\n  this.world = null;\n};\n\nvar castRay_rayvector = new Vec3();\nvar castRay_target = new Vec3();\n\nRaycastVehicle.prototype.castRay = function (wheel) {\n  var rayvector = castRay_rayvector;\n  var target = castRay_target;\n  this.updateWheelTransformWorld(wheel);\n  var chassisBody = this.chassisBody;\n  var depth = -1;\n  var raylen = wheel.suspensionRestLength + wheel.radius;\n  wheel.directionWorld.scale(raylen, rayvector);\n  var source = wheel.chassisConnectionPointWorld;\n  source.vadd(rayvector, target);\n  var raycastResult = wheel.raycastResult;\n  var param = 0;\n  raycastResult.reset(); // Turn off ray collision with the chassis temporarily\n\n  var oldState = chassisBody.collisionResponse;\n  chassisBody.collisionResponse = false; // Cast ray against world\n\n  this.world.rayTest(source, target, raycastResult);\n  chassisBody.collisionResponse = oldState;\n  var object = raycastResult.body;\n  wheel.raycastResult.groundObject = 0;\n\n  if (object) {\n    depth = raycastResult.distance;\n    wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;\n    wheel.isInContact = true;\n    var hitDistance = raycastResult.distance;\n    wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel\n\n    var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;\n    var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;\n\n    if (wheel.suspensionLength < minSuspensionLength) {\n      wheel.suspensionLength = minSuspensionLength;\n    }\n\n    if (wheel.suspensionLength > maxSuspensionLength) {\n      wheel.suspensionLength = maxSuspensionLength;\n      wheel.raycastResult.reset();\n    }\n\n    var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);\n    var chassis_velocity_at_contactPoint = new Vec3();\n    chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);\n    var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);\n\n    if (denominator >= -0.1) {\n      wheel.suspensionRelativeVelocity = 0;\n      wheel.clippedInvContactDotSuspension = 1 / 0.1;\n    } else {\n      var inv = -1 / denominator;\n      wheel.suspensionRelativeVelocity = projVel * inv;\n      wheel.clippedInvContactDotSuspension = inv;\n    }\n  } else {\n    //put wheel info as in rest position\n    wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;\n    wheel.suspensionRelativeVelocity = 0.0;\n    wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);\n    wheel.clippedInvContactDotSuspension = 1.0;\n  }\n\n  return depth;\n};\n\nRaycastVehicle.prototype.updateWheelTransformWorld = function (wheel) {\n  wheel.isInContact = false;\n  var chassisBody = this.chassisBody;\n  chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);\n  chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);\n  chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);\n};\n/**\n * Update one of the wheel transform.\n * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.\n * @method updateWheelTransform\n * @param {integer} wheelIndex The wheel index to update.\n */\n\n\nRaycastVehicle.prototype.updateWheelTransform = function (wheelIndex) {\n  var up = tmpVec4;\n  var right = tmpVec5;\n  var fwd = tmpVec6;\n  var wheel = this.wheelInfos[wheelIndex];\n  this.updateWheelTransformWorld(wheel);\n  wheel.directionLocal.scale(-1, up);\n  right.copy(wheel.axleLocal);\n  up.cross(right, fwd);\n  fwd.normalize();\n  right.normalize(); // Rotate around steering over the wheelAxle\n\n  var steering = wheel.steering;\n  var steeringOrn = new Quaternion();\n  steeringOrn.setFromAxisAngle(up, steering);\n  var rotatingOrn = new Quaternion();\n  rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel\n\n  var q = wheel.worldTransform.quaternion;\n  this.chassisBody.quaternion.mult(steeringOrn, q);\n  q.mult(rotatingOrn, q);\n  q.normalize(); // world position of the wheel\n\n  var p = wheel.worldTransform.position;\n  p.copy(wheel.directionWorld);\n  p.scale(wheel.suspensionLength, p);\n  p.vadd(wheel.chassisConnectionPointWorld, p);\n};\n\nvar directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];\n/**\n * Get the world transform of one of the wheels\n * @method getWheelTransformWorld\n * @param  {integer} wheelIndex\n * @return {Transform}\n */\n\nRaycastVehicle.prototype.getWheelTransformWorld = function (wheelIndex) {\n  return this.wheelInfos[wheelIndex].worldTransform;\n};\n\nvar updateFriction_surfNormalWS_scaled_proj = new Vec3();\nvar updateFriction_axle = [];\nvar updateFriction_forwardWS = [];\nvar sideFrictionStiffness2 = 1;\n\nRaycastVehicle.prototype.updateFriction = function (timeStep) {\n  var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards\n\n  var wheelInfos = this.wheelInfos;\n  var numWheels = wheelInfos.length;\n  var chassisBody = this.chassisBody;\n  var forwardWS = updateFriction_forwardWS;\n  var axle = updateFriction_axle;\n  var numWheelsOnGround = 0;\n\n  for (var i = 0; i < numWheels; i++) {\n    var wheel = wheelInfos[i];\n    var groundObject = wheel.raycastResult.body;\n\n    if (groundObject) {\n      numWheelsOnGround++;\n    }\n\n    wheel.sideImpulse = 0;\n    wheel.forwardImpulse = 0;\n\n    if (!forwardWS[i]) {\n      forwardWS[i] = new Vec3();\n    }\n\n    if (!axle[i]) {\n      axle[i] = new Vec3();\n    }\n  }\n\n  for (var i = 0; i < numWheels; i++) {\n    var wheel = wheelInfos[i];\n    var groundObject = wheel.raycastResult.body;\n\n    if (groundObject) {\n      var axlei = axle[i];\n      var wheelTrans = this.getWheelTransformWorld(i); // Get world axle\n\n      wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);\n      var surfNormalWS = wheel.raycastResult.hitNormalWorld;\n      var proj = axlei.dot(surfNormalWS);\n      surfNormalWS.scale(proj, surfNormalWS_scaled_proj);\n      axlei.vsub(surfNormalWS_scaled_proj, axlei);\n      axlei.normalize();\n      surfNormalWS.cross(axlei, forwardWS[i]);\n      forwardWS[i].normalize();\n      wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);\n      wheel.sideImpulse *= sideFrictionStiffness2;\n    }\n  }\n\n  var sideFactor = 1;\n  var fwdFactor = 0.5;\n  this.sliding = false;\n\n  for (var i = 0; i < numWheels; i++) {\n    var wheel = wheelInfos[i];\n    var groundObject = wheel.raycastResult.body;\n    var rollingFriction = 0;\n    wheel.slipInfo = 1;\n\n    if (groundObject) {\n      var defaultRollingFrictionImpulse = 0;\n      var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);\n      // rollingFriction = calcRollingFriction(contactPt);\n\n      rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);\n      rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;\n\n      var factor = maxImpulse / rollingFriction;\n      wheel.slipInfo *= factor;\n    } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)\n\n\n    wheel.forwardImpulse = 0;\n    wheel.skidInfo = 1;\n\n    if (groundObject) {\n      wheel.skidInfo = 1;\n      var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;\n      var maximpSide = maximp;\n      var maximpSquared = maximp * maximpSide;\n      wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;\n\n      var x = wheel.forwardImpulse * fwdFactor;\n      var y = wheel.sideImpulse * sideFactor;\n      var impulseSquared = x * x + y * y;\n      wheel.sliding = false;\n\n      if (impulseSquared > maximpSquared) {\n        this.sliding = true;\n        wheel.sliding = true;\n        var factor = maximp / Math.sqrt(impulseSquared);\n        wheel.skidInfo *= factor;\n      }\n    }\n  }\n\n  if (this.sliding) {\n    for (var i = 0; i < numWheels; i++) {\n      var wheel = wheelInfos[i];\n\n      if (wheel.sideImpulse !== 0) {\n        if (wheel.skidInfo < 1) {\n          wheel.forwardImpulse *= wheel.skidInfo;\n          wheel.sideImpulse *= wheel.skidInfo;\n        }\n      }\n    }\n  } // apply the impulses\n\n\n  for (var i = 0; i < numWheels; i++) {\n    var wheel = wheelInfos[i];\n    var rel_pos = new Vec3();\n    wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position\n    //rel_pos.copy(wheel.raycastResult.hitPointWorld);\n\n    if (wheel.forwardImpulse !== 0) {\n      var impulse = new Vec3();\n      forwardWS[i].scale(wheel.forwardImpulse, impulse);\n      chassisBody.applyImpulse(impulse, rel_pos);\n    }\n\n    if (wheel.sideImpulse !== 0) {\n      var groundObject = wheel.raycastResult.body;\n      var rel_pos2 = new Vec3();\n      wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);\n\n      var sideImp = new Vec3();\n      axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.\n      // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).\n\n      chassisBody.vectorToLocalFrame(rel_pos, rel_pos);\n      rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;\n      chassisBody.vectorToWorldFrame(rel_pos, rel_pos);\n      chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground\n\n      sideImp.scale(-1, sideImp);\n      groundObject.applyImpulse(sideImp, rel_pos2);\n    }\n  }\n};\n\nvar calcRollingFriction_vel1 = new Vec3();\nvar calcRollingFriction_vel2 = new Vec3();\nvar calcRollingFriction_vel = new Vec3();\n\nfunction calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {\n  var j1 = 0;\n  var contactPosWorld = frictionPosWorld; // var rel_pos1 = new Vec3();\n  // var rel_pos2 = new Vec3();\n\n  var vel1 = calcRollingFriction_vel1;\n  var vel2 = calcRollingFriction_vel2;\n  var vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);\n  // contactPosWorld.vsub(body1.position, rel_pos2);\n\n  body0.getVelocityAtWorldPoint(contactPosWorld, vel1);\n  body1.getVelocityAtWorldPoint(contactPosWorld, vel2);\n  vel1.vsub(vel2, vel);\n  var vrel = frictionDirectionWorld.dot(vel);\n  var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);\n  var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);\n  var relaxation = 1;\n  var jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity\n\n  j1 = -vrel * jacDiagABInv;\n\n  if (maxImpulse < j1) {\n    j1 = maxImpulse;\n  }\n\n  if (j1 < -maxImpulse) {\n    j1 = -maxImpulse;\n  }\n\n  return j1;\n}\n\nvar computeImpulseDenominator_r0 = new Vec3();\nvar computeImpulseDenominator_c0 = new Vec3();\nvar computeImpulseDenominator_vec = new Vec3();\nvar computeImpulseDenominator_m = new Vec3();\n\nfunction computeImpulseDenominator(body, pos, normal) {\n  var r0 = computeImpulseDenominator_r0;\n  var c0 = computeImpulseDenominator_c0;\n  var vec = computeImpulseDenominator_vec;\n  var m = computeImpulseDenominator_m;\n  pos.vsub(body.position, r0);\n  r0.cross(normal, c0);\n  body.invInertiaWorld.vmult(c0, m);\n  m.cross(r0, vec);\n  return body.invMass + normal.dot(vec);\n}\n\nvar resolveSingleBilateral_vel1 = new Vec3();\nvar resolveSingleBilateral_vel2 = new Vec3();\nvar resolveSingleBilateral_vel = new Vec3(); //bilateral constraint between two dynamic objects\n\nfunction resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {\n  var normalLenSqr = normal.norm2();\n\n  if (normalLenSqr > 1.1) {\n    return 0; // no impulse\n  } // var rel_pos1 = new Vec3();\n  // var rel_pos2 = new Vec3();\n  // pos1.vsub(body1.position, rel_pos1);\n  // pos2.vsub(body2.position, rel_pos2);\n\n\n  var vel1 = resolveSingleBilateral_vel1;\n  var vel2 = resolveSingleBilateral_vel2;\n  var vel = resolveSingleBilateral_vel;\n  body1.getVelocityAtWorldPoint(pos1, vel1);\n  body2.getVelocityAtWorldPoint(pos2, vel2);\n  vel1.vsub(vel2, vel);\n  var rel_vel = normal.dot(vel);\n  var contactDamping = 0.2;\n  var massTerm = 1 / (body1.invMass + body2.invMass);\n  var impulse = -contactDamping * rel_vel * massTerm;\n  return impulse;\n}","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/objects/RaycastVehicle.js"],"names":["Body","require","Vec3","Quaternion","RaycastResult","Ray","WheelInfo","module","exports","RaycastVehicle","options","chassisBody","wheelInfos","sliding","world","indexRightAxis","indexForwardAxis","indexUpAxis","tmpVec1","tmpVec2","tmpVec3","tmpVec4","tmpVec5","tmpVec6","tmpRay","prototype","addWheel","info","index","length","push","setSteeringValue","value","wheelIndex","wheel","steering","torque","applyEngineForce","engineForce","setBrake","brake","addToWorld","constraints","addBody","that","preStepCallback","updateVehicle","dt","addEventListener","getVehicleAxisWorld","axisIndex","result","set","vectorToWorldFrame","timeStep","numWheels","i","updateWheelTransform","currentVehicleSpeedKmHour","velocity","norm","forwardWorld","dot","castRay","updateSuspension","impulse","relpos","suspensionForce","maxSuspensionForce","raycastResult","hitNormalWorld","scale","hitPointWorld","vsub","position","applyImpulse","updateFriction","hitNormalWorldScaledWithProj","fwd","vel","getVelocityAtWorldPoint","chassisConnectionPointWorld","m","isInContact","proj","proj2","deltaRotation","radius","useCustomSlidingRotationalSpeed","customSlidingRotationalSpeed","Math","abs","rotation","deltaTime","chassisMass","mass","w_it","force","susp_length","suspensionRestLength","current_length","suspensionLength","length_diff","suspensionStiffness","clippedInvContactDotSuspension","projected_rel_vel","suspensionRelativeVelocity","susp_damping","dampingCompression","dampingRelaxation","removeFromWorld","remove","removeEventListener","castRay_rayvector","castRay_target","rayvector","target","updateWheelTransformWorld","depth","raylen","directionWorld","source","vadd","param","reset","oldState","collisionResponse","rayTest","object","body","groundObject","distance","hitDistance","minSuspensionLength","maxSuspensionTravel","maxSuspensionLength","denominator","chassis_velocity_at_contactPoint","projVel","inv","pointToWorldFrame","chassisConnectionPointLocal","directionLocal","axleLocal","axleWorld","up","right","copy","cross","normalize","steeringOrn","setFromAxisAngle","rotatingOrn","q","worldTransform","quaternion","mult","p","directions","getWheelTransformWorld","updateFriction_surfNormalWS_scaled_proj","updateFriction_axle","updateFriction_forwardWS","sideFrictionStiffness2","surfNormalWS_scaled_proj","forwardWS","axle","numWheelsOnGround","sideImpulse","forwardImpulse","axlei","wheelTrans","surfNormalWS","resolveSingleBilateral","sideFactor","fwdFactor","rollingFriction","slipInfo","defaultRollingFrictionImpulse","maxImpulse","calcRollingFriction","factor","skidInfo","maximp","frictionSlip","maximpSide","maximpSquared","x","y","impulseSquared","sqrt","rel_pos","rel_pos2","sideImp","vectorToLocalFrame","rollInfluence","calcRollingFriction_vel1","calcRollingFriction_vel2","calcRollingFriction_vel","body0","body1","frictionPosWorld","frictionDirectionWorld","j1","contactPosWorld","vel1","vel2","vrel","denom0","computeImpulseDenominator","denom1","relaxation","jacDiagABInv","computeImpulseDenominator_r0","computeImpulseDenominator_c0","computeImpulseDenominator_vec","computeImpulseDenominator_m","pos","normal","r0","c0","vec","invInertiaWorld","vmult","invMass","resolveSingleBilateral_vel1","resolveSingleBilateral_vel2","resolveSingleBilateral_vel","pos1","body2","pos2","normalLenSqr","norm2","rel_vel","contactDamping","massTerm"],"mappings":"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","sourcesContent":["var Body = require('./Body');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar RaycastResult = require('../collision/RaycastResult');\nvar Ray = require('../collision/Ray');\nvar WheelInfo = require('../objects/WheelInfo');\n\nmodule.exports = RaycastVehicle;\n\n/**\n * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.\n * @class RaycastVehicle\n * @constructor\n * @param {object} [options]\n * @param {Body} [options.chassisBody] The car chassis body.\n * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2\n * @param {integer} [options.indexLeftAxis]\n * @param {integer} [options.indexUpAxis]\n */\nfunction RaycastVehicle(options){\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = options.chassisBody;\n\n    /**\n     * An array of WheelInfo objects.\n     * @property {array} wheelInfos\n     */\n    this.wheelInfos = [];\n\n    /**\n     * Will be set to true if the car is sliding.\n     * @property {boolean} sliding\n     */\n    this.sliding = false;\n\n    /**\n     * @property {World} world\n     */\n    this.world = null;\n\n    /**\n     * Index of the right axis, 0=x, 1=y, 2=z\n     * @property {integer} indexRightAxis\n     * @default 1\n     */\n    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;\n\n    /**\n     * Index of the forward axis, 0=x, 1=y, 2=z\n     * @property {integer} indexForwardAxis\n     * @default 0\n     */\n    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;\n\n    /**\n     * Index of the up axis, 0=x, 1=y, 2=z\n     * @property {integer} indexUpAxis\n     * @default 2\n     */\n    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;\n}\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpVec3 = new Vec3();\nvar tmpVec4 = new Vec3();\nvar tmpVec5 = new Vec3();\nvar tmpVec6 = new Vec3();\nvar tmpRay = new Ray();\n\n/**\n * Add a wheel. For information about the options, see WheelInfo.\n * @method addWheel\n * @param {object} [options]\n */\nRaycastVehicle.prototype.addWheel = function(options){\n    options = options || {};\n\n    var info = new WheelInfo(options);\n    var index = this.wheelInfos.length;\n    this.wheelInfos.push(info);\n\n    return index;\n};\n\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){\n    var wheel = this.wheelInfos[wheelIndex];\n    wheel.steering = value;\n};\n\nvar torque = new Vec3();\n\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method applyEngineForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){\n    this.wheelInfos[wheelIndex].engineForce = value;\n};\n\n/**\n * Set the braking force of a wheel\n * @method setBrake\n * @param {number} brake\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setBrake = function(brake, wheelIndex){\n    this.wheelInfos[wheelIndex].brake = brake;\n};\n\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.addToWorld = function(world){\n    var constraints = this.constraints;\n    world.addBody(this.chassisBody);\n    var that = this;\n    this.preStepCallback = function(){\n        that.updateVehicle(world.dt);\n    };\n    world.addEventListener('preStep', this.preStepCallback);\n    this.world = world;\n};\n\n/**\n * Get one of the wheel axles, world-oriented.\n * @private\n * @method getVehicleAxisWorld\n * @param  {integer} axisIndex\n * @param  {Vec3} result\n */\nRaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){\n    result.set(\n        axisIndex === 0 ? 1 : 0,\n        axisIndex === 1 ? 1 : 0,\n        axisIndex === 2 ? 1 : 0\n    );\n    this.chassisBody.vectorToWorldFrame(result, result);\n};\n\nRaycastVehicle.prototype.updateVehicle = function(timeStep){\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n\n    for (var i = 0; i < numWheels; i++) {\n        this.updateWheelTransform(i);\n    }\n\n    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();\n\n    var forwardWorld = new Vec3();\n    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);\n\n    if (forwardWorld.dot(chassisBody.velocity) < 0){\n        this.currentVehicleSpeedKmHour *= -1;\n    }\n\n    // simulate suspension\n    for (var i = 0; i < numWheels; i++) {\n        this.castRay(wheelInfos[i]);\n    }\n\n    this.updateSuspension(timeStep);\n\n    var impulse = new Vec3();\n    var relpos = new Vec3();\n    for (var i = 0; i < numWheels; i++) {\n        //apply suspension force\n        var wheel = wheelInfos[i];\n        var suspensionForce = wheel.suspensionForce;\n        if (suspensionForce > wheel.maxSuspensionForce) {\n            suspensionForce = wheel.maxSuspensionForce;\n        }\n        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);\n\n        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.applyImpulse(impulse, relpos);\n    }\n\n    this.updateFriction(timeStep);\n\n    var hitNormalWorldScaledWithProj = new Vec3();\n    var fwd  = new Vec3();\n    var vel = new Vec3();\n    for (i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        //var relpos = new Vec3();\n        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);\n\n        // Hack to get the rotation in the correct direction\n        var m = 1;\n        switch(this.indexUpAxis){\n        case 1:\n            m = -1;\n            break;\n        }\n\n        if (wheel.isInContact) {\n\n            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);\n            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);\n            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);\n\n            fwd.vsub(hitNormalWorldScaledWithProj, fwd);\n\n            var proj2 = fwd.dot(vel);\n            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;\n        }\n\n        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){\n            // Apply custom rotation when accelerating and sliding\n            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;\n        }\n\n        // Lock wheels\n        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){\n            wheel.deltaRotation = 0;\n        }\n\n        wheel.rotation += wheel.deltaRotation; // Use the old value\n        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact\n    }\n};\n\nRaycastVehicle.prototype.updateSuspension = function(deltaTime) {\n    var chassisBody = this.chassisBody;\n    var chassisMass = chassisBody.mass;\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n\n    for (var w_it = 0; w_it < numWheels; w_it++){\n        var wheel = wheelInfos[w_it];\n\n        if (wheel.isInContact){\n            var force;\n\n            // Spring\n            var susp_length = wheel.suspensionRestLength;\n            var current_length = wheel.suspensionLength;\n            var length_diff = (susp_length - current_length);\n\n            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;\n\n            // Damper\n            var projected_rel_vel = wheel.suspensionRelativeVelocity;\n            var susp_damping;\n            if (projected_rel_vel < 0) {\n                susp_damping = wheel.dampingCompression;\n            } else {\n                susp_damping = wheel.dampingRelaxation;\n            }\n            force -= susp_damping * projected_rel_vel;\n\n            wheel.suspensionForce = force * chassisMass;\n            if (wheel.suspensionForce < 0) {\n                wheel.suspensionForce = 0;\n            }\n        } else {\n            wheel.suspensionForce = 0;\n        }\n    }\n};\n\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.removeFromWorld = function(world){\n    var constraints = this.constraints;\n    world.remove(this.chassisBody);\n    world.removeEventListener('preStep', this.preStepCallback);\n    this.world = null;\n};\n\nvar castRay_rayvector = new Vec3();\nvar castRay_target = new Vec3();\nRaycastVehicle.prototype.castRay = function(wheel) {\n    var rayvector = castRay_rayvector;\n    var target = castRay_target;\n\n    this.updateWheelTransformWorld(wheel);\n    var chassisBody = this.chassisBody;\n\n    var depth = -1;\n\n    var raylen = wheel.suspensionRestLength + wheel.radius;\n\n    wheel.directionWorld.scale(raylen, rayvector);\n    var source = wheel.chassisConnectionPointWorld;\n    source.vadd(rayvector, target);\n    var raycastResult = wheel.raycastResult;\n\n    var param = 0;\n\n    raycastResult.reset();\n    // Turn off ray collision with the chassis temporarily\n    var oldState = chassisBody.collisionResponse;\n    chassisBody.collisionResponse = false;\n\n    // Cast ray against world\n    this.world.rayTest(source, target, raycastResult);\n    chassisBody.collisionResponse = oldState;\n\n    var object = raycastResult.body;\n\n    wheel.raycastResult.groundObject = 0;\n\n    if (object) {\n        depth = raycastResult.distance;\n        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;\n        wheel.isInContact = true;\n\n        var hitDistance = raycastResult.distance;\n        wheel.suspensionLength = hitDistance - wheel.radius;\n\n        // clamp on max suspension travel\n        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;\n        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;\n        if (wheel.suspensionLength < minSuspensionLength) {\n            wheel.suspensionLength = minSuspensionLength;\n        }\n        if (wheel.suspensionLength > maxSuspensionLength) {\n            wheel.suspensionLength = maxSuspensionLength;\n            wheel.raycastResult.reset();\n        }\n\n        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);\n\n        var chassis_velocity_at_contactPoint = new Vec3();\n        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);\n\n        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );\n\n        if (denominator >= -0.1) {\n            wheel.suspensionRelativeVelocity = 0;\n            wheel.clippedInvContactDotSuspension = 1 / 0.1;\n        } else {\n            var inv = -1 / denominator;\n            wheel.suspensionRelativeVelocity = projVel * inv;\n            wheel.clippedInvContactDotSuspension = inv;\n        }\n\n    } else {\n\n        //put wheel info as in rest position\n        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;\n        wheel.suspensionRelativeVelocity = 0.0;\n        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);\n        wheel.clippedInvContactDotSuspension = 1.0;\n    }\n\n    return depth;\n};\n\nRaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){\n    wheel.isInContact = false;\n    var chassisBody = this.chassisBody;\n    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);\n    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);\n    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);\n};\n\n\n/**\n * Update one of the wheel transform.\n * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.\n * @method updateWheelTransform\n * @param {integer} wheelIndex The wheel index to update.\n */\nRaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){\n    var up = tmpVec4;\n    var right = tmpVec5;\n    var fwd = tmpVec6;\n\n    var wheel = this.wheelInfos[wheelIndex];\n    this.updateWheelTransformWorld(wheel);\n\n    wheel.directionLocal.scale(-1, up);\n    right.copy(wheel.axleLocal);\n    up.cross(right, fwd);\n    fwd.normalize();\n    right.normalize();\n\n    // Rotate around steering over the wheelAxle\n    var steering = wheel.steering;\n    var steeringOrn = new Quaternion();\n    steeringOrn.setFromAxisAngle(up, steering);\n\n    var rotatingOrn = new Quaternion();\n    rotatingOrn.setFromAxisAngle(right, wheel.rotation);\n\n    // World rotation of the wheel\n    var q = wheel.worldTransform.quaternion;\n    this.chassisBody.quaternion.mult(steeringOrn, q);\n    q.mult(rotatingOrn, q);\n\n    q.normalize();\n\n    // world position of the wheel\n    var p = wheel.worldTransform.position;\n    p.copy(wheel.directionWorld);\n    p.scale(wheel.suspensionLength, p);\n    p.vadd(wheel.chassisConnectionPointWorld, p);\n};\n\nvar directions = [\n    new Vec3(1, 0, 0),\n    new Vec3(0, 1, 0),\n    new Vec3(0, 0, 1)\n];\n\n/**\n * Get the world transform of one of the wheels\n * @method getWheelTransformWorld\n * @param  {integer} wheelIndex\n * @return {Transform}\n */\nRaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {\n    return this.wheelInfos[wheelIndex].worldTransform;\n};\n\n\nvar updateFriction_surfNormalWS_scaled_proj = new Vec3();\nvar updateFriction_axle = [];\nvar updateFriction_forwardWS = [];\nvar sideFrictionStiffness2 = 1;\nRaycastVehicle.prototype.updateFriction = function(timeStep) {\n    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;\n\n    //calculate the impulse, so that the wheels don't move sidewards\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n    var forwardWS = updateFriction_forwardWS;\n    var axle = updateFriction_axle;\n\n    var numWheelsOnGround = 0;\n\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n        if (groundObject){\n            numWheelsOnGround++;\n        }\n\n        wheel.sideImpulse = 0;\n        wheel.forwardImpulse = 0;\n        if(!forwardWS[i]){\n            forwardWS[i] = new Vec3();\n        }\n        if(!axle[i]){\n            axle[i] = new Vec3();\n        }\n    }\n\n    for (var i = 0; i < numWheels; i++){\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n\n        if (groundObject) {\n            var axlei = axle[i];\n            var wheelTrans = this.getWheelTransformWorld(i);\n\n            // Get world axle\n            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);\n\n            var surfNormalWS = wheel.raycastResult.hitNormalWorld;\n            var proj = axlei.dot(surfNormalWS);\n            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);\n            axlei.vsub(surfNormalWS_scaled_proj, axlei);\n            axlei.normalize();\n\n            surfNormalWS.cross(axlei, forwardWS[i]);\n            forwardWS[i].normalize();\n\n            wheel.sideImpulse = resolveSingleBilateral(\n                chassisBody,\n                wheel.raycastResult.hitPointWorld,\n                groundObject,\n                wheel.raycastResult.hitPointWorld,\n                axlei\n            );\n\n            wheel.sideImpulse *= sideFrictionStiffness2;\n        }\n    }\n\n    var sideFactor = 1;\n    var fwdFactor = 0.5;\n\n    this.sliding = false;\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        var groundObject = wheel.raycastResult.body;\n\n        var rollingFriction = 0;\n\n        wheel.slipInfo = 1;\n        if (groundObject) {\n            var defaultRollingFrictionImpulse = 0;\n            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;\n\n            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);\n            // rollingFriction = calcRollingFriction(contactPt);\n            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);\n\n            rollingFriction += wheel.engineForce * timeStep;\n\n            // rollingFriction = 0;\n            var factor = maxImpulse / rollingFriction;\n            wheel.slipInfo *= factor;\n        }\n\n        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)\n\n        wheel.forwardImpulse = 0;\n        wheel.skidInfo = 1;\n\n        if (groundObject) {\n            wheel.skidInfo = 1;\n\n            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;\n            var maximpSide = maximp;\n\n            var maximpSquared = maximp * maximpSide;\n\n            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;\n\n            var x = wheel.forwardImpulse * fwdFactor;\n            var y = wheel.sideImpulse * sideFactor;\n\n            var impulseSquared = x * x + y * y;\n\n            wheel.sliding = false;\n            if (impulseSquared > maximpSquared) {\n                this.sliding = true;\n                wheel.sliding = true;\n\n                var factor = maximp / Math.sqrt(impulseSquared);\n\n                wheel.skidInfo *= factor;\n            }\n        }\n    }\n\n    if (this.sliding) {\n        for (var i = 0; i < numWheels; i++) {\n            var wheel = wheelInfos[i];\n            if (wheel.sideImpulse !== 0) {\n                if (wheel.skidInfo < 1){\n                    wheel.forwardImpulse *= wheel.skidInfo;\n                    wheel.sideImpulse *= wheel.skidInfo;\n                }\n            }\n        }\n    }\n\n    // apply the impulses\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var rel_pos = new Vec3();\n        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);\n        // cannons applyimpulse is using world coord for the position\n        //rel_pos.copy(wheel.raycastResult.hitPointWorld);\n\n        if (wheel.forwardImpulse !== 0) {\n            var impulse = new Vec3();\n            forwardWS[i].scale(wheel.forwardImpulse, impulse);\n            chassisBody.applyImpulse(impulse, rel_pos);\n        }\n\n        if (wheel.sideImpulse !== 0){\n            var groundObject = wheel.raycastResult.body;\n\n            var rel_pos2 = new Vec3();\n            wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);\n            //rel_pos2.copy(wheel.raycastResult.hitPointWorld);\n            var sideImp = new Vec3();\n            axle[i].scale(wheel.sideImpulse, sideImp);\n\n            // Scale the relative position in the up direction with rollInfluence.\n            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).\n            chassisBody.vectorToLocalFrame(rel_pos, rel_pos);\n            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;\n            chassisBody.vectorToWorldFrame(rel_pos, rel_pos);\n            chassisBody.applyImpulse(sideImp, rel_pos);\n\n            //apply friction impulse on the ground\n            sideImp.scale(-1, sideImp);\n            groundObject.applyImpulse(sideImp, rel_pos2);\n        }\n    }\n};\n\nvar calcRollingFriction_vel1 = new Vec3();\nvar calcRollingFriction_vel2 = new Vec3();\nvar calcRollingFriction_vel = new Vec3();\n\nfunction calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {\n    var j1 = 0;\n    var contactPosWorld = frictionPosWorld;\n\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    var vel1 = calcRollingFriction_vel1;\n    var vel2 = calcRollingFriction_vel2;\n    var vel = calcRollingFriction_vel;\n    // contactPosWorld.vsub(body0.position, rel_pos1);\n    // contactPosWorld.vsub(body1.position, rel_pos2);\n\n    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);\n    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);\n    vel1.vsub(vel2, vel);\n\n    var vrel = frictionDirectionWorld.dot(vel);\n\n    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);\n    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);\n    var relaxation = 1;\n    var jacDiagABInv = relaxation / (denom0 + denom1);\n\n    // calculate j that moves us to zero relative velocity\n    j1 = -vrel * jacDiagABInv;\n\n    if (maxImpulse < j1) {\n        j1 = maxImpulse;\n    }\n    if (j1 < -maxImpulse) {\n        j1 = -maxImpulse;\n    }\n\n    return j1;\n}\n\nvar computeImpulseDenominator_r0 = new Vec3();\nvar computeImpulseDenominator_c0 = new Vec3();\nvar computeImpulseDenominator_vec = new Vec3();\nvar computeImpulseDenominator_m = new Vec3();\nfunction computeImpulseDenominator(body, pos, normal) {\n    var r0 = computeImpulseDenominator_r0;\n    var c0 = computeImpulseDenominator_c0;\n    var vec = computeImpulseDenominator_vec;\n    var m = computeImpulseDenominator_m;\n\n    pos.vsub(body.position, r0);\n    r0.cross(normal, c0);\n    body.invInertiaWorld.vmult(c0, m);\n    m.cross(r0, vec);\n\n    return body.invMass + normal.dot(vec);\n}\n\n\nvar resolveSingleBilateral_vel1 = new Vec3();\nvar resolveSingleBilateral_vel2 = new Vec3();\nvar resolveSingleBilateral_vel = new Vec3();\n\n//bilateral constraint between two dynamic objects\nfunction resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){\n    var normalLenSqr = normal.norm2();\n    if (normalLenSqr > 1.1){\n        return 0; // no impulse\n    }\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    // pos1.vsub(body1.position, rel_pos1);\n    // pos2.vsub(body2.position, rel_pos2);\n\n    var vel1 = resolveSingleBilateral_vel1;\n    var vel2 = resolveSingleBilateral_vel2;\n    var vel = resolveSingleBilateral_vel;\n    body1.getVelocityAtWorldPoint(pos1, vel1);\n    body2.getVelocityAtWorldPoint(pos2, vel2);\n\n    vel1.vsub(vel2, vel);\n\n    var rel_vel = normal.dot(vel);\n\n    var contactDamping = 0.2;\n    var massTerm = 1 / (body1.invMass + body2.invMass);\n    var impulse = - contactDamping * rel_vel * massTerm;\n\n    return impulse;\n}"]},"metadata":{},"sourceType":"script"}