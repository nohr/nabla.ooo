{"ast":null,"code":"module.exports = DistanceConstraint;\n\nvar Constraint = require('./Constraint');\n\nvar ContactEquation = require('../equations/ContactEquation');\n/**\n * Constrains two bodies to be at a constant distance from each others center of mass.\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB\n * @param {Number} [maxForce=1e6]\n * @extends Constraint\n */\n\n\nfunction DistanceConstraint(bodyA, bodyB, distance, maxForce) {\n  Constraint.call(this, bodyA, bodyB);\n\n  if (typeof distance === \"undefined\") {\n    distance = bodyA.position.distanceTo(bodyB.position);\n  }\n\n  if (typeof maxForce === \"undefined\") {\n    maxForce = 1e6;\n  }\n  /**\n   * @property {number} distance\n   */\n\n\n  this.distance = distance;\n  /**\n   * @property {ContactEquation} distanceEquation\n   */\n\n  var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);\n  this.equations.push(eq); // Make it bidirectional\n\n  eq.minForce = -maxForce;\n  eq.maxForce = maxForce;\n}\n\nDistanceConstraint.prototype = new Constraint();\n\nDistanceConstraint.prototype.update = function () {\n  var bodyA = this.bodyA;\n  var bodyB = this.bodyB;\n  var eq = this.distanceEquation;\n  var halfDist = this.distance * 0.5;\n  var normal = eq.ni;\n  bodyB.position.vsub(bodyA.position, normal);\n  normal.normalize();\n  normal.mult(halfDist, eq.ri);\n  normal.mult(-halfDist, eq.rj);\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/constraints/DistanceConstraint.js"],"names":["module","exports","DistanceConstraint","Constraint","require","ContactEquation","bodyA","bodyB","distance","maxForce","call","position","distanceTo","eq","distanceEquation","equations","push","minForce","prototype","update","halfDist","normal","ni","vsub","normalize","mult","ri","rj"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,kBAAjB;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIC,eAAe,GAAGD,OAAO,CAAC,8BAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,kBAAT,CAA4BI,KAA5B,EAAkCC,KAAlC,EAAwCC,QAAxC,EAAiDC,QAAjD,EAA0D;AACtDN,EAAAA,UAAU,CAACO,IAAX,CAAgB,IAAhB,EAAqBJ,KAArB,EAA2BC,KAA3B;;AAEA,MAAG,OAAOC,QAAP,KAAmB,WAAtB,EAAmC;AAC/BA,IAAAA,QAAQ,GAAGF,KAAK,CAACK,QAAN,CAAeC,UAAf,CAA0BL,KAAK,CAACI,QAAhC,CAAX;AACH;;AAED,MAAG,OAAOF,QAAP,KAAmB,WAAtB,EAAmC;AAC/BA,IAAAA,QAAQ,GAAG,GAAX;AACH;AAED;AACJ;AACA;;;AACI,OAAKD,QAAL,GAAgBA,QAAhB;AAEA;AACJ;AACA;;AACI,MAAIK,EAAE,GAAG,KAAKC,gBAAL,GAAwB,IAAIT,eAAJ,CAAoBC,KAApB,EAA2BC,KAA3B,CAAjC;AACA,OAAKQ,SAAL,CAAeC,IAAf,CAAoBH,EAApB,EApBsD,CAsBtD;;AACAA,EAAAA,EAAE,CAACI,QAAH,GAAc,CAACR,QAAf;AACAI,EAAAA,EAAE,CAACJ,QAAH,GAAeA,QAAf;AACH;;AACDP,kBAAkB,CAACgB,SAAnB,GAA+B,IAAIf,UAAJ,EAA/B;;AAEAD,kBAAkB,CAACgB,SAAnB,CAA6BC,MAA7B,GAAsC,YAAU;AAC5C,MAAIb,KAAK,GAAG,KAAKA,KAAjB;AACA,MAAIC,KAAK,GAAG,KAAKA,KAAjB;AACA,MAAIM,EAAE,GAAG,KAAKC,gBAAd;AACA,MAAIM,QAAQ,GAAG,KAAKZ,QAAL,GAAgB,GAA/B;AACA,MAAIa,MAAM,GAAGR,EAAE,CAACS,EAAhB;AAEAf,EAAAA,KAAK,CAACI,QAAN,CAAeY,IAAf,CAAoBjB,KAAK,CAACK,QAA1B,EAAoCU,MAApC;AACAA,EAAAA,MAAM,CAACG,SAAP;AACAH,EAAAA,MAAM,CAACI,IAAP,CAAYL,QAAZ,EAAsBP,EAAE,CAACa,EAAzB;AACAL,EAAAA,MAAM,CAACI,IAAP,CAAY,CAACL,QAAb,EAAuBP,EAAE,CAACc,EAA1B;AACH,CAXD","sourcesContent":["module.exports = DistanceConstraint;\n\nvar Constraint = require('./Constraint');\nvar ContactEquation = require('../equations/ContactEquation');\n\n/**\n * Constrains two bodies to be at a constant distance from each others center of mass.\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB\n * @param {Number} [maxForce=1e6]\n * @extends Constraint\n */\nfunction DistanceConstraint(bodyA,bodyB,distance,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    if(typeof(distance)===\"undefined\") {\n        distance = bodyA.position.distanceTo(bodyB.position);\n    }\n\n    if(typeof(maxForce)===\"undefined\") {\n        maxForce = 1e6;\n    }\n\n    /**\n     * @property {number} distance\n     */\n    this.distance = distance;\n\n    /**\n     * @property {ContactEquation} distanceEquation\n     */\n    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);\n    this.equations.push(eq);\n\n    // Make it bidirectional\n    eq.minForce = -maxForce;\n    eq.maxForce =  maxForce;\n}\nDistanceConstraint.prototype = new Constraint();\n\nDistanceConstraint.prototype.update = function(){\n    var bodyA = this.bodyA;\n    var bodyB = this.bodyB;\n    var eq = this.distanceEquation;\n    var halfDist = this.distance * 0.5;\n    var normal = eq.ni;\n\n    bodyB.position.vsub(bodyA.position, normal);\n    normal.normalize();\n    normal.mult(halfDist, eq.ri);\n    normal.mult(-halfDist, eq.rj);\n};"]},"metadata":{},"sourceType":"script"}