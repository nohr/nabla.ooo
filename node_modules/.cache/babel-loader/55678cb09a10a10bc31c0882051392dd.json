{"ast":null,"code":"module.exports = Equation;\n\nvar JacobianElement = require('../math/JacobianElement'),\n    Vec3 = require('../math/Vec3');\n/**\n * Equation base class\n * @class Equation\n * @constructor\n * @author schteppe\n * @param {Body} bi\n * @param {Body} bj\n * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.\n * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.\n */\n\n\nfunction Equation(bi, bj, minForce, maxForce) {\n  this.id = Equation.id++;\n  /**\n   * @property {number} minForce\n   */\n\n  this.minForce = typeof minForce === \"undefined\" ? -1e6 : minForce;\n  /**\n   * @property {number} maxForce\n   */\n\n  this.maxForce = typeof maxForce === \"undefined\" ? 1e6 : maxForce;\n  /**\n   * @property bi\n   * @type {Body}\n   */\n\n  this.bi = bi;\n  /**\n   * @property bj\n   * @type {Body}\n   */\n\n  this.bj = bj;\n  /**\n   * SPOOK parameter\n   * @property {number} a\n   */\n\n  this.a = 0.0;\n  /**\n   * SPOOK parameter\n   * @property {number} b\n   */\n\n  this.b = 0.0;\n  /**\n   * SPOOK parameter\n   * @property {number} eps\n   */\n\n  this.eps = 0.0;\n  /**\n   * @property {JacobianElement} jacobianElementA\n   */\n\n  this.jacobianElementA = new JacobianElement();\n  /**\n   * @property {JacobianElement} jacobianElementB\n   */\n\n  this.jacobianElementB = new JacobianElement();\n  /**\n   * @property {boolean} enabled\n   * @default true\n   */\n\n  this.enabled = true;\n  /**\n   * A number, proportional to the force added to the bodies.\n   * @property {number} multiplier\n   * @readonly\n   */\n\n  this.multiplier = 0; // Set typical spook params\n\n  this.setSpookParams(1e7, 4, 1 / 60);\n}\n\nEquation.prototype.constructor = Equation;\nEquation.id = 0;\n/**\n * Recalculates a,b,eps.\n * @method setSpookParams\n */\n\nEquation.prototype.setSpookParams = function (stiffness, relaxation, timeStep) {\n  var d = relaxation,\n      k = stiffness,\n      h = timeStep;\n  this.a = 4.0 / (h * (1 + 4 * d));\n  this.b = 4.0 * d / (1 + 4 * d);\n  this.eps = 4.0 / (h * h * k * (1 + 4 * d));\n};\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\n\n\nEquation.prototype.computeB = function (a, b, h) {\n  var GW = this.computeGW(),\n      Gq = this.computeGq(),\n      GiMf = this.computeGiMf();\n  return -Gq * a - GW * b - GiMf * h;\n};\n/**\n * Computes G*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\n\n\nEquation.prototype.computeGq = function () {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      xi = bi.position,\n      xj = bj.position;\n  return GA.spatial.dot(xi) + GB.spatial.dot(xj);\n};\n\nvar zero = new Vec3();\n/**\n * Computes G*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\n\nEquation.prototype.computeGW = function () {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      vi = bi.velocity,\n      vj = bj.velocity,\n      wi = bi.angularVelocity,\n      wj = bj.angularVelocity;\n  return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);\n};\n/**\n * Computes G*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\n\n\nEquation.prototype.computeGWlambda = function () {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      vi = bi.vlambda,\n      vj = bj.vlambda,\n      wi = bi.wlambda,\n      wj = bj.wlambda;\n  return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);\n};\n/**\n * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\n\n\nvar iMfi = new Vec3(),\n    iMfj = new Vec3(),\n    invIi_vmult_taui = new Vec3(),\n    invIj_vmult_tauj = new Vec3();\n\nEquation.prototype.computeGiMf = function () {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      fi = bi.force,\n      ti = bi.torque,\n      fj = bj.force,\n      tj = bj.torque,\n      invMassi = bi.invMassSolve,\n      invMassj = bj.invMassSolve;\n  fi.scale(invMassi, iMfi);\n  fj.scale(invMassj, iMfj);\n  bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);\n  bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);\n  return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);\n};\n/**\n * Computes G*inv(M)*G'\n * @method computeGiMGt\n * @return {Number}\n */\n\n\nvar tmp = new Vec3();\n\nEquation.prototype.computeGiMGt = function () {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      invMassi = bi.invMassSolve,\n      invMassj = bj.invMassSolve,\n      invIi = bi.invInertiaWorldSolve,\n      invIj = bj.invInertiaWorldSolve,\n      result = invMassi + invMassj;\n  invIi.vmult(GA.rotational, tmp);\n  result += tmp.dot(GA.rotational);\n  invIj.vmult(GB.rotational, tmp);\n  result += tmp.dot(GB.rotational);\n  return result;\n};\n\nvar addToWlambda_temp = new Vec3(),\n    addToWlambda_Gi = new Vec3(),\n    addToWlambda_Gj = new Vec3(),\n    addToWlambda_ri = new Vec3(),\n    addToWlambda_rj = new Vec3(),\n    addToWlambda_Mdiag = new Vec3();\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\n\nEquation.prototype.addToWlambda = function (deltalambda) {\n  var GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      bi = this.bi,\n      bj = this.bj,\n      temp = addToWlambda_temp; // Add to linear velocity\n  // v_lambda += inv(M) * delta_lamba * G\n\n  bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);\n  bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity\n\n  bi.invInertiaWorldSolve.vmult(GA.rotational, temp);\n  bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);\n  bj.invInertiaWorldSolve.vmult(GB.rotational, temp);\n  bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);\n};\n/**\n * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\n\n\nEquation.prototype.computeC = function () {\n  return this.computeGiMGt() + this.eps;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/Equation.js"],"names":["module","exports","Equation","JacobianElement","require","Vec3","bi","bj","minForce","maxForce","id","a","b","eps","jacobianElementA","jacobianElementB","enabled","multiplier","setSpookParams","prototype","constructor","stiffness","relaxation","timeStep","d","k","h","computeB","GW","computeGW","Gq","computeGq","GiMf","computeGiMf","GA","GB","xi","position","xj","spatial","dot","zero","vi","velocity","vj","wi","angularVelocity","wj","multiplyVectors","computeGWlambda","vlambda","wlambda","iMfi","iMfj","invIi_vmult_taui","invIj_vmult_tauj","fi","force","ti","torque","fj","tj","invMassi","invMassSolve","invMassj","scale","invInertiaWorldSolve","vmult","tmp","computeGiMGt","invIi","invIj","result","rotational","addToWlambda_temp","addToWlambda_Gi","addToWlambda_Gj","addToWlambda_ri","addToWlambda_rj","addToWlambda_Mdiag","addToWlambda","deltalambda","temp","addScaledVector","computeC"],"mappings":"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","sourcesContent":["module.exports = Equation;\n\nvar JacobianElement = require('../math/JacobianElement'),\n    Vec3 = require('../math/Vec3');\n\n/**\n * Equation base class\n * @class Equation\n * @constructor\n * @author schteppe\n * @param {Body} bi\n * @param {Body} bj\n * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.\n * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.\n */\nfunction Equation(bi,bj,minForce,maxForce){\n    this.id = Equation.id++;\n\n    /**\n     * @property {number} minForce\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -1e6 : minForce;\n\n    /**\n     * @property {number} maxForce\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? 1e6 : maxForce;\n\n    /**\n     * @property bi\n     * @type {Body}\n     */\n    this.bi = bi;\n\n    /**\n     * @property bj\n     * @type {Body}\n     */\n    this.bj = bj;\n\n    /**\n     * SPOOK parameter\n     * @property {number} a\n     */\n    this.a = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} b\n     */\n    this.b = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} eps\n     */\n    this.eps = 0.0;\n\n    /**\n     * @property {JacobianElement} jacobianElementA\n     */\n    this.jacobianElementA = new JacobianElement();\n\n    /**\n     * @property {JacobianElement} jacobianElementB\n     */\n    this.jacobianElementB = new JacobianElement();\n\n    /**\n     * @property {boolean} enabled\n     * @default true\n     */\n    this.enabled = true;\n\n    /**\n     * A number, proportional to the force added to the bodies.\n     * @property {number} multiplier\n     * @readonly\n     */\n    this.multiplier = 0;\n\n    // Set typical spook params\n    this.setSpookParams(1e7,4,1/60);\n}\nEquation.prototype.constructor = Equation;\n\nEquation.id = 0;\n\n/**\n * Recalculates a,b,eps.\n * @method setSpookParams\n */\nEquation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){\n    var d = relaxation,\n        k = stiffness,\n        h = timeStep;\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.eps = 4.0 / (h * h * k * (1 + 4 * d));\n};\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW(),\n        Gq = this.computeGq(),\n        GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nEquation.prototype.computeGq = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        xi = bi.position,\n        xj = bj.position;\n    return GA.spatial.dot(xi) + GB.spatial.dot(xj);\n};\n\nvar zero = new Vec3();\n\n/**\n * Computes G*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity,\n        wj = bj.angularVelocity;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n\n/**\n * Computes G*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda,\n        wj = bj.wlambda;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n/**\n * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = new Vec3(),\n    iMfj = new Vec3(),\n    invIi_vmult_taui = new Vec3(),\n    invIj_vmult_tauj = new Vec3();\nEquation.prototype.computeGiMf = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        fi = bi.force,\n        ti = bi.torque,\n        fj = bj.force,\n        tj = bj.torque,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve;\n\n    fi.scale(invMassi,iMfi);\n    fj.scale(invMassj,iMfj);\n\n    bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui);\n    bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj);\n\n    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);\n};\n\n/**\n * Computes G*inv(M)*G'\n * @method computeGiMGt\n * @return {Number}\n */\nvar tmp = new Vec3();\nEquation.prototype.computeGiMGt = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaWorldSolve,\n        invIj = bj.invInertiaWorldSolve,\n        result = invMassi + invMassj;\n\n    invIi.vmult(GA.rotational,tmp);\n    result += tmp.dot(GA.rotational);\n\n    invIj.vmult(GB.rotational,tmp);\n    result += tmp.dot(GB.rotational);\n\n    return  result;\n};\n\nvar addToWlambda_temp = new Vec3(),\n    addToWlambda_Gi = new Vec3(),\n    addToWlambda_Gj = new Vec3(),\n    addToWlambda_ri = new Vec3(),\n    addToWlambda_rj = new Vec3(),\n    addToWlambda_Mdiag = new Vec3();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        temp = addToWlambda_temp;\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);\n    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);\n\n    // Add to angular velocity\n    bi.invInertiaWorldSolve.vmult(GA.rotational,temp);\n    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);\n\n    bj.invInertiaWorldSolve.vmult(GB.rotational,temp);\n    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeC = function(){\n    return this.computeGiMGt() + this.eps;\n};\n"]},"metadata":{},"sourceType":"script"}