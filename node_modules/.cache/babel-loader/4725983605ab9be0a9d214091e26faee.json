{"ast":null,"code":"module.exports = Plane;\n\nvar Shape = require('./Shape');\n\nvar Vec3 = require('../math/Vec3');\n/**\n * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.\n * @class Plane\n * @constructor\n * @extends Shape\n * @author schteppe\n */\n\n\nfunction Plane() {\n  Shape.call(this, {\n    type: Shape.types.PLANE\n  }); // World oriented normal\n\n  this.worldNormal = new Vec3();\n  this.worldNormalNeedsUpdate = true;\n  this.boundingSphereRadius = Number.MAX_VALUE;\n}\n\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\nPlane.prototype.computeWorldNormal = function (quat) {\n  var n = this.worldNormal;\n  n.set(0, 0, 1);\n  quat.vmult(n, n);\n  this.worldNormalNeedsUpdate = false;\n};\n\nPlane.prototype.calculateLocalInertia = function (mass, target) {\n  target = target || new Vec3();\n  return target;\n};\n\nPlane.prototype.volume = function () {\n  return Number.MAX_VALUE; // The plane is infinite...\n};\n\nvar tempNormal = new Vec3();\n\nPlane.prototype.calculateWorldAABB = function (pos, quat, min, max) {\n  // The plane AABB is infinite, except if the normal is pointing along any axis\n  tempNormal.set(0, 0, 1); // Default plane normal is z\n\n  quat.vmult(tempNormal, tempNormal);\n  var maxVal = Number.MAX_VALUE;\n  min.set(-maxVal, -maxVal, -maxVal);\n  max.set(maxVal, maxVal, maxVal);\n\n  if (tempNormal.x === 1) {\n    max.x = pos.x;\n  }\n\n  if (tempNormal.y === 1) {\n    max.y = pos.y;\n  }\n\n  if (tempNormal.z === 1) {\n    max.z = pos.z;\n  }\n\n  if (tempNormal.x === -1) {\n    min.x = pos.x;\n  }\n\n  if (tempNormal.y === -1) {\n    min.y = pos.y;\n  }\n\n  if (tempNormal.z === -1) {\n    min.z = pos.z;\n  }\n};\n\nPlane.prototype.updateBoundingSphereRadius = function () {\n  this.boundingSphereRadius = Number.MAX_VALUE;\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/shapes/Plane.js"],"names":["module","exports","Plane","Shape","require","Vec3","call","type","types","PLANE","worldNormal","worldNormalNeedsUpdate","boundingSphereRadius","Number","MAX_VALUE","prototype","constructor","computeWorldNormal","quat","n","set","vmult","calculateLocalInertia","mass","target","volume","tempNormal","calculateWorldAABB","pos","min","max","maxVal","x","y","z","updateBoundingSphereRadius"],"mappings":"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","sourcesContent":["module.exports = Plane;\n\nvar Shape = require('./Shape');\nvar Vec3 = require('../math/Vec3');\n\n/**\n * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.\n * @class Plane\n * @constructor\n * @extends Shape\n * @author schteppe\n */\nfunction Plane(){\n    Shape.call(this, {\n        type: Shape.types.PLANE\n    });\n\n    // World oriented normal\n    this.worldNormal = new Vec3();\n    this.worldNormalNeedsUpdate = true;\n\n    this.boundingSphereRadius = Number.MAX_VALUE;\n}\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\nPlane.prototype.computeWorldNormal = function(quat){\n    var n = this.worldNormal;\n    n.set(0,0,1);\n    quat.vmult(n,n);\n    this.worldNormalNeedsUpdate = false;\n};\n\nPlane.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    return target;\n};\n\nPlane.prototype.volume = function(){\n    return Number.MAX_VALUE; // The plane is infinite...\n};\n\nvar tempNormal = new Vec3();\nPlane.prototype.calculateWorldAABB = function(pos, quat, min, max){\n    // The plane AABB is infinite, except if the normal is pointing along any axis\n    tempNormal.set(0,0,1); // Default plane normal is z\n    quat.vmult(tempNormal,tempNormal);\n    var maxVal = Number.MAX_VALUE;\n    min.set(-maxVal, -maxVal, -maxVal);\n    max.set(maxVal, maxVal, maxVal);\n\n    if(tempNormal.x === 1){ max.x = pos.x; }\n    if(tempNormal.y === 1){ max.y = pos.y; }\n    if(tempNormal.z === 1){ max.z = pos.z; }\n\n    if(tempNormal.x === -1){ min.x = pos.x; }\n    if(tempNormal.y === -1){ min.y = pos.y; }\n    if(tempNormal.z === -1){ min.z = pos.z; }\n};\n\nPlane.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = Number.MAX_VALUE;\n};"]},"metadata":{},"sourceType":"script"}