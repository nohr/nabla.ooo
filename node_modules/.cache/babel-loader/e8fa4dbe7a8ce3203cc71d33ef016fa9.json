{"ast":null,"code":"var Body = require('../objects/Body');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Shape = require('../shapes/Shape');\n\nvar Plane = require('../shapes/Plane');\n\nmodule.exports = Broadphase;\n/**\n * Base class for broadphase implementations\n * @class Broadphase\n * @constructor\n * @author schteppe\n */\n\nfunction Broadphase() {\n  /**\n  * The world to search for collisions in.\n  * @property world\n  * @type {World}\n  */\n  this.world = null;\n  /**\n   * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.\n   * @property useBoundingBoxes\n   * @type {Boolean}\n   */\n\n  this.useBoundingBoxes = false;\n  /**\n   * Set to true if the objects in the world moved.\n   * @property {Boolean} dirty\n   */\n\n  this.dirty = true;\n}\n/**\n * Get the collision pairs from the world\n * @method collisionPairs\n * @param {World} world The world to search in\n * @param {Array} p1 Empty array to be filled with body objects\n * @param {Array} p2 Empty array to be filled with body objects\n */\n\n\nBroadphase.prototype.collisionPairs = function (world, p1, p2) {\n  throw new Error(\"collisionPairs not implemented for this BroadPhase class!\");\n};\n/**\n * Check if a body pair needs to be intersection tested at all.\n * @method needBroadphaseCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {bool}\n */\n\n\nBroadphase.prototype.needBroadphaseCollision = function (bodyA, bodyB) {\n  // Check collision filter masks\n  if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {\n    return false;\n  } // Check types\n\n\n  if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {\n    // Both bodies are static or sleeping. Skip.\n    return false;\n  }\n\n  return true;\n};\n/**\n * Check if the bounding volumes of two bodies intersect.\n * @method intersectionTest\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {array} pairs1\n * @param {array} pairs2\n  */\n\n\nBroadphase.prototype.intersectionTest = function (bodyA, bodyB, pairs1, pairs2) {\n  if (this.useBoundingBoxes) {\n    this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);\n  } else {\n    this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);\n  }\n};\n/**\n * Check if the bounding spheres of two bodies are intersecting.\n * @method doBoundingSphereBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1 bodyA is appended to this array if intersection\n * @param {Array} pairs2 bodyB is appended to this array if intersection\n */\n\n\nvar Broadphase_collisionPairs_r = new Vec3(),\n    // Temp objects\nBroadphase_collisionPairs_normal = new Vec3(),\n    Broadphase_collisionPairs_quat = new Quaternion(),\n    Broadphase_collisionPairs_relpos = new Vec3();\n\nBroadphase.prototype.doBoundingSphereBroadphase = function (bodyA, bodyB, pairs1, pairs2) {\n  var r = Broadphase_collisionPairs_r;\n  bodyB.position.vsub(bodyA.position, r);\n  var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);\n  var norm2 = r.norm2();\n\n  if (norm2 < boundingRadiusSum2) {\n    pairs1.push(bodyA);\n    pairs2.push(bodyB);\n  }\n};\n/**\n * Check if the bounding boxes of two bodies are intersecting.\n * @method doBoundingBoxBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\n\n\nBroadphase.prototype.doBoundingBoxBroadphase = function (bodyA, bodyB, pairs1, pairs2) {\n  if (bodyA.aabbNeedsUpdate) {\n    bodyA.computeAABB();\n  }\n\n  if (bodyB.aabbNeedsUpdate) {\n    bodyB.computeAABB();\n  } // Check AABB / AABB\n\n\n  if (bodyA.aabb.overlaps(bodyB.aabb)) {\n    pairs1.push(bodyA);\n    pairs2.push(bodyB);\n  }\n};\n/**\n * Removes duplicate pairs from the pair arrays.\n * @method makePairsUnique\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\n\n\nvar Broadphase_makePairsUnique_temp = {\n  keys: []\n},\n    Broadphase_makePairsUnique_p1 = [],\n    Broadphase_makePairsUnique_p2 = [];\n\nBroadphase.prototype.makePairsUnique = function (pairs1, pairs2) {\n  var t = Broadphase_makePairsUnique_temp,\n      p1 = Broadphase_makePairsUnique_p1,\n      p2 = Broadphase_makePairsUnique_p2,\n      N = pairs1.length;\n\n  for (var i = 0; i !== N; i++) {\n    p1[i] = pairs1[i];\n    p2[i] = pairs2[i];\n  }\n\n  pairs1.length = 0;\n  pairs2.length = 0;\n\n  for (var i = 0; i !== N; i++) {\n    var id1 = p1[i].id,\n        id2 = p2[i].id;\n    var key = id1 < id2 ? id1 + \",\" + id2 : id2 + \",\" + id1;\n    t[key] = i;\n    t.keys.push(key);\n  }\n\n  for (var i = 0; i !== t.keys.length; i++) {\n    var key = t.keys.pop(),\n        pairIndex = t[key];\n    pairs1.push(p1[pairIndex]);\n    pairs2.push(p2[pairIndex]);\n    delete t[key];\n  }\n};\n/**\n * To be implemented by subcasses\n * @method setWorld\n * @param {World} world\n */\n\n\nBroadphase.prototype.setWorld = function (world) {};\n/**\n * Check if the bounding spheres of two bodies overlap.\n * @method boundingSphereCheck\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {boolean}\n */\n\n\nvar bsc_dist = new Vec3();\n\nBroadphase.boundingSphereCheck = function (bodyA, bodyB) {\n  var dist = bsc_dist;\n  bodyA.position.vsub(bodyB.position, dist);\n  return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();\n};\n/**\n * Returns all the bodies within the AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param  {array} result An array to store resulting bodies in.\n * @return {array}\n */\n\n\nBroadphase.prototype.aabbQuery = function (world, aabb, result) {\n  console.warn('.aabbQuery is not implemented in this Broadphase subclass.');\n  return [];\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/collision/Broadphase.js"],"names":["Body","require","Vec3","Quaternion","Shape","Plane","module","exports","Broadphase","world","useBoundingBoxes","dirty","prototype","collisionPairs","p1","p2","Error","needBroadphaseCollision","bodyA","bodyB","collisionFilterGroup","collisionFilterMask","type","STATIC","sleepState","SLEEPING","intersectionTest","pairs1","pairs2","doBoundingBoxBroadphase","doBoundingSphereBroadphase","Broadphase_collisionPairs_r","Broadphase_collisionPairs_normal","Broadphase_collisionPairs_quat","Broadphase_collisionPairs_relpos","r","position","vsub","boundingRadiusSum2","Math","pow","boundingRadius","norm2","push","aabbNeedsUpdate","computeAABB","aabb","overlaps","Broadphase_makePairsUnique_temp","keys","Broadphase_makePairsUnique_p1","Broadphase_makePairsUnique_p2","makePairsUnique","t","N","length","i","id1","id","id2","key","pop","pairIndex","setWorld","bsc_dist","boundingSphereCheck","dist","shape","boundingSphereRadius","aabbQuery","result","console","warn"],"mappings":"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","sourcesContent":["var Body = require('../objects/Body');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Shape = require('../shapes/Shape');\nvar Plane = require('../shapes/Plane');\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations\n * @class Broadphase\n * @constructor\n * @author schteppe\n */\nfunction Broadphase(){\n    /**\n    * The world to search for collisions in.\n    * @property world\n    * @type {World}\n    */\n    this.world = null;\n\n    /**\n     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.\n     * @property useBoundingBoxes\n     * @type {Boolean}\n     */\n    this.useBoundingBoxes = false;\n\n    /**\n     * Set to true if the objects in the world moved.\n     * @property {Boolean} dirty\n     */\n    this.dirty = true;\n}\n\n/**\n * Get the collision pairs from the world\n * @method collisionPairs\n * @param {World} world The world to search in\n * @param {Array} p1 Empty array to be filled with body objects\n * @param {Array} p2 Empty array to be filled with body objects\n */\nBroadphase.prototype.collisionPairs = function(world,p1,p2){\n    throw new Error(\"collisionPairs not implemented for this BroadPhase class!\");\n};\n\n/**\n * Check if a body pair needs to be intersection tested at all.\n * @method needBroadphaseCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {bool}\n */\nBroadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){\n\n    // Check collision filter masks\n    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){\n        return false;\n    }\n\n    // Check types\n    if(((bodyA.type & Body.STATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&\n       ((bodyB.type & Body.STATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {\n        // Both bodies are static or sleeping. Skip.\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if the bounding volumes of two bodies intersect.\n * @method intersectionTest\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {array} pairs1\n * @param {array} pairs2\n  */\nBroadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){\n    if(this.useBoundingBoxes){\n        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);\n    } else {\n        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);\n    }\n};\n\n/**\n * Check if the bounding spheres of two bodies are intersecting.\n * @method doBoundingSphereBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1 bodyA is appended to this array if intersection\n * @param {Array} pairs2 bodyB is appended to this array if intersection\n */\nvar Broadphase_collisionPairs_r = new Vec3(), // Temp objects\n    Broadphase_collisionPairs_normal =  new Vec3(),\n    Broadphase_collisionPairs_quat =  new Quaternion(),\n    Broadphase_collisionPairs_relpos  =  new Vec3();\nBroadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){\n    var r = Broadphase_collisionPairs_r;\n    bodyB.position.vsub(bodyA.position,r);\n    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);\n    var norm2 = r.norm2();\n    if(norm2 < boundingRadiusSum2){\n        pairs1.push(bodyA);\n        pairs2.push(bodyB);\n    }\n};\n\n/**\n * Check if the bounding boxes of two bodies are intersecting.\n * @method doBoundingBoxBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nBroadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){\n    if(bodyA.aabbNeedsUpdate){\n        bodyA.computeAABB();\n    }\n    if(bodyB.aabbNeedsUpdate){\n        bodyB.computeAABB();\n    }\n\n    // Check AABB / AABB\n    if(bodyA.aabb.overlaps(bodyB.aabb)){\n        pairs1.push(bodyA);\n        pairs2.push(bodyB);\n    }\n};\n\n/**\n * Removes duplicate pairs from the pair arrays.\n * @method makePairsUnique\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nvar Broadphase_makePairsUnique_temp = { keys:[] },\n    Broadphase_makePairsUnique_p1 = [],\n    Broadphase_makePairsUnique_p2 = [];\nBroadphase.prototype.makePairsUnique = function(pairs1,pairs2){\n    var t = Broadphase_makePairsUnique_temp,\n        p1 = Broadphase_makePairsUnique_p1,\n        p2 = Broadphase_makePairsUnique_p2,\n        N = pairs1.length;\n\n    for(var i=0; i!==N; i++){\n        p1[i] = pairs1[i];\n        p2[i] = pairs2[i];\n    }\n\n    pairs1.length = 0;\n    pairs2.length = 0;\n\n    for(var i=0; i!==N; i++){\n        var id1 = p1[i].id,\n            id2 = p2[i].id;\n        var key = id1 < id2 ? id1+\",\"+id2 :  id2+\",\"+id1;\n        t[key] = i;\n        t.keys.push(key);\n    }\n\n    for(var i=0; i!==t.keys.length; i++){\n        var key = t.keys.pop(),\n            pairIndex = t[key];\n        pairs1.push(p1[pairIndex]);\n        pairs2.push(p2[pairIndex]);\n        delete t[key];\n    }\n};\n\n/**\n * To be implemented by subcasses\n * @method setWorld\n * @param {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n};\n\n/**\n * Check if the bounding spheres of two bodies overlap.\n * @method boundingSphereCheck\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {boolean}\n */\nvar bsc_dist = new Vec3();\nBroadphase.boundingSphereCheck = function(bodyA,bodyB){\n    var dist = bsc_dist;\n    bodyA.position.vsub(bodyB.position,dist);\n    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();\n};\n\n/**\n * Returns all the bodies within the AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param  {array} result An array to store resulting bodies in.\n * @return {array}\n */\nBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');\n    return [];\n};"]},"metadata":{},"sourceType":"script"}