{"ast":null,"code":"module.exports = Trimesh;\n\nvar Shape = require('./Shape');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Quaternion = require('../math/Quaternion');\n\nvar Transform = require('../math/Transform');\n\nvar AABB = require('../collision/AABB');\n\nvar Octree = require('../utils/Octree');\n/**\n * @class Trimesh\n * @constructor\n * @param {array} vertices\n * @param {array} indices\n * @extends Shape\n * @example\n *     // How to make a mesh with a single triangle\n *     var vertices = [\n *         0, 0, 0, // vertex 0\n *         1, 0, 0, // vertex 1\n *         0, 1, 0  // vertex 2\n *     ];\n *     var indices = [\n *         0, 1, 2  // triangle 0\n *     ];\n *     var trimeshShape = new Trimesh(vertices, indices);\n */\n\n\nfunction Trimesh(vertices, indices) {\n  Shape.call(this, {\n    type: Shape.types.TRIMESH\n  });\n  /**\n   * @property vertices\n   * @type {Array}\n   */\n\n  this.vertices = new Float32Array(vertices);\n  /**\n   * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.\n   * @property indices\n   * @type {Array}\n   */\n\n  this.indices = new Int16Array(indices);\n  /**\n   * The normals data.\n   * @property normals\n   * @type {Array}\n   */\n\n  this.normals = new Float32Array(indices.length);\n  /**\n   * The local AABB of the mesh.\n   * @property aabb\n   * @type {Array}\n   */\n\n  this.aabb = new AABB();\n  /**\n   * References to vertex pairs, making up all unique edges in the trimesh.\n   * @property {array} edges\n   */\n\n  this.edges = null;\n  /**\n   * Local scaling of the mesh. Use .setScale() to set it.\n   * @property {Vec3} scale\n   */\n\n  this.scale = new Vec3(1, 1, 1);\n  /**\n   * The indexed triangles. Use .updateTree() to update it.\n   * @property {Octree} tree\n   */\n\n  this.tree = new Octree();\n  this.updateEdges();\n  this.updateNormals();\n  this.updateAABB();\n  this.updateBoundingSphereRadius();\n  this.updateTree();\n}\n\nTrimesh.prototype = new Shape();\nTrimesh.prototype.constructor = Trimesh;\nvar computeNormals_n = new Vec3();\n/**\n * @method updateTree\n */\n\nTrimesh.prototype.updateTree = function () {\n  var tree = this.tree;\n  tree.reset();\n  tree.aabb.copy(this.aabb);\n  var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled\n\n  tree.aabb.lowerBound.x *= 1 / scale.x;\n  tree.aabb.lowerBound.y *= 1 / scale.y;\n  tree.aabb.lowerBound.z *= 1 / scale.z;\n  tree.aabb.upperBound.x *= 1 / scale.x;\n  tree.aabb.upperBound.y *= 1 / scale.y;\n  tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles\n\n  var triangleAABB = new AABB();\n  var a = new Vec3();\n  var b = new Vec3();\n  var c = new Vec3();\n  var points = [a, b, c];\n\n  for (var i = 0; i < this.indices.length / 3; i++) {\n    //this.getTriangleVertices(i, a, b, c);\n    // Get unscaled triangle verts\n    var i3 = i * 3;\n\n    this._getUnscaledVertex(this.indices[i3], a);\n\n    this._getUnscaledVertex(this.indices[i3 + 1], b);\n\n    this._getUnscaledVertex(this.indices[i3 + 2], c);\n\n    triangleAABB.setFromPoints(points);\n    tree.insert(triangleAABB, i);\n  }\n\n  tree.removeEmptyNodes();\n};\n\nvar unscaledAABB = new AABB();\n/**\n * Get triangles in a local AABB from the trimesh.\n * @method getTrianglesInAABB\n * @param  {AABB} aabb\n * @param  {array} result An array of integers, referencing the queried triangles.\n */\n\nTrimesh.prototype.getTrianglesInAABB = function (aabb, result) {\n  unscaledAABB.copy(aabb); // Scale it to local\n\n  var scale = this.scale;\n  var isx = scale.x;\n  var isy = scale.y;\n  var isz = scale.z;\n  var l = unscaledAABB.lowerBound;\n  var u = unscaledAABB.upperBound;\n  l.x /= isx;\n  l.y /= isy;\n  l.z /= isz;\n  u.x /= isx;\n  u.y /= isy;\n  u.z /= isz;\n  return this.tree.aabbQuery(unscaledAABB, result);\n};\n/**\n * @method setScale\n * @param {Vec3} scale\n */\n\n\nTrimesh.prototype.setScale = function (scale) {\n  var wasUniform = this.scale.x === this.scale.y === this.scale.z;\n  var isUniform = scale.x === scale.y === scale.z;\n\n  if (!(wasUniform && isUniform)) {\n    // Non-uniform scaling. Need to update normals.\n    this.updateNormals();\n  }\n\n  this.scale.copy(scale);\n  this.updateAABB();\n  this.updateBoundingSphereRadius();\n};\n/**\n * Compute the normals of the faces. Will save in the .normals array.\n * @method updateNormals\n */\n\n\nTrimesh.prototype.updateNormals = function () {\n  var n = computeNormals_n; // Generate normals\n\n  var normals = this.normals;\n\n  for (var i = 0; i < this.indices.length / 3; i++) {\n    var i3 = i * 3;\n    var a = this.indices[i3],\n        b = this.indices[i3 + 1],\n        c = this.indices[i3 + 2];\n    this.getVertex(a, va);\n    this.getVertex(b, vb);\n    this.getVertex(c, vc);\n    Trimesh.computeNormal(vb, va, vc, n);\n    normals[i3] = n.x;\n    normals[i3 + 1] = n.y;\n    normals[i3 + 2] = n.z;\n  }\n};\n/**\n * Update the .edges property\n * @method updateEdges\n */\n\n\nTrimesh.prototype.updateEdges = function () {\n  var edges = {};\n\n  var add = function (indexA, indexB) {\n    var key = a < b ? a + '_' + b : b + '_' + a;\n    edges[key] = true;\n  };\n\n  for (var i = 0; i < this.indices.length / 3; i++) {\n    var i3 = i * 3;\n    var a = this.indices[i3],\n        b = this.indices[i3 + 1],\n        c = this.indices[i3 + 2];\n    add(a, b);\n    add(b, c);\n    add(c, a);\n  }\n\n  var keys = Object.keys(edges);\n  this.edges = new Int16Array(keys.length * 2);\n\n  for (var i = 0; i < keys.length; i++) {\n    var indices = keys[i].split('_');\n    this.edges[2 * i] = parseInt(indices[0], 10);\n    this.edges[2 * i + 1] = parseInt(indices[1], 10);\n  }\n};\n/**\n * Get an edge vertex\n * @method getEdgeVertex\n * @param  {number} edgeIndex\n * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.\n * @param  {Vec3} vertexStore Where to store the result\n */\n\n\nTrimesh.prototype.getEdgeVertex = function (edgeIndex, firstOrSecond, vertexStore) {\n  var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];\n  this.getVertex(vertexIndex, vertexStore);\n};\n\nvar getEdgeVector_va = new Vec3();\nvar getEdgeVector_vb = new Vec3();\n/**\n * Get a vector along an edge.\n * @method getEdgeVector\n * @param  {number} edgeIndex\n * @param  {Vec3} vectorStore\n */\n\nTrimesh.prototype.getEdgeVector = function (edgeIndex, vectorStore) {\n  var va = getEdgeVector_va;\n  var vb = getEdgeVector_vb;\n  this.getEdgeVertex(edgeIndex, 0, va);\n  this.getEdgeVertex(edgeIndex, 1, vb);\n  vb.vsub(va, vectorStore);\n};\n/**\n * Get face normal given 3 vertices\n * @static\n * @method computeNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\n\n\nvar cb = new Vec3();\nvar ab = new Vec3();\n\nTrimesh.computeNormal = function (va, vb, vc, target) {\n  vb.vsub(va, ab);\n  vc.vsub(vb, cb);\n  cb.cross(ab, target);\n\n  if (!target.isZero()) {\n    target.normalize();\n  }\n};\n\nvar va = new Vec3();\nvar vb = new Vec3();\nvar vc = new Vec3();\n/**\n * Get vertex i.\n * @method getVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\n\nTrimesh.prototype.getVertex = function (i, out) {\n  var scale = this.scale;\n\n  this._getUnscaledVertex(i, out);\n\n  out.x *= scale.x;\n  out.y *= scale.y;\n  out.z *= scale.z;\n  return out;\n};\n/**\n * Get raw vertex i\n * @private\n * @method _getUnscaledVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\n\n\nTrimesh.prototype._getUnscaledVertex = function (i, out) {\n  var i3 = i * 3;\n  var vertices = this.vertices;\n  return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);\n};\n/**\n * Get a vertex from the trimesh,transformed by the given position and quaternion.\n * @method getWorldVertex\n * @param  {number} i\n * @param  {Vec3} pos\n * @param  {Quaternion} quat\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\n\n\nTrimesh.prototype.getWorldVertex = function (i, pos, quat, out) {\n  this.getVertex(i, out);\n  Transform.pointToWorldFrame(pos, quat, out, out);\n  return out;\n};\n/**\n * Get the three vertices for triangle i.\n * @method getTriangleVertices\n * @param  {number} i\n * @param  {Vec3} a\n * @param  {Vec3} b\n * @param  {Vec3} c\n */\n\n\nTrimesh.prototype.getTriangleVertices = function (i, a, b, c) {\n  var i3 = i * 3;\n  this.getVertex(this.indices[i3], a);\n  this.getVertex(this.indices[i3 + 1], b);\n  this.getVertex(this.indices[i3 + 2], c);\n};\n/**\n * Compute the normal of triangle i.\n * @method getNormal\n * @param  {Number} i\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\n\n\nTrimesh.prototype.getNormal = function (i, target) {\n  var i3 = i * 3;\n  return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);\n};\n\nvar cli_aabb = new AABB();\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\n\nTrimesh.prototype.calculateLocalInertia = function (mass, target) {\n  // Approximate with box inertia\n  // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n  this.computeLocalAABB(cli_aabb);\n  var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,\n      y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,\n      z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;\n  return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\n/**\n * Compute the local AABB for the trimesh\n * @method computeLocalAABB\n * @param  {AABB} aabb\n */\n\nTrimesh.prototype.computeLocalAABB = function (aabb) {\n  var l = aabb.lowerBound,\n      u = aabb.upperBound,\n      n = this.vertices.length,\n      vertices = this.vertices,\n      v = computeLocalAABB_worldVert;\n  this.getVertex(0, v);\n  l.copy(v);\n  u.copy(v);\n\n  for (var i = 0; i !== n; i++) {\n    this.getVertex(i, v);\n\n    if (v.x < l.x) {\n      l.x = v.x;\n    } else if (v.x > u.x) {\n      u.x = v.x;\n    }\n\n    if (v.y < l.y) {\n      l.y = v.y;\n    } else if (v.y > u.y) {\n      u.y = v.y;\n    }\n\n    if (v.z < l.z) {\n      l.z = v.z;\n    } else if (v.z > u.z) {\n      u.z = v.z;\n    }\n  }\n};\n/**\n * Update the .aabb property\n * @method updateAABB\n */\n\n\nTrimesh.prototype.updateAABB = function () {\n  this.computeLocalAABB(this.aabb);\n};\n/**\n * Will update the .boundingSphereRadius property\n * @method updateBoundingSphereRadius\n */\n\n\nTrimesh.prototype.updateBoundingSphereRadius = function () {\n  // Assume points are distributed with local (0,0,0) as center\n  var max2 = 0;\n  var vertices = this.vertices;\n  var v = new Vec3();\n\n  for (var i = 0, N = vertices.length / 3; i !== N; i++) {\n    this.getVertex(i, v);\n    var norm2 = v.norm2();\n\n    if (norm2 > max2) {\n      max2 = norm2;\n    }\n  }\n\n  this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\nvar calculateWorldAABB_frame = new Transform();\nvar calculateWorldAABB_aabb = new AABB();\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\n\nTrimesh.prototype.calculateWorldAABB = function (pos, quat, min, max) {\n  /*\n  var n = this.vertices.length / 3,\n      verts = this.vertices;\n  var minx,miny,minz,maxx,maxy,maxz;\n   var v = tempWorldVertex;\n  for(var i=0; i<n; i++){\n      this.getVertex(i, v);\n      quat.vmult(v, v);\n      pos.vadd(v, v);\n      if (v.x < minx || minx===undefined){\n          minx = v.x;\n      } else if(v.x > maxx || maxx===undefined){\n          maxx = v.x;\n      }\n       if (v.y < miny || miny===undefined){\n          miny = v.y;\n      } else if(v.y > maxy || maxy===undefined){\n          maxy = v.y;\n      }\n       if (v.z < minz || minz===undefined){\n          minz = v.z;\n      } else if(v.z > maxz || maxz===undefined){\n          maxz = v.z;\n      }\n  }\n  min.set(minx,miny,minz);\n  max.set(maxx,maxy,maxz);\n  */\n  // Faster approximation using local AABB\n  var frame = calculateWorldAABB_frame;\n  var result = calculateWorldAABB_aabb;\n  frame.position = pos;\n  frame.quaternion = quat;\n  this.aabb.toWorldFrame(frame, result);\n  min.copy(result.lowerBound);\n  max.copy(result.upperBound);\n};\n/**\n * Get approximate volume\n * @method volume\n * @return {Number}\n */\n\n\nTrimesh.prototype.volume = function () {\n  return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n/**\n * Create a Trimesh instance, shaped as a torus.\n * @static\n * @method createTorus\n * @param  {number} [radius=1]\n * @param  {number} [tube=0.5]\n * @param  {number} [radialSegments=8]\n * @param  {number} [tubularSegments=6]\n * @param  {number} [arc=6.283185307179586]\n * @return {Trimesh} A torus\n */\n\n\nTrimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {\n  radius = radius || 1;\n  tube = tube || 0.5;\n  radialSegments = radialSegments || 8;\n  tubularSegments = tubularSegments || 6;\n  arc = arc || Math.PI * 2;\n  var vertices = [];\n  var indices = [];\n\n  for (var j = 0; j <= radialSegments; j++) {\n    for (var i = 0; i <= tubularSegments; i++) {\n      var u = i / tubularSegments * arc;\n      var v = j / radialSegments * Math.PI * 2;\n      var x = (radius + tube * Math.cos(v)) * Math.cos(u);\n      var y = (radius + tube * Math.cos(v)) * Math.sin(u);\n      var z = tube * Math.sin(v);\n      vertices.push(x, y, z);\n    }\n  }\n\n  for (var j = 1; j <= radialSegments; j++) {\n    for (var i = 1; i <= tubularSegments; i++) {\n      var a = (tubularSegments + 1) * j + i - 1;\n      var b = (tubularSegments + 1) * (j - 1) + i - 1;\n      var c = (tubularSegments + 1) * (j - 1) + i;\n      var d = (tubularSegments + 1) * j + i;\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  }\n\n  return new Trimesh(vertices, indices);\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/shapes/Trimesh.js"],"names":["module","exports","Trimesh","Shape","require","Vec3","Quaternion","Transform","AABB","Octree","vertices","indices","call","type","types","TRIMESH","Float32Array","Int16Array","normals","length","aabb","edges","scale","tree","updateEdges","updateNormals","updateAABB","updateBoundingSphereRadius","updateTree","prototype","constructor","computeNormals_n","reset","copy","lowerBound","x","y","z","upperBound","triangleAABB","a","b","c","points","i","i3","_getUnscaledVertex","setFromPoints","insert","removeEmptyNodes","unscaledAABB","getTrianglesInAABB","result","isx","isy","isz","l","u","aabbQuery","setScale","wasUniform","isUniform","n","getVertex","va","vb","vc","computeNormal","add","indexA","indexB","key","keys","Object","split","parseInt","getEdgeVertex","edgeIndex","firstOrSecond","vertexStore","vertexIndex","getEdgeVector_va","getEdgeVector_vb","getEdgeVector","vectorStore","vsub","cb","ab","target","cross","isZero","normalize","out","set","getWorldVertex","pos","quat","pointToWorldFrame","getTriangleVertices","getNormal","cli_aabb","calculateLocalInertia","mass","computeLocalAABB","computeLocalAABB_worldVert","v","max2","N","norm2","boundingSphereRadius","Math","sqrt","tempWorldVertex","calculateWorldAABB_frame","calculateWorldAABB_aabb","calculateWorldAABB","min","max","frame","position","quaternion","toWorldFrame","volume","PI","createTorus","radius","tube","radialSegments","tubularSegments","arc","j","cos","sin","push","d"],"mappings":"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","sourcesContent":["module.exports = Trimesh;\n\nvar Shape = require('./Shape');\nvar Vec3 = require('../math/Vec3');\nvar Quaternion = require('../math/Quaternion');\nvar Transform = require('../math/Transform');\nvar AABB = require('../collision/AABB');\nvar Octree = require('../utils/Octree');\n\n/**\n * @class Trimesh\n * @constructor\n * @param {array} vertices\n * @param {array} indices\n * @extends Shape\n * @example\n *     // How to make a mesh with a single triangle\n *     var vertices = [\n *         0, 0, 0, // vertex 0\n *         1, 0, 0, // vertex 1\n *         0, 1, 0  // vertex 2\n *     ];\n *     var indices = [\n *         0, 1, 2  // triangle 0\n *     ];\n *     var trimeshShape = new Trimesh(vertices, indices);\n */\nfunction Trimesh(vertices, indices) {\n    Shape.call(this, {\n        type: Shape.types.TRIMESH\n    });\n\n    /**\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = new Float32Array(vertices);\n\n    /**\n     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.\n     * @property indices\n     * @type {Array}\n     */\n    this.indices = new Int16Array(indices);\n\n    /**\n     * The normals data.\n     * @property normals\n     * @type {Array}\n     */\n    this.normals = new Float32Array(indices.length);\n\n    /**\n     * The local AABB of the mesh.\n     * @property aabb\n     * @type {Array}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * References to vertex pairs, making up all unique edges in the trimesh.\n     * @property {array} edges\n     */\n    this.edges = null;\n\n    /**\n     * Local scaling of the mesh. Use .setScale() to set it.\n     * @property {Vec3} scale\n     */\n    this.scale = new Vec3(1, 1, 1);\n\n    /**\n     * The indexed triangles. Use .updateTree() to update it.\n     * @property {Octree} tree\n     */\n    this.tree = new Octree();\n\n    this.updateEdges();\n    this.updateNormals();\n    this.updateAABB();\n    this.updateBoundingSphereRadius();\n    this.updateTree();\n}\nTrimesh.prototype = new Shape();\nTrimesh.prototype.constructor = Trimesh;\n\nvar computeNormals_n = new Vec3();\n\n/**\n * @method updateTree\n */\nTrimesh.prototype.updateTree = function(){\n    var tree = this.tree;\n\n    tree.reset();\n    tree.aabb.copy(this.aabb);\n    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled\n    tree.aabb.lowerBound.x *= 1 / scale.x;\n    tree.aabb.lowerBound.y *= 1 / scale.y;\n    tree.aabb.lowerBound.z *= 1 / scale.z;\n    tree.aabb.upperBound.x *= 1 / scale.x;\n    tree.aabb.upperBound.y *= 1 / scale.y;\n    tree.aabb.upperBound.z *= 1 / scale.z;\n\n    // Insert all triangles\n    var triangleAABB = new AABB();\n    var a = new Vec3();\n    var b = new Vec3();\n    var c = new Vec3();\n    var points = [a, b, c];\n    for (var i = 0; i < this.indices.length / 3; i++) {\n        //this.getTriangleVertices(i, a, b, c);\n\n        // Get unscaled triangle verts\n        var i3 = i * 3;\n        this._getUnscaledVertex(this.indices[i3], a);\n        this._getUnscaledVertex(this.indices[i3 + 1], b);\n        this._getUnscaledVertex(this.indices[i3 + 2], c);\n\n        triangleAABB.setFromPoints(points);\n        tree.insert(triangleAABB, i);\n    }\n    tree.removeEmptyNodes();\n};\n\nvar unscaledAABB = new AABB();\n\n/**\n * Get triangles in a local AABB from the trimesh.\n * @method getTrianglesInAABB\n * @param  {AABB} aabb\n * @param  {array} result An array of integers, referencing the queried triangles.\n */\nTrimesh.prototype.getTrianglesInAABB = function(aabb, result){\n    unscaledAABB.copy(aabb);\n\n    // Scale it to local\n    var scale = this.scale;\n    var isx = scale.x;\n    var isy = scale.y;\n    var isz = scale.z;\n    var l = unscaledAABB.lowerBound;\n    var u = unscaledAABB.upperBound;\n    l.x /= isx;\n    l.y /= isy;\n    l.z /= isz;\n    u.x /= isx;\n    u.y /= isy;\n    u.z /= isz;\n\n    return this.tree.aabbQuery(unscaledAABB, result);\n};\n\n/**\n * @method setScale\n * @param {Vec3} scale\n */\nTrimesh.prototype.setScale = function(scale){\n    var wasUniform = this.scale.x === this.scale.y === this.scale.z;\n    var isUniform = scale.x === scale.y === scale.z;\n\n    if(!(wasUniform && isUniform)){\n        // Non-uniform scaling. Need to update normals.\n        this.updateNormals();\n    }\n    this.scale.copy(scale);\n    this.updateAABB();\n    this.updateBoundingSphereRadius();\n};\n\n/**\n * Compute the normals of the faces. Will save in the .normals array.\n * @method updateNormals\n */\nTrimesh.prototype.updateNormals = function(){\n    var n = computeNormals_n;\n\n    // Generate normals\n    var normals = this.normals;\n    for(var i=0; i < this.indices.length / 3; i++){\n        var i3 = i * 3;\n\n        var a = this.indices[i3],\n            b = this.indices[i3 + 1],\n            c = this.indices[i3 + 2];\n\n        this.getVertex(a, va);\n        this.getVertex(b, vb);\n        this.getVertex(c, vc);\n\n        Trimesh.computeNormal(vb, va, vc, n);\n\n        normals[i3] = n.x;\n        normals[i3 + 1] = n.y;\n        normals[i3 + 2] = n.z;\n    }\n};\n\n/**\n * Update the .edges property\n * @method updateEdges\n */\nTrimesh.prototype.updateEdges = function(){\n    var edges = {};\n    var add = function(indexA, indexB){\n        var key = a < b ? a + '_' + b : b + '_' + a;\n        edges[key] = true;\n    };\n    for(var i=0; i < this.indices.length / 3; i++){\n        var i3 = i * 3;\n        var a = this.indices[i3],\n            b = this.indices[i3 + 1],\n            c = this.indices[i3 + 2];\n        add(a,b);\n        add(b,c);\n        add(c,a);\n    }\n    var keys = Object.keys(edges);\n    this.edges = new Int16Array(keys.length * 2);\n    for (var i = 0; i < keys.length; i++) {\n        var indices = keys[i].split('_');\n        this.edges[2 * i] = parseInt(indices[0], 10);\n        this.edges[2 * i + 1] = parseInt(indices[1], 10);\n    }\n};\n\n/**\n * Get an edge vertex\n * @method getEdgeVertex\n * @param  {number} edgeIndex\n * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.\n * @param  {Vec3} vertexStore Where to store the result\n */\nTrimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){\n    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];\n    this.getVertex(vertexIndex, vertexStore);\n};\n\nvar getEdgeVector_va = new Vec3();\nvar getEdgeVector_vb = new Vec3();\n\n/**\n * Get a vector along an edge.\n * @method getEdgeVector\n * @param  {number} edgeIndex\n * @param  {Vec3} vectorStore\n */\nTrimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){\n    var va = getEdgeVector_va;\n    var vb = getEdgeVector_vb;\n    this.getEdgeVertex(edgeIndex, 0, va);\n    this.getEdgeVertex(edgeIndex, 1, vb);\n    vb.vsub(va, vectorStore);\n};\n\n/**\n * Get face normal given 3 vertices\n * @static\n * @method computeNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\nvar cb = new Vec3();\nvar ab = new Vec3();\nTrimesh.computeNormal = function ( va, vb, vc, target ) {\n    vb.vsub(va,ab);\n    vc.vsub(vb,cb);\n    cb.cross(ab,target);\n    if ( !target.isZero() ) {\n        target.normalize();\n    }\n};\n\nvar va = new Vec3();\nvar vb = new Vec3();\nvar vc = new Vec3();\n\n/**\n * Get vertex i.\n * @method getVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype.getVertex = function(i, out){\n    var scale = this.scale;\n    this._getUnscaledVertex(i, out);\n    out.x *= scale.x;\n    out.y *= scale.y;\n    out.z *= scale.z;\n    return out;\n};\n\n/**\n * Get raw vertex i\n * @private\n * @method _getUnscaledVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype._getUnscaledVertex = function(i, out){\n    var i3 = i * 3;\n    var vertices = this.vertices;\n    return out.set(\n        vertices[i3],\n        vertices[i3 + 1],\n        vertices[i3 + 2]\n    );\n};\n\n/**\n * Get a vertex from the trimesh,transformed by the given position and quaternion.\n * @method getWorldVertex\n * @param  {number} i\n * @param  {Vec3} pos\n * @param  {Quaternion} quat\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype.getWorldVertex = function(i, pos, quat, out){\n    this.getVertex(i, out);\n    Transform.pointToWorldFrame(pos, quat, out, out);\n    return out;\n};\n\n/**\n * Get the three vertices for triangle i.\n * @method getTriangleVertices\n * @param  {number} i\n * @param  {Vec3} a\n * @param  {Vec3} b\n * @param  {Vec3} c\n */\nTrimesh.prototype.getTriangleVertices = function(i, a, b, c){\n    var i3 = i * 3;\n    this.getVertex(this.indices[i3], a);\n    this.getVertex(this.indices[i3 + 1], b);\n    this.getVertex(this.indices[i3 + 2], c);\n};\n\n/**\n * Compute the normal of triangle i.\n * @method getNormal\n * @param  {Number} i\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\nTrimesh.prototype.getNormal = function(i, target){\n    var i3 = i * 3;\n    return target.set(\n        this.normals[i3],\n        this.normals[i3 + 1],\n        this.normals[i3 + 2]\n    );\n};\n\nvar cli_aabb = new AABB();\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\nTrimesh.prototype.calculateLocalInertia = function(mass,target){\n    // Approximate with box inertia\n    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n    this.computeLocalAABB(cli_aabb);\n    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,\n        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,\n        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;\n    return target.set(\n        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),\n        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),\n        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )\n    );\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\n\n/**\n * Compute the local AABB for the trimesh\n * @method computeLocalAABB\n * @param  {AABB} aabb\n */\nTrimesh.prototype.computeLocalAABB = function(aabb){\n    var l = aabb.lowerBound,\n        u = aabb.upperBound,\n        n = this.vertices.length,\n        vertices = this.vertices,\n        v = computeLocalAABB_worldVert;\n\n    this.getVertex(0, v);\n    l.copy(v);\n    u.copy(v);\n\n    for(var i=0; i !== n; i++){\n        this.getVertex(i, v);\n\n        if(v.x < l.x){\n            l.x = v.x;\n        } else if(v.x > u.x){\n            u.x = v.x;\n        }\n\n        if(v.y < l.y){\n            l.y = v.y;\n        } else if(v.y > u.y){\n            u.y = v.y;\n        }\n\n        if(v.z < l.z){\n            l.z = v.z;\n        } else if(v.z > u.z){\n            u.z = v.z;\n        }\n    }\n};\n\n\n/**\n * Update the .aabb property\n * @method updateAABB\n */\nTrimesh.prototype.updateAABB = function(){\n    this.computeLocalAABB(this.aabb);\n};\n\n/**\n * Will update the .boundingSphereRadius property\n * @method updateBoundingSphereRadius\n */\nTrimesh.prototype.updateBoundingSphereRadius = function(){\n    // Assume points are distributed with local (0,0,0) as center\n    var max2 = 0;\n    var vertices = this.vertices;\n    var v = new Vec3();\n    for(var i=0, N=vertices.length / 3; i !== N; i++) {\n        this.getVertex(i, v);\n        var norm2 = v.norm2();\n        if(norm2 > max2){\n            max2 = norm2;\n        }\n    }\n    this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\nvar calculateWorldAABB_frame = new Transform();\nvar calculateWorldAABB_aabb = new AABB();\n\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\nTrimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    /*\n    var n = this.vertices.length / 3,\n        verts = this.vertices;\n    var minx,miny,minz,maxx,maxy,maxz;\n\n    var v = tempWorldVertex;\n    for(var i=0; i<n; i++){\n        this.getVertex(i, v);\n        quat.vmult(v, v);\n        pos.vadd(v, v);\n        if (v.x < minx || minx===undefined){\n            minx = v.x;\n        } else if(v.x > maxx || maxx===undefined){\n            maxx = v.x;\n        }\n\n        if (v.y < miny || miny===undefined){\n            miny = v.y;\n        } else if(v.y > maxy || maxy===undefined){\n            maxy = v.y;\n        }\n\n        if (v.z < minz || minz===undefined){\n            minz = v.z;\n        } else if(v.z > maxz || maxz===undefined){\n            maxz = v.z;\n        }\n    }\n    min.set(minx,miny,minz);\n    max.set(maxx,maxy,maxz);\n    */\n\n    // Faster approximation using local AABB\n    var frame = calculateWorldAABB_frame;\n    var result = calculateWorldAABB_aabb;\n    frame.position = pos;\n    frame.quaternion = quat;\n    this.aabb.toWorldFrame(frame, result);\n    min.copy(result.lowerBound);\n    max.copy(result.upperBound);\n};\n\n/**\n * Get approximate volume\n * @method volume\n * @return {Number}\n */\nTrimesh.prototype.volume = function(){\n    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n\n/**\n * Create a Trimesh instance, shaped as a torus.\n * @static\n * @method createTorus\n * @param  {number} [radius=1]\n * @param  {number} [tube=0.5]\n * @param  {number} [radialSegments=8]\n * @param  {number} [tubularSegments=6]\n * @param  {number} [arc=6.283185307179586]\n * @return {Trimesh} A torus\n */\nTrimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {\n    radius = radius || 1;\n    tube = tube || 0.5;\n    radialSegments = radialSegments || 8;\n    tubularSegments = tubularSegments || 6;\n    arc = arc || Math.PI * 2;\n\n    var vertices = [];\n    var indices = [];\n\n    for ( var j = 0; j <= radialSegments; j ++ ) {\n        for ( var i = 0; i <= tubularSegments; i ++ ) {\n            var u = i / tubularSegments * arc;\n            var v = j / radialSegments * Math.PI * 2;\n\n            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n            var z = tube * Math.sin( v );\n\n            vertices.push( x, y, z );\n        }\n    }\n\n    for ( var j = 1; j <= radialSegments; j ++ ) {\n        for ( var i = 1; i <= tubularSegments; i ++ ) {\n            var a = ( tubularSegments + 1 ) * j + i - 1;\n            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n            var d = ( tubularSegments + 1 ) * j + i;\n\n            indices.push(a, b, d);\n            indices.push(b, c, d);\n        }\n    }\n\n    return new Trimesh(vertices, indices);\n};\n"]},"metadata":{},"sourceType":"script"}