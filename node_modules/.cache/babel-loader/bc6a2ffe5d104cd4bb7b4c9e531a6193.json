{"ast":null,"code":"module.exports = ContactEquation;\n\nvar Equation = require('./Equation');\n\nvar Vec3 = require('../math/Vec3');\n\nvar Mat3 = require('../math/Mat3');\n/**\n * Contact/non-penetration constraint equation\n * @class ContactEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @extends Equation\n */\n\n\nfunction ContactEquation(bodyA, bodyB, maxForce) {\n  maxForce = typeof maxForce !== 'undefined' ? maxForce : 1e6;\n  Equation.call(this, bodyA, bodyB, 0, maxForce);\n  /**\n   * @property restitution\n   * @type {Number}\n   */\n\n  this.restitution = 0.0; // \"bounciness\": u1 = -e*u0\n\n  /**\n   * World-oriented vector that goes from the center of bi to the contact point.\n   * @property {Vec3} ri\n   */\n\n  this.ri = new Vec3();\n  /**\n   * World-oriented vector that starts in body j position and goes to the contact point.\n   * @property {Vec3} rj\n   */\n\n  this.rj = new Vec3();\n  /**\n   * Contact normal, pointing out of body i.\n   * @property {Vec3} ni\n   */\n\n  this.ni = new Vec3();\n}\n\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\nvar ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors\n\nvar ContactEquation_computeB_temp2 = new Vec3();\nvar ContactEquation_computeB_temp3 = new Vec3();\n\nContactEquation.prototype.computeB = function (h) {\n  var a = this.a,\n      b = this.b,\n      bi = this.bi,\n      bj = this.bj,\n      ri = this.ri,\n      rj = this.rj,\n      rixn = ContactEquation_computeB_temp1,\n      rjxn = ContactEquation_computeB_temp2,\n      vi = bi.velocity,\n      wi = bi.angularVelocity,\n      fi = bi.force,\n      taui = bi.torque,\n      vj = bj.velocity,\n      wj = bj.angularVelocity,\n      fj = bj.force,\n      tauj = bj.torque,\n      penetrationVec = ContactEquation_computeB_temp3,\n      GA = this.jacobianElementA,\n      GB = this.jacobianElementB,\n      n = this.ni; // Caluclate cross products\n\n  ri.cross(n, rixn);\n  rj.cross(n, rjxn); // g = xj+rj -(xi+ri)\n  // G = [ -ni  -rixn  ni  rjxn ]\n\n  n.negate(GA.spatial);\n  rixn.negate(GA.rotational);\n  GB.spatial.copy(n);\n  GB.rotational.copy(rjxn); // Calculate the penetration vector\n\n  penetrationVec.copy(bj.position);\n  penetrationVec.vadd(rj, penetrationVec);\n  penetrationVec.vsub(bi.position, penetrationVec);\n  penetrationVec.vsub(ri, penetrationVec);\n  var g = n.dot(penetrationVec); // Compute iteration\n\n  var ePlusOne = this.restitution + 1;\n  var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);\n  var GiMf = this.computeGiMf();\n  var B = -g * a - GW * b - h * GiMf;\n  return B;\n};\n\nvar ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();\n/**\n * Get the current relative velocity in the contact point.\n * @method getImpactVelocityAlongNormal\n * @return {number}\n */\n\nContactEquation.prototype.getImpactVelocityAlongNormal = function () {\n  var vi = ContactEquation_getImpactVelocityAlongNormal_vi;\n  var vj = ContactEquation_getImpactVelocityAlongNormal_vj;\n  var xi = ContactEquation_getImpactVelocityAlongNormal_xi;\n  var xj = ContactEquation_getImpactVelocityAlongNormal_xj;\n  var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;\n  this.bi.position.vadd(this.ri, xi);\n  this.bj.position.vadd(this.rj, xj);\n  this.bi.getVelocityAtWorldPoint(xi, vi);\n  this.bj.getVelocityAtWorldPoint(xj, vj);\n  vi.vsub(vj, relVel);\n  return this.ni.dot(relVel);\n};","map":{"version":3,"sources":["C:/Users/aite5/Desktop/nabla.ooo/node_modules/cannon/src/equations/ContactEquation.js"],"names":["module","exports","ContactEquation","Equation","require","Vec3","Mat3","bodyA","bodyB","maxForce","call","restitution","ri","rj","ni","prototype","constructor","ContactEquation_computeB_temp1","ContactEquation_computeB_temp2","ContactEquation_computeB_temp3","computeB","h","a","b","bi","bj","rixn","rjxn","vi","velocity","wi","angularVelocity","fi","force","taui","torque","vj","wj","fj","tauj","penetrationVec","GA","jacobianElementA","GB","jacobianElementB","n","cross","negate","spatial","rotational","copy","position","vadd","vsub","g","dot","ePlusOne","GW","GiMf","computeGiMf","B","ContactEquation_getImpactVelocityAlongNormal_vi","ContactEquation_getImpactVelocityAlongNormal_vj","ContactEquation_getImpactVelocityAlongNormal_xi","ContactEquation_getImpactVelocityAlongNormal_xj","ContactEquation_getImpactVelocityAlongNormal_relVel","getImpactVelocityAlongNormal","xi","xj","relVel","getVelocityAtWorldPoint"],"mappings":"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","sourcesContent":["module.exports = ContactEquation;\n\nvar Equation = require('./Equation');\nvar Vec3 = require('../math/Vec3');\nvar Mat3 = require('../math/Mat3');\n\n/**\n * Contact/non-penetration constraint equation\n * @class ContactEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @extends Equation\n */\nfunction ContactEquation(bodyA, bodyB, maxForce){\n    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;\n    Equation.call(this, bodyA, bodyB, 0, maxForce);\n\n    /**\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0.0; // \"bounciness\": u1 = -e*u0\n\n    /**\n     * World-oriented vector that goes from the center of bi to the contact point.\n     * @property {Vec3} ri\n     */\n    this.ri = new Vec3();\n\n    /**\n     * World-oriented vector that starts in body j position and goes to the contact point.\n     * @property {Vec3} rj\n     */\n    this.rj = new Vec3();\n\n    /**\n     * Contact normal, pointing out of body i.\n     * @property {Vec3} ni\n     */\n    this.ni = new Vec3();\n}\n\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\n\nvar ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors\nvar ContactEquation_computeB_temp2 = new Vec3();\nvar ContactEquation_computeB_temp3 = new Vec3();\nContactEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixn = ContactEquation_computeB_temp1,\n        rjxn = ContactEquation_computeB_temp2,\n\n        vi = bi.velocity,\n        wi = bi.angularVelocity,\n        fi = bi.force,\n        taui = bi.torque,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity,\n        fj = bj.force,\n        tauj = bj.torque,\n\n        penetrationVec = ContactEquation_computeB_temp3,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n\n        n = this.ni;\n\n    // Caluclate cross products\n    ri.cross(n,rixn);\n    rj.cross(n,rjxn);\n\n    // g = xj+rj -(xi+ri)\n    // G = [ -ni  -rixn  ni  rjxn ]\n    n.negate(GA.spatial);\n    rixn.negate(GA.rotational);\n    GB.spatial.copy(n);\n    GB.rotational.copy(rjxn);\n\n    // Calculate the penetration vector\n    penetrationVec.copy(bj.position);\n    penetrationVec.vadd(rj,penetrationVec);\n    penetrationVec.vsub(bi.position,penetrationVec);\n    penetrationVec.vsub(ri,penetrationVec);\n\n    var g = n.dot(penetrationVec);\n\n    // Compute iteration\n    var ePlusOne = this.restitution + 1;\n    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);\n    var GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h*GiMf;\n\n    return B;\n};\n\nvar ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();\n\n/**\n * Get the current relative velocity in the contact point.\n * @method getImpactVelocityAlongNormal\n * @return {number}\n */\nContactEquation.prototype.getImpactVelocityAlongNormal = function(){\n    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;\n    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;\n    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;\n    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;\n    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;\n\n    this.bi.position.vadd(this.ri, xi);\n    this.bj.position.vadd(this.rj, xj);\n\n    this.bi.getVelocityAtWorldPoint(xi, vi);\n    this.bj.getVelocityAtWorldPoint(xj, vj);\n\n    vi.vsub(vj, relVel);\n\n    return this.ni.dot(relVel);\n};\n\n"]},"metadata":{},"sourceType":"script"}